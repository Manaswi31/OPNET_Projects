/* Process model C form file: bt_master.pr.c */
/* Portions of this file copyright 2014 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from bt_master.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char bt_master_pr_c [] = "MIL_3_Tfile_Hdr_ 1800 30A op_runsim_opt 7 55C31F81 55C31F81 1 volta chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 468d 2                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/***********************************************/
// The SuiteTooth model set was developed by
// HIGHLAND SYSTEMS, INC.
//
// It incorporates code available in the public
// domain and other code that is the property of
// OPNET Technologies, Inc.
//
// Inquiries may be addressed to:
// 
// Highland Systems, Inc.
// (703) 312 0830
// info@highsys.com
// www.highsys.com
/***********************************************/

#include <math.h>
#include "oms_pr.h"

#define SLOT_TIME    .000625
#define ERROR        101

#define ACK          1
#define NAK          0

/****** Changes to max piconets (in particular, an increase) */
/******   requires a similar increase to the count field of  */
/*****    dimensioned statistics Slave tput and BT tput      */
/*****    AND also a change to max piconets in the slaves HB */	
#define MAX_PICONETS 100	

/* define streams */
#define STOCHASTIC_INSTREAM  			0
#define BT_INSTREAM         			1
#define BT_OUTSTREAM         			1
#define STOCHASTIC_OUTSTREAM 		    0
#define APP_INSTREAM 		 			2
#define APP_OUTSTREAM 		 			2
#define CONTROL_INSTREAM   				3
#define CONTROL_OUTSTREAM				3

/* define possible transmission/self interrupt types */
#define POLL        		1
#define SCO         		2
#define ACL_RETX    		4
#define ACL         		5
#define NULL_TX     		6
#define TX          		7
#define FREQ_HOP   			8
#define TX_ERROR    		9
/* CONTROL is used in the L_CH packet header.  It is defined as binary '11' in the spec */
#define CONTROL     		10
#define TX_WAIT     		11
#define NO_TX       		12
#define SCHEDULED_VOICE  	15
/* USER_DATA is the default logical channel, used to represent */
/*  ACL, SCO, POLLS, NULLS, or retransmissions. */
#define USER_DATA			16


/* define packet types */

#define NULL_PKT            0
#define HV1                 1
#define HV2                 2
#define HV3                 3
#define DM1                 4
#define DM3                 5
#define DM5                 6
#define DH1                 7
#define DH3                 8
#define DH5                 9
#define POLL_PKT            10

/* define header bit sizes */
#define ACCESS_CODE         72
#define HEADER              54
#define SS_PAYLOAD_HEADER    8
#define MS_PAYLOAD_HEADER   16

#define TYPE                 0
#define OVERHEAD             1
#define SLOTS                2
#define CON                  3

/* define constant packet payload values */
#define HV1_PAYLOAD         80        
#define HV2_PAYLOAD        160 
#define HV3_PAYLOAD        240 
#define HV1_FEC            160
#define HV2_FEC             80
#define HV3_FEC              0
#define DM1_PAYLOAD        136        
#define DH1_PAYLOAD        216 
#define DM3_PAYLOAD        968 
#define DH3_PAYLOAD        1464
#define DM5_PAYLOAD        1792
#define DH5_PAYLOAD        2712


#define SLAVE_0             0
#define SLAVE_6             6

#define MASTER_TO_SLAVE     0
#define SLAVE_TO_MASTER     1

/* Define the transition macros */
#define BEGSIM              op_intrpt_type() == OPC_INTRPT_BEGSIM
#define FROM_STOC_OR_APP_OR_LM    op_intrpt_type() == OPC_INTRPT_STRM &&\
	(op_intrpt_strm() == STOCHASTIC_INSTREAM || op_intrpt_strm() == APP_INSTREAM || op_intrpt_strm() == CONTROL_INSTREAM)
#define SLAVE_DONE          op_intrpt_type() == OPC_INTRPT_REMOTE
#define PACKET_RECEIVED     op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm() == BT_INSTREAM
#define TRANSMIT            op_intrpt_type() == OPC_INTRPT_SELF && (op_intrpt_code() == TX || op_intrpt_code() == SCHEDULED_VOICE || op_intrpt_code() == POLL)
#define HOP                 op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code() == FREQ_HOP
#define NO_RESPONSE         op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code() >= 20
#define SLAVE_RESPONSE      op_intrpt_type() == OPC_INTRPT_REMOTE
#define FROM_LM             op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm() == CONTROL_INSTREAM 


#define SET_AT_SLAVE       -1
#define CUSTOM              0
#define CLEAR				0
#define CONGESTED			1

#define VOICE               0
#define DATA                1

#define MIN_FREQ		2402
#define FREQ_OFFSET		   1
#define NUMBER_OF_HOPS		79	
#define	SEGMENT_SIZE		32	
#define	DELTA				16	
#define NUMBER_OF_SLOTS		134217728	/* 2^27 modulo for slots counter */
#define	TS			   		.000625		/* The TS unit is 625uS */

#define BT_TRACE_ACTIVE		    	(op_prg_odb_ltrace_active ("bluetooth_master"))
#define BT_TIMING_TRACE_ACTIVE		(op_prg_odb_ltrace_active ("master_slot_timing"))
#define BT_SCO_TRACE_ACTIVE			(op_prg_odb_ltrace_active ("master_sco"))
#define BT_HOP_TRACE_ACTIVE			(op_prg_odb_ltrace_active ("hop"))
#define BT_ACL_TRACE_ACTIVE			(op_prg_odb_ltrace_active ("acl"))
#define BT_ARQ_TRACE_ACTIVE			(op_prg_odb_ltrace_active ("arq"))
#define BT_SCHEDULER_TRACE_ACTIVE	(op_prg_odb_ltrace_active ("scheduler"))
#define BT_NOTX_TRACE_ACTIVE		(op_prg_odb_ltrace_active ("notx"))
#define BT_ADDR_TRACE_ACTIVE		(op_prg_odb_ltrace_active ("addressing"))
 
/* global vars for stats */
double Gb_tput[MAX_PICONETS];
double Gb_overhead_tput[MAX_PICONETS];
double Gb_fec_tput[MAX_PICONETS];
//long  Gb_bt_pk_reception_count;
//long  Gb_bt_pk_loss_count;


/* Global stathandle, defined in coexist_ecc.ps.c. */
/* Values are written in the pipeline. */
extern Stathandle Gb_bt_pkloss_rate_stat;

/* Global payload_errors as determined in coexist_ecc.ps.c */
//extern payload_errors;

/* global vars for logs */
Log_Handle config_log_handle;
Log_Handle protocol_log_handle;
int sim_log_initialized;

/* global variable for pathloss model */
/* this sim attribute is read in and stored as a global to 
avoid reading it in many times during a simulation */
int Pathloss_Model;

/* function prototypes */
void change_frequencies (double hop);
void    bt_init_seg_hop_table();
static int bt_next_freq_hop ();
void	bt_mst_mac_error (char * fcnt, char * msg, char * opt);
int init_piconet (Objid my_id);
int get_tx_type();
int next_tx_event(char*);
int packet_select(int tx_type);
Packet* packet_create(int pk_type);
void get_pk_type(char* bt_pk_type, int* type);
void update_last_poll();
void hop(int);
void send_bt_pk(int, char*);

/* define datatypes */
typedef struct
	{
	int					slave_obj_id;
	int					tx_channel_attr_id;
	int					rx_channel_attr_id;
	}Piconet_Slave;

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Piconet_Slave	          		piconet_table[7]                                ;	/* table of slave object ids: also has tx and rx channel objids */
	Objid	                  		rx_channel_objid                                ;	/* master's receiver channel object id */
	Objid	                  		tx_channel_objid                                ;	/* master's transmitter channel object id */
	Sbhandle	               		Acl_seg_buf[8]                                  ;	/* segmentation buffer for incoming stochastic traffic */
	Sbhandle	               		Sco_seg_buf[3]                                  ;	/* segmentation buffer for incoming voice (via stochastic) */
	                        		                                                	/* traffic                                                 */
	Sbhandle	               		Rsm_buf[7]                                      ;	/* Reassembly buffers, one for each slave in the piconet */
	int	                    		My_piconet_address                              ;	/* value read from model attr. */
	int	                    		hop_inside_index                                ;	/* index used to select next hop */
	int	                    		segment_hop_table[SEGMENT_SIZE]                 ;	/* array of hops within the current segment */
	int	                    		hop_segment_index                               ;	/* used to set segment for segment hop table */
	int	                    		hop_table[NUMBER_OF_HOPS]                       ;	/* array of hops available */
	int	                    		Tsco                                            ;	/* Number of timeslots between SCO transmissions */
	int	                    		Poll_interval                                   ;	/* Number of timeslots between guaranteed ACL packet delivery to */
	                        		                                                	/* slaves in the piconet                                         */
	int	                    		Channel_condition                               ;
	int	                    		Tx_slots                                        ;	/* determines the number of slots the master will use to */
	                        		                                                	/* transmit ACL packets                                  */
	int	                    		Slave_tx_slots[7]                               ;	/* defines the number of slots used by the slaves of the piconet for */
	                        		                                                	/* ACL transmissions.                                                */
	int	                    		Number_of_slaves                                ;	/* Number of slaves in the piconet.  Value is returned */
	                        		                                                	/* by init_piconet();                                  */
	int*	                   		Slave_channel_condition_ptrs[7]                 ;	/* array of pointers to slave channel condition state   */
	                        		                                                	/* variables.  Can be used to adaptively change channel */
	                        		                                                	/* conditions.                                          */
	int	                    		Slave_channel_condition[7]                      ;
	int	                    		SCO_con[3]                                      ;	/* array of slave destination addresses for which */
	                        		                                                	/* an SCO connection exists                       */
	int	                    		Num_SCO_cons                                    ;	/* Number of current SCO connections in this piconet */
	int	                    		Current_slot                                    ;	/* current Bluetooth clock slot */
	int	                    		Current_slot_mod                                ;	/* current slot mod Tsco, used for sco reservations */
	int	                    		Last_hop_slot                                   ;	/* timeslot value of the last frequency hop. */
	int	                    		Dest_addr                                       ;	/* address of next slave to receive from the master. */
	int	                    		Last_poll[7]                                    ;
	int	                    		Last_poll_update                                ;
	int	                    		Last_slave_polled                               ;
	int	                    		Poll_slave_synch                                ;
	int	                    		Retx[7]                                         ;	/* Boolean, set to true if slave[n] need a retransmission. */
	int	                    		Next_acl_slave                                  ;	/* Next slave to be sent data (if master has any for it) according */
	                        		                                                	/* to the round-robin algorithm.                                   */
	int	                    		Seqn[7]                                         ;	/* Sequence number (bit value) assigned to successive ACL packets. */
	int	                    		Seqn_old[7]                                     ;	/* Last sequence number received in ACL packet from slave n */
	int	                    		Slave_to_ack[7]                                 ;	/* Boolean; determines if a slave needs to be acked. */
	int	                    		Arq[7]                                          ;	/* ARQN bit field value for sent packets */
	int	                    		Last_acl_pk_type[7]                             ;	/* stores format of last sent ACL packet; needed for retransmissions. */
	int	                    		Slave_response_slot                             ;
	int	                    		Next_free_slot                                  ;
	int	                    		Acl_pending                                     ;
	int	                    		Use_next_free_slot                              ;
	int	                    		Pk_count[2]                                     ;
	int	                    		Next_control_slave                              ;
	int	                    		Logical_channel                                 ;
	Stathandle	             		Mac_packets_sent_stat                           ;
	Stathandle	             		Mac_packets_recv_stat                           ;
	Stathandle	             		Mac_pkt_lost_stat                               ;
	Stathandle	             		Sco_pkt_received_stat                           ;
	Stathandle	             		Sco_pkt_sent_stat                               ;
	Stathandle	             		Mac_throughput_stat                             ;
	Stathandle	             		Hop_value_stat                                  ;
	Stathandle	             		Mac_fec_throughput_stat                         ;
	Stathandle	             		Offset_gb_stat                                  ;
	Stathandle	             		Gb_tput_stat                                    ;
	Stathandle	             		Gb_overhead_tput_stat                           ;
	Stathandle	             		Gb_fec_tput_stat                                ;
	Stathandle	             		Poll_pkts_sent_stat                             ;
	Stathandle	             		Acl_pk_sent_stat                                ;
	Stathandle	             		Acl_pk_received_stat                            ;
	Stathandle	             		Retx_stat                                       ;
	Stathandle	             		Null_pk_sent_stat                               ;
	Stathandle	             		Tx_skipped_stat                                 ;
	Stathandle	             		Dropped_sco_stat                                ;
	Stathandle	             		Nulls_received_stat                             ;
	Stathandle	             		Control_packets_sent_stat                       ;
	Stathandle	             		Control_packets_received_stat                   ;
	Stathandle	             		Mac_sdu_delay_stat                              ;
	Stathandle	             		Control_packets_from_slave_stat                 ;
	Stathandle	             		Control_packets_to_slave_stat                   ;
	Stathandle	             		Control_packets_sent_gb_stat                    ;
	Stathandle	             		Control_packets_received_gb_stat                ;
	Stathandle	             		Gb_aggregate_tput_stat                          ;
	Stathandle	             		Residual_sco_payload_errors_stat                ;
	Evhandle	               		Evh_poll                                        ;
	Evhandle	               		No_response_evh                                 ;
	Evhandle	               		Evh_tx                                          ;	/* Transmit event handle */
	Evhandle	               		Evh_voice                                       ;
	double	                 		Voice_source_pk_size                            ;
	double	                 		Offset                                          ;	/* Duration of up to 2 timeslots for which a piconet's timing */
	                        		                                                	/* is offset to other piconets in the network.                */
	double	                 		tx_old                                          ;
	Packet *	               		Retx_pkptr[7]                                   ;	/* pointer to copy of last sent packet type. */
	} bt_master_state;

#define pr_state_ptr            		((bt_master_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))
#define piconet_table           		pr_state_ptr->piconet_table
#define rx_channel_objid        		pr_state_ptr->rx_channel_objid
#define tx_channel_objid        		pr_state_ptr->tx_channel_objid
#define Acl_seg_buf             		pr_state_ptr->Acl_seg_buf
#define Sco_seg_buf             		pr_state_ptr->Sco_seg_buf
#define Rsm_buf                 		pr_state_ptr->Rsm_buf
#define My_piconet_address      		pr_state_ptr->My_piconet_address
#define hop_inside_index        		pr_state_ptr->hop_inside_index
#define segment_hop_table       		pr_state_ptr->segment_hop_table
#define hop_segment_index       		pr_state_ptr->hop_segment_index
#define hop_table               		pr_state_ptr->hop_table
#define Tsco                    		pr_state_ptr->Tsco
#define Poll_interval           		pr_state_ptr->Poll_interval
#define Channel_condition       		pr_state_ptr->Channel_condition
#define Tx_slots                		pr_state_ptr->Tx_slots
#define Slave_tx_slots          		pr_state_ptr->Slave_tx_slots
#define Number_of_slaves        		pr_state_ptr->Number_of_slaves
#define Slave_channel_condition_ptrs		pr_state_ptr->Slave_channel_condition_ptrs
#define Slave_channel_condition 		pr_state_ptr->Slave_channel_condition
#define SCO_con                 		pr_state_ptr->SCO_con
#define Num_SCO_cons            		pr_state_ptr->Num_SCO_cons
#define Current_slot            		pr_state_ptr->Current_slot
#define Current_slot_mod        		pr_state_ptr->Current_slot_mod
#define Last_hop_slot           		pr_state_ptr->Last_hop_slot
#define Dest_addr               		pr_state_ptr->Dest_addr
#define Last_poll               		pr_state_ptr->Last_poll
#define Last_poll_update        		pr_state_ptr->Last_poll_update
#define Last_slave_polled       		pr_state_ptr->Last_slave_polled
#define Poll_slave_synch        		pr_state_ptr->Poll_slave_synch
#define Retx                    		pr_state_ptr->Retx
#define Next_acl_slave          		pr_state_ptr->Next_acl_slave
#define Seqn                    		pr_state_ptr->Seqn
#define Seqn_old                		pr_state_ptr->Seqn_old
#define Slave_to_ack            		pr_state_ptr->Slave_to_ack
#define Arq                     		pr_state_ptr->Arq
#define Last_acl_pk_type        		pr_state_ptr->Last_acl_pk_type
#define Slave_response_slot     		pr_state_ptr->Slave_response_slot
#define Next_free_slot          		pr_state_ptr->Next_free_slot
#define Acl_pending             		pr_state_ptr->Acl_pending
#define Use_next_free_slot      		pr_state_ptr->Use_next_free_slot
#define Pk_count                		pr_state_ptr->Pk_count
#define Next_control_slave      		pr_state_ptr->Next_control_slave
#define Logical_channel         		pr_state_ptr->Logical_channel
#define Mac_packets_sent_stat   		pr_state_ptr->Mac_packets_sent_stat
#define Mac_packets_recv_stat   		pr_state_ptr->Mac_packets_recv_stat
#define Mac_pkt_lost_stat       		pr_state_ptr->Mac_pkt_lost_stat
#define Sco_pkt_received_stat   		pr_state_ptr->Sco_pkt_received_stat
#define Sco_pkt_sent_stat       		pr_state_ptr->Sco_pkt_sent_stat
#define Mac_throughput_stat     		pr_state_ptr->Mac_throughput_stat
#define Hop_value_stat          		pr_state_ptr->Hop_value_stat
#define Mac_fec_throughput_stat 		pr_state_ptr->Mac_fec_throughput_stat
#define Offset_gb_stat          		pr_state_ptr->Offset_gb_stat
#define Gb_tput_stat            		pr_state_ptr->Gb_tput_stat
#define Gb_overhead_tput_stat   		pr_state_ptr->Gb_overhead_tput_stat
#define Gb_fec_tput_stat        		pr_state_ptr->Gb_fec_tput_stat
#define Poll_pkts_sent_stat     		pr_state_ptr->Poll_pkts_sent_stat
#define Acl_pk_sent_stat        		pr_state_ptr->Acl_pk_sent_stat
#define Acl_pk_received_stat    		pr_state_ptr->Acl_pk_received_stat
#define Retx_stat               		pr_state_ptr->Retx_stat
#define Null_pk_sent_stat       		pr_state_ptr->Null_pk_sent_stat
#define Tx_skipped_stat         		pr_state_ptr->Tx_skipped_stat
#define Dropped_sco_stat        		pr_state_ptr->Dropped_sco_stat
#define Nulls_received_stat     		pr_state_ptr->Nulls_received_stat
#define Control_packets_sent_stat		pr_state_ptr->Control_packets_sent_stat
#define Control_packets_received_stat		pr_state_ptr->Control_packets_received_stat
#define Mac_sdu_delay_stat      		pr_state_ptr->Mac_sdu_delay_stat
#define Control_packets_from_slave_stat		pr_state_ptr->Control_packets_from_slave_stat
#define Control_packets_to_slave_stat		pr_state_ptr->Control_packets_to_slave_stat
#define Control_packets_sent_gb_stat		pr_state_ptr->Control_packets_sent_gb_stat
#define Control_packets_received_gb_stat		pr_state_ptr->Control_packets_received_gb_stat
#define Gb_aggregate_tput_stat  		pr_state_ptr->Gb_aggregate_tput_stat
#define Residual_sco_payload_errors_stat		pr_state_ptr->Residual_sco_payload_errors_stat
#define Evh_poll                		pr_state_ptr->Evh_poll
#define No_response_evh         		pr_state_ptr->No_response_evh
#define Evh_tx                  		pr_state_ptr->Evh_tx
#define Evh_voice               		pr_state_ptr->Evh_voice
#define Voice_source_pk_size    		pr_state_ptr->Voice_source_pk_size
#define Offset                  		pr_state_ptr->Offset
#define tx_old                  		pr_state_ptr->tx_old
#define Retx_pkptr              		pr_state_ptr->Retx_pkptr

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	bt_master_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((bt_master_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/****************************************************************************************/
/* Function change_frequencies                                    	                    */
/* Purpose:  Called by master, sets all transmitter and receiver channels in the 		*/
/*			piconet to the new frequency												*/
/* In:   hop, the next hop value													    */
/* Out:  none, frequency attributes are changed in piconet                              */
/* Notes: 																				*/
/****************************************************************************************/
void change_frequencies (double hop)
{	
	int i;

	FIN (change_frequencies (hop));
	
	if (BT_HOP_TRACE_ACTIVE)
		{
		printf ("Frequency Hop for Master(%d) at %.6f, slot %d\n", My_piconet_address, op_sim_time(), Current_slot);
		}
	
	/* Change master's frequencies */
	op_ima_obj_attr_set(rx_channel_objid, "min frequency", MIN_FREQ + hop * FREQ_OFFSET);
	op_ima_obj_attr_set(tx_channel_objid, "min frequency", MIN_FREQ + hop * FREQ_OFFSET);
	
	/* Set frequencies on all slaves in piconet */
	for (i = 0; i < 7; i++)
		{
		if (piconet_table[i].slave_obj_id != 0)
			{
			if (BT_HOP_TRACE_ACTIVE)
				{
				printf ("    Frequency Hop for Slave(%d)(%d)\n", My_piconet_address, i);
				}
			op_ima_obj_attr_set(piconet_table[i].rx_channel_attr_id, "min frequency", MIN_FREQ + hop * FREQ_OFFSET);
			op_ima_obj_attr_set(piconet_table[i].tx_channel_attr_id, "min frequency", MIN_FREQ + hop * FREQ_OFFSET);
			}
		else
			{
			break;
			}
		}
	if (BT_HOP_TRACE_ACTIVE)
		{
		printf ("\n");
		}

	FOUT;
}


/****************************************************************************************/
/* Function bt_init_seg_hop_table                                    	       NIST     */
/* Purpose:  Called by master, fills the segment hop table with random offset values	*/										
/* In:   none																		    */
/* Out:  none, random hop offsets stored in table			                            */
/* Notes: 																				*/
/****************************************************************************************/

void    bt_init_seg_hop_table()
    {
        
	int             i,j;
	Boolean		valid;

	FIN (bt_init_seg_hop_table());
	
	/* Init the segment offset table */
	for (i=0; i<SEGMENT_SIZE; i++)
	  segment_hop_table[i] = -1;

	for (i=0; i<SEGMENT_SIZE; i++)
		do
        {
        	valid = OPC_TRUE;
			/* generate a random offset value */
        	segment_hop_table[i] = hop_table[ ( (hop_segment_index +
			   (int)floor(op_dist_uniform(1)*SEGMENT_SIZE)) ) % NUMBER_OF_HOPS ];
			if (BT_TRACE_ACTIVE)					
					
			/* check all assigned hops to be sure we aren't duplicating them */
            for (j=0; j<i; j++) 
				if (segment_hop_table[i] == segment_hop_table[j])
					{
					valid = OPC_FALSE;
					if (BT_TRACE_ACTIVE)					
					break;
					}
		}
        while ( !valid );

    hop_inside_index = 0;           /* Start with the first randomly chosen */
                                    /* freq from the random table */

    FOUT;
}

/****************************************************************************************/
/* Function bt_next_freq_hop	                                    	       NIST     */
/* Purpose:  Called by master, generates the next frequency to be used by this piconet	*/											
/* In:   none																		    */
/* Out:  next frequency hop value from hop table			                            */
/* Notes: 																				*/
/****************************************************************************************/
static int bt_next_freq_hop ()
{
	FIN (bt_next_freq_hop  ());

	/* Test if there is at least one frequency free inside the segment of 32 frequencies*/
	/* If not, go to the next segment */
	if (hop_inside_index >= SEGMENT_SIZE)
		{
		hop_segment_index += DELTA;
		hop_segment_index %= (NUMBER_OF_HOPS);/* 0,16,32,48,64,1,17... in the 79 Hop model */
		bt_init_seg_hop_table();		/* Get a new sequence of SEGMENT_SIZE hops */
		}

	/* A frequency is available now - take it for the current hop frequency */
	
	FRET (segment_hop_table[hop_inside_index++]);
}

/**************************************************************************************************/
/* Function:		bt_mst_mac_error															  */
/* Description:	Error handling procedure													      */
/* ParamIn:		char * : fcnt																      */
/*						The function in the process     										  */
/*						where the error occured													  */
/* ParamIn:		char * : msg																      */
/*						The description of the error											  */
/* ParamIn:		char * : opt																      */
/*						An optional message														  */
/**************************************************************************************************/

void	bt_mst_mac_error (char * fcnt, char * msg, char * opt)
{
	/* Terminates simulation and print an error message. */
	FIN (bt_mst_mac_error (fcnt, msg, opt));


	op_sim_end ("Error in BlueTooth Master MAC process: ", fcnt, msg, opt);


	FOUT;
}

/****************************************************************************************/
/* Function init_piconet                                    	                        */
/* Purpose:  Called by master, assigns addresses to all slaves (0-6) in this piconet 	*/
/*			and stores their transmitter and receiver channel ids into a piconet table  */
/*			using the address as the index. Slave attributes for Tsco and Nbc are set   */
/*			by the master to ensure compatibility. The number of slaves is returned. 	*/
/* In:   my_id, the object id of the master process									    */
/* Out:  number of slaves in the piconet                                                */
/* Notes:  	1) a piconet with more than seven slaves will end the simulation 			*/
/*   		2) this function searches for parent nodes by name - the first two letters	*/
/*				of the node model containing this process should be 'bt' 				*/ 
/****************************************************************************************/
int init_piconet (Objid my_id)
{
	typedef struct
	{
	Objid node_id;
	Objid qps_id;
	}pico_entry;
	
	pico_entry temp_table[7];	
	int		i, k, nd_count, qps_count;
	int 	pc_addr, temp;
	int 	num_slaves;
	Objid	ch_id, qps_id, tr_id, node_id;
	Objid*	mast_id;
	Boolean in_my_piconet;
	char 	my_name[64];
	char 	node_name[64];
	char 	str0[128];
	int* fec_level;			

	FIN (init_piconet ());

	nd_count = op_topo_object_count(OPC_OBJMTYPE_NODE);
	num_slaves = 0;
	op_ima_obj_attr_get(op_id_parent(my_id), "model", &my_name);	

	for (i=0;i<7;i++)
		{
		piconet_table[i].slave_obj_id = 0;
		temp_table[i].qps_id = 0;
		}

	for (i = 0; i < nd_count; i++)
		{
		/* find each bluetooth node with model named "bt.." */
		node_id = op_topo_object(OPC_OBJMTYPE_NODE, i);
		op_ima_obj_attr_get(node_id, "model", &node_name);		
		
		if (((node_name[0] == 'b' || node_name[0] == 'B') && (node_name[1] == 't' || node_name[1] == 'T')) && (node_id != op_topo_parent(my_id)))
			{
			in_my_piconet = OPC_FALSE;

			
			/* find out how many child queues/processes there are for this bt node	*/
			qps_count = op_topo_child_count(node_id, OPC_OBJMTYPE_QPS);
			for (k = 0; k < qps_count; k++)
				{
				/* find a child process with the attribute "Piconet Address" */
				/* and check to see if it is in the same piconet as this node */
				qps_id = op_topo_child(node_id, OPC_OBJMTYPE_QPS, k);
				if (op_ima_obj_attr_exists(qps_id, "Piconet Address") == OPC_TRUE)
					{
					op_ima_obj_attr_get(qps_id, "Piconet Address", &pc_addr);
					if (pc_addr == My_piconet_address)
						{
						/* Check for more than one master node assigned to the same piconet */
						if (strcmp(node_name, my_name)==0)
							{
							sprintf(str0, "More than one master node assigned to piconet %d", My_piconet_address);
							op_sim_end(str0,"Check scenario configuration","","");
							}
						in_my_piconet = OPC_TRUE;
						}
						
					break;
					}
				}
			
			if (in_my_piconet == OPC_TRUE)
				{
				/* store object ids in a temporary table */
				temp_table[num_slaves].qps_id = qps_id;
				temp_table[num_slaves].node_id = node_id;
				
				num_slaves++;
				if(num_slaves > 7)
					{
					sprintf(str0, "More than 7 slaves in piconet %d", My_piconet_address);
					op_sim_end(str0,"","","");
					}
				}
			} /* end if BT node */
		}/* end node search */

	if(BT_ADDR_TRACE_ACTIVE)
		{
		sprintf (str0, "Piconet %d: Number of slaves found = %d", My_piconet_address, num_slaves);
		op_prg_odb_print_major (str0, OPC_NIL, OPC_NIL, OPC_NIL);
		}
	
	/* find the slaves with user-assigned addresses */
	for(i=0; i<num_slaves; i++)
		{
		if(temp_table[i].qps_id != 0)
			{	
			temp = -1;

			op_ima_obj_attr_get(temp_table[i].qps_id, "Slave Address", &temp); 	
			
			if(BT_ADDR_TRACE_ACTIVE)
				{
				printf("Objid %d: In piconet %d address assigned by user is %d (master will assign if -1)\n",temp_table[i].qps_id, My_piconet_address,  temp);
				}

			if (temp != -1 )
				{
				if(temp > num_slaves-1)
					{
					sprintf(str0, "Slave assigned illegal address of slave %d in piconet %d", temp, My_piconet_address);
					op_sim_end(str0,"Slave numbers must fit within limits of consecutive numbering starting at 0","","Number assigned must be less than the number of slaves in the piconet");
					}
				
				
				if (piconet_table[temp].slave_obj_id == 0)
					{
					piconet_table[temp].slave_obj_id = temp_table[i].qps_id;
										
					/* get the object id of the receiver channel */
					tr_id = op_topo_child(temp_table[i].node_id, OPC_OBJTYPE_RARX, 0);
					op_ima_obj_attr_get(tr_id, "channel", &ch_id);
					piconet_table[temp].rx_channel_attr_id = op_topo_child(ch_id, OPC_OBJTYPE_RARXCH, 0);
					/* get the object id of the transmitter channel */
					tr_id = op_topo_child(temp_table[i].node_id, OPC_OBJTYPE_RATX, 0);
					op_ima_obj_attr_get(tr_id, "channel", &ch_id);
					piconet_table[temp].tx_channel_attr_id = op_topo_child(ch_id, OPC_OBJTYPE_RATXCH, 0);
							
					/* set state variables for master id */
					/* get pointer to SV and set it */
					mast_id = op_ima_obj_svar_get (temp_table[i].qps_id, "master_id");
					*mast_id = my_id;
					
					temp_table[i].qps_id = -1;

					}
				else
					{
					sprintf(str0, "more than one slave assigned address %d in piconet %d", temp, My_piconet_address);
					op_sim_end(str0, "user settings must be changed","","");
					}
				}
			}
		}
		
		
	k = 0;
	
	/* then the slaves that are not yet assigned addresses */
	
	for(i=0; i<num_slaves; i++)
		{
		if (piconet_table [i].slave_obj_id == 0)
			{
			/* find an object not already assigned this address */
			while(temp_table[k].qps_id == -1)
				{k++;}
			if(BT_ADDR_TRACE_ACTIVE)
				{
				printf("Objid %d: In piconet %d address being assigned by master is %d \n", temp_table[k].qps_id, My_piconet_address,i);
				}
			
			piconet_table [i].slave_obj_id = temp_table[k].qps_id;
			op_ima_obj_attr_set(temp_table[k].qps_id, "Slave Address", i);
			
			/* get the object id of the receiver channel */
			tr_id = op_topo_child(temp_table[k].node_id, OPC_OBJTYPE_RARX, 0);
			op_ima_obj_attr_get(tr_id, "channel", &ch_id);
			piconet_table[i].rx_channel_attr_id = op_topo_child(ch_id, OPC_OBJTYPE_RARXCH, 0);
			
			/* get the object id of the transmitter channel */
			tr_id = op_topo_child(temp_table[k].node_id, OPC_OBJTYPE_RATX, 0);
			op_ima_obj_attr_get(tr_id, "channel", &ch_id);
			piconet_table[i].tx_channel_attr_id = op_topo_child(ch_id, OPC_OBJTYPE_RATXCH, 0);
				
			
			/* set state variables for master id */
			/* get pointer to SV and set it */
			mast_id = op_ima_obj_svar_get (temp_table[k].qps_id, "master_id");
			*mast_id = my_id;
			
			temp_table[k].qps_id = -1;
			}
		}
	
	/*	Print trace information.				*/
	if (BT_ADDR_TRACE_ACTIVE)
		{
		sprintf (str0, " Addresses assigned to %d slaves of piconet %d", num_slaves, My_piconet_address);
		op_prg_odb_print_major (str0, OPC_NIL, OPC_NIL, OPC_NIL);
		}
				
	
	for(i=0; i<num_slaves; i++)
		{
		if (piconet_table[i].slave_obj_id == 0)
			op_sim_end("Piconet slaves are not configured properly", "Check for slave addresses greater than number of slaves","","");
		fec_level = op_ima_obj_svar_get (piconet_table[i].slave_obj_id, "Channel_condition");
		*fec_level = Slave_channel_condition[i];
		Slave_channel_condition_ptrs[i] = fec_level;
		}

	FRET(num_slaves);
	}

/****************************************************************************************/
/* Function get_tx_type                                    	                            */
/* Purpose:  Called upon entrance to "To BT Radio".                                  	*/
/*            - determines what type of transmission is needed for this slot            */
/*            - determines the destination slave for this slot                          */
/* In:   none                      									                    */
/* Return:  tx_type, ie, NULL, POLL, SCO, ACL, ACL_RETX, CONTROL                        */
/* Sets the SV  Dest_addr                                                               */
/****************************************************************************************/

int get_tx_type()
{
	int tx_type = TX_ERROR, i, j, n, send_poll, send_sco, sco_con_index; 
	int con_index = -1, slave_addr, done;
	double bitcount;
	
	FIN(get_tx_type());
	
	send_poll = OPC_FALSE;
	send_sco  = OPC_FALSE;
	done      = OPC_FALSE;
	
	/* USER_DATA is the default logical channel; if CONTROL traffic is sent, it will be switched */
	/* The variable will be used in the packet creation (packet_create())                        */
	//Logical_channel = USER_DATA;
	
	/* There are two broad cases: 1) the channel is maxed by SCO     								*/
	/*                            2) the channel is not maxed by SCO 								*/
	/* For 1), we must pre-empt an SCO packet to deliver (ordered by priority) any retransmissions, */
	/*  control messages, or POLL packets.  This requires that we flush the SCO buffer of the 		*/
	/*  pre-empted slave by the amount of data that would have been sent, depending on Tsco.	    */
	/*  This prevents inreasing app layer delays over SCO links.                              		*/
	/* For 2), the priority is:																  		*/
	/*  SCO																					  		*/
	/*  RETX (may contain LMP data)															  		*/
	/*  CONTROL																				  		*/
	/*  POLL																				  		*/
	/*  ACL																					  		*/
	/*  NULL																				  		*/
	/************************************************************************************************/
	
	/* case 1: channel is maxed by SCO */
	if ((Num_SCO_cons == 3) || (Num_SCO_cons == 2 && Tsco == 4) || (Num_SCO_cons == 1 && Tsco == 2))
		{
		/* determine if a slave needs a retransmission.  These must have priority since they may contain */
		/* LMP messages. 																				 */
		for (i=Next_acl_slave; i <= Next_acl_slave + Number_of_slaves; i++)
			{
			slave_addr = i % Number_of_slaves;
			if (Retx[slave_addr])
				{
				Dest_addr = slave_addr;
				Next_acl_slave = ++slave_addr % Number_of_slaves;
				tx_type = ACL_RETX;
				done = OPC_TRUE;
				}
			}
		/* no slave needed a retx, so look for control data */
		if (!done)
			{
			/* check for control traffic.  If any, find destination */
			/* Use round-robin scheduling for control traffic       */
			for (j=Next_control_slave; j<=Next_control_slave + Number_of_slaves; j++)
				{
				slave_addr = j % Number_of_slaves;
				/* there is control data for slave slave_addr */
				if (!op_subq_empty(slave_addr))
					{
					Dest_addr = slave_addr;
					Next_control_slave = ++slave_addr%Number_of_slaves;
					tx_type = ACL;
					Logical_channel = CONTROL;
					done = OPC_TRUE;	
					}
				}

			}
		/* didn't find retx or control, check for a slave in need of a POLL */
		/* Determine if a slave needs a poll according to poll interval timer. */
		if (!done)
			{
			for (j=Last_slave_polled +1; j <= Last_slave_polled + Number_of_slaves; j++)
				{
				i = j % Number_of_slaves;
				if (Last_poll[i] >= Poll_interval)
					{
					Dest_addr = i;
					Last_poll[i] = 0;
					Last_slave_polled = i;
					Logical_channel = USER_DATA;
					/* Send ACL data if there is any to send to this slave */
					if (op_sar_buf_size(Acl_seg_buf[Dest_addr]) > 0)
						{
							tx_type = ACL;
						}
					else
						tx_type = POLL;
					done = OPC_TRUE;
					}
				}
			}
		/* We found something to send - we must flush the pre-empted SCO data */
		if (done)
			{
			/* what SCO connection are we pre-empting? */
			con_index = (Current_slot_mod+2)/2;
			/* what slave does this correspond to? */
			for (n=0; n<Number_of_slaves; n++)
				if (SCO_con[n] == con_index)
				   {
				   slave_addr = n;
				   /* slave n's index into the SCO sar buffer */
				   sco_con_index = SCO_con[n] - 1;
				   }
			/* flush the pre_empted SCO data from the SAR buffer */
			if (op_sar_buf_size (Sco_seg_buf [sco_con_index]) >= Voice_source_pk_size && Voice_source_pk_size > 0)
				{
				/* flush no more than a single packet of data for this Tsco, but not more than is in the buffer */
				bitcount = Voice_source_pk_size > (Tsco * 5 * 8)?(Tsco * 5 * 8):Voice_source_pk_size;
				op_sar_srcbuf_bits_flush (Sco_seg_buf [sco_con_index], 0, bitcount);
				}
			op_stat_write (Dropped_sco_stat, 1);
			FRET (tx_type);
			}
		else /* we didn't find anything that needs to pre-empt this SCO transmission */
			{
			/* find the slave's address */
			for (i=0; i<Number_of_slaves; i++)
				if (SCO_con[i] == (Current_slot_mod/2 + 1))
					{
					Dest_addr = i;
					FRET(SCO);
					}
			}
		
		
		}
	/****************************************************/
	else /* Case 2: the channel isn't maxed by SCO      */
	/****************************************************/	
		{
		/* first priority is SCO */
		for (i=0; i<Num_SCO_cons; i++)
			{
			/* if this timeslot is a SCO reserved slot */
			if (Current_slot_mod == (2*i))
				{
				con_index = i +1;
				tx_type = SCO;
				send_sco = OPC_TRUE;
				}
			}
		if (con_index > -1) /* find the slave's address */
			for (i=0; i<Number_of_slaves; i++)
				if (SCO_con[i] == con_index)
					{
					Dest_addr = i;
					//Last_slave_polled = i; ?? sco doesn't count as a poll 
					FRET(SCO);
					}
		/* second priority is RETX; it may contain LMP/CONTROL data */
		for (i=Next_acl_slave; i <= Next_acl_slave + Number_of_slaves; i++)
			{
			slave_addr = i % Number_of_slaves;
			if (Retx[slave_addr])
				{
				Dest_addr = slave_addr;
				Next_acl_slave = ++slave_addr % Number_of_slaves;
				//printf ("Retx @ %f for slot %d\n", op_sim_time(), Current_slot);
				FRET(ACL_RETX);
				}
			}
		/* third priority is CONTROL/LMP data */
		/* check for control traffic.  If any, find destination */
		/* Use round-robin scheduling for control traffic       */
		for (j=Next_control_slave; j<Next_control_slave + Number_of_slaves; j++)
			{
			slave_addr = j % Number_of_slaves;
			/* there is control data for slave slave_addr */
			if (!op_subq_empty(slave_addr))
				{
				Dest_addr = slave_addr;
				Next_control_slave = ++slave_addr%Number_of_slaves;
				Logical_channel = CONTROL;
				FRET(ACL);
				}
			}
		/* fourth priority is POLL traffic */
		for (j=Last_slave_polled +1; j <= Last_slave_polled + Number_of_slaves; j++)
			{ 
			i = j % Number_of_slaves;
			//printf("checking for poll: last_polled+1(j)=%d last+num=%d j%num = %d\n",(Last_slave_polled+1),(Last_slave_polled + Number_of_slaves),i);
			if (Last_poll[i] >= Poll_interval)
				{
				Dest_addr = i;
				Last_poll[i] = 0;
				Last_slave_polled = i;
				Logical_channel = USER_DATA;
				/* Send ACL data if there is any to send to this slave */
				if (op_sar_buf_size(Acl_seg_buf[Dest_addr]) > 0)
					{ /*start change here*/
					/* check to make sure there are enough upcoming free slots (not reserved by SCO) */
					/*  to complete this transmission */
					if (Num_SCO_cons > 0 && Tx_slots > 1)
						{
						/* only other viable case is where tx slots is 3 and tsco is 6 */
						/* can only use 3 slots from the 3rd slot of the Tsco period */
						/* If we would have to wait, send smaller poll packet */
						if (Tx_slots == 5 ||( Num_SCO_cons == 1 && Tsco == 6 &&\
							Tx_slots == 3 && Current_slot_mod != 2))
							{
							//printf("sending POLL since not enough slots for ACL\n");
							tx_type = POLL;
							}
						}
					else						
						tx_type = ACL;/*end change here */
					}
				else
					tx_type = POLL;	
				FRET (tx_type);
				}
			}
		/* fifth/sixth priority is ACL/NULL */
		/* Check each slave according to round-robin scheduling */
		for (i=Next_acl_slave; i <= Next_acl_slave + Number_of_slaves; i++)
			{
			slave_addr = i % Number_of_slaves;
			bitcount = op_sar_buf_size (Acl_seg_buf [slave_addr]);
			if (bitcount > 0)
				{
				Dest_addr = slave_addr;
				Next_acl_slave = ++slave_addr % Number_of_slaves;
				Logical_channel = USER_DATA;
				FRET(ACL);
				}
			else if (Slave_to_ack [slave_addr])
				{
				Dest_addr = slave_addr;
				Next_acl_slave = ++slave_addr % Number_of_slaves;
				Logical_channel = USER_DATA;
				FRET(NULL_TX);
				}
			}

		}
	printf("tx_type = %d\n", tx_type);

	FRET(tx_type);
}

/****************************************************************************************/
/* Function next_tx_event                                    	                        */
/* Purpose:  Schedules the next tx event based on the state of the holding buffers.   	*/
/*           The next transmission's details are not determined here, that is done by   */
/*            get_tx_type().                                                            */            
/* In:   Character string, message to output for scheduler trace,                       */
/*        typically name of caller									                    */
/* Return:  Slot for which interrupt is scheduled.  Returns 0 if no interrupt           */
/*           is scheduled.  Can be interpreted as T/F.                                  */
/****************************************************************************************/

int next_tx_event(char* caller)
{
	int timeslots=0, i, num_events, done=OPC_FALSE, slave_addr, temp_slot, display_slot;
	int pending_tx_events = 0, first_ev_found = OPC_FALSE;
	Evhandle next_event;
	double tx_time=0., bufsize, temp_time;
	int int_type = TX, free_slot_mod;
	
	FIN(next_tx_event());
	Use_next_free_slot = OPC_TRUE;
	/* We want only one tx event in the event list at any given time.  It is possible */
	/*  that a previously scheduled tx event is for a later time than is now needed,  */
	/*  for example, I just received an ACL packet that requires an ack, but the next */
	/*  tx event is for an SCO tx 4 slots in the future.                              */
	
	/* display slot is returned by the function */
	display_slot = 0;

	/* determine the next non-sco free slot */
	free_slot_mod = Next_free_slot % Tsco;
	if(Num_SCO_cons > 0 && free_slot_mod <= (2 * Num_SCO_cons - 2))
		{
		/* The channel is maxed by SCO */
		if ((Tsco == 6 && Num_SCO_cons == 3) || (Tsco == 4 && Num_SCO_cons == 2) || Tsco == 2)
			{
			FRET(display_slot);
			}
		else if (Tsco == 4 && Num_SCO_cons == 1)
			{
			Next_free_slot += 2;
			}
		else if (Tsco == 6 && Num_SCO_cons == 1)
			{
			Next_free_slot += 2;
			}
		else if (Tsco == 6 && Num_SCO_cons == 2)
			{
			if (free_slot_mod == 2)
				Next_free_slot += 2;
			else 
				Next_free_slot += 4;
			}
		else
			printf ("Master %d: next free slot not calculated in next tx event\n", My_piconet_address);
		
		}
	
	
	/* check for control/lmp data */
	if (!op_q_empty()) /* there are contents in this processes queue, which only contains LMP data */
		{
		done = OPC_TRUE;
		}
	
	/* else if slave needs a poll  */
	if (!done)
		{
		for (i=0; i < Number_of_slaves; i++)
			{
			if (Last_poll[i] >= (Poll_interval - 2))
				{
				timeslots = 2; // poll will be sent in next master to slave slot
				done = OPC_TRUE;
				}
			}
		}
	
	
	/* else if ACL data (retx or new) for any slave except retx for slave Dest_addr, since we just sent it a packet */
	if(!done)
		{
		for (i=0; i < Number_of_slaves; i++)
			{
			/* Don't test retx[Dest_addr] since it is likely to be true since we just sent it a TX */
			slave_addr = i == Dest_addr?((Dest_addr + 1) % Number_of_slaves):i;
			bufsize = op_sar_buf_size (Acl_seg_buf [i]);
			/* test for retx first */
			if (Number_of_slaves > 1 && Retx[slave_addr])
				{
				timeslots = 2;
				done = OPC_TRUE;
				break;
				}

			else if (!done && ((bufsize > 0) || Slave_to_ack [slave_addr]))
				{
				timeslots = 2;
				done = OPC_TRUE;
				break;
				}
			if(done)
				break;
			}
		}
	
		
	/* calculate sim time for next tx event */
	if (Use_next_free_slot && done)
		{
		tx_time = Next_free_slot * SLOT_TIME + .000001 + Offset;
		display_slot = Next_free_slot;
		}

		if (done)
			{
			if (op_ev_valid (Evh_tx) && !op_ev_equal (Evh_tx, op_ev_current()) &&\
				op_ev_code(Evh_tx) != SCHEDULED_VOICE)				
				/* cancel any non-SCO events that aren't scheduled for the next_free_slot */
				{
				
				temp_time = op_ev_time (Evh_tx);
				temp_slot = (int)(floor((temp_time + .000001 - Offset) / SLOT_TIME));
				if (temp_slot != Next_free_slot)
					{
					op_ev_cancel (Evh_tx);
					Evh_tx = op_intrpt_schedule_self (tx_time, int_type);
					if (BT_SCHEDULER_TRACE_ACTIVE)
						{
						printf ("Master %d: Tx event (%d) for %d  CANCELLED at %d, caller is %s\n",\
							My_piconet_address, op_ev_code(Evh_tx), temp_slot, Current_slot, caller);
						printf ("Tx slot scheduled for slot %d (%.6f), called by %s at slot %d\n",\
							display_slot, tx_time, caller, Current_slot);
						}
					}
				}
			else if (!op_ev_valid(Evh_tx))
				{
				Evh_tx = op_intrpt_schedule_self (tx_time, int_type);
				if (BT_SCHEDULER_TRACE_ACTIVE)
					{
					printf ("Master %d: Tx slot scheduled for slot %d (%.6f), called by %s at slot %d\n",\
						My_piconet_address, display_slot, tx_time, caller, Current_slot);
					}
				}
			temp_slot = (int)(floor((tx_time + .000001 - Offset) / SLOT_TIME));
			
			/* Reschedule a POLL event if scheduled for the same time */			
			num_events = op_ev_count_local ();
			next_event = op_ev_current ();
			for (i = 0; i<num_events; i++)
				{
				if (op_ev_code(next_event) == POLL &&\
					(int)(floor((op_ev_time (next_event) + .000001 - Offset) / SLOT_TIME)) == display_slot)
					{
					op_ev_cancel (next_event);
					op_intrpt_schedule_self ((display_slot + Poll_interval) * SLOT_TIME + Offset, POLL);
					if (BT_SCHEDULER_TRACE_ACTIVE)
						printf ("Master %d: POLL Event at %d rescheduled for %d\n", My_piconet_address, display_slot, display_slot + Poll_interval);
					break;
					}
				next_event = op_ev_next_local (next_event);
				}
			}
		else
			{
			if (BT_SCHEDULER_TRACE_ACTIVE)				
				printf ("Master %d:NO Tx slot scheduled (%.6f), called by %s at slot %d\n",\
					My_piconet_address, op_sim_time(), caller, Current_slot);
			}
		
	FRET(display_slot);
			
	
}

/****************************************************************************************/
/* Function packet_select()                                   	                        */
/* Purpose:  Determines the next packet type given the next transmission type       	*/
/*                                                                                      */
/* In:   tx_type:  POLL, SCO, ACL, CONTROL, NULL.									    */
/* Return:  packet type for the transmission (DM1, HV1...)                              */
/****************************************************************************************/

int packet_select(int tx_type)
{
	int pk_type = ERROR;  /* default value */
	double bitcount;
	
	FIN(packet_select());

	switch (tx_type)
		{
		case SCO:
		if (Tsco == 6)
			pk_type = HV3;
		else if (Tsco == 4)
			pk_type = HV2;
		else
			pk_type = HV1;
		break;
		case ACL:
			{
			/* if CONTROL/LM data needs to be sent, it is sent on an ACL link in a DM1 packet */
			if (Logical_channel == CONTROL)
				{
				pk_type = DM1;
				}
			/* packet type depends on how many slots the master can use for transmissions */
			/* Packet type will be D<H|M>X depending on channel conditions */
			else if (Tx_slots == 1)
				pk_type = Channel_condition == CLEAR?DH1:DM1;
			else if (Tx_slots == 3)
				pk_type = Channel_condition == CLEAR?DH3:DM3;
			else if (Tx_slots == 5)
				pk_type = Channel_condition == CLEAR?DH5:DM5;
			else if (Tx_slots == CUSTOM)
				{
				/* sample custom algorithm -- choose the smallest ACL packet type neccessary */
				/*  based on buffer size for Dest_addr                                       */
				bitcount = op_sar_buf_size (Acl_seg_buf [Dest_addr]);
				if (bitcount > (Channel_condition == CLEAR?DH3_PAYLOAD:DM3_PAYLOAD))
					pk_type = Channel_condition == CLEAR?DH5:DM5;
				else if (bitcount > (Channel_condition == CLEAR?DH1_PAYLOAD:DM1_PAYLOAD))
					pk_type = Channel_condition == CLEAR?DH3:DM3;
				else
					pk_type = Channel_condition == CLEAR?DH1:DM1;

				}
			}
				
		break;
		case ACL_RETX:
		pk_type = Last_acl_pk_type [Dest_addr];
		break;
		case POLL:
		pk_type = POLL_PKT;
		break;
		case NULL_TX:
		pk_type = NULL_PKT;
		break;
		}
	FRET(pk_type);
}

/****************************************************************************************/
/* Function packet_create()                                   	                        */
/* Purpose:  creates the packet to be sent, inserts payload, fec and sets ARQ fields.  	*/
/*                                                                                      */
/* In:   pk_type:  HV1, DM1...   				                                        */
/* Return:  Packet pointer                                                              */
/****************************************************************************************/

Packet* packet_create(int pk_type)
{

	Packet* bt_pkt, *payload_pkt, *fec_pkt;
	char* packet_type = "error";
	double pk_size, fec_size;
	int tx_type = -1, bitcount, fec = OPC_FALSE, header_plus_crc, slave_response_slot = Current_slot + 1;
	int sample_type;
	FIN (packet_create(pk_type));
	
	switch (pk_type)
		{
		case HV1:
		packet_type = "HV1";
		pk_size = HV1_PAYLOAD;
		fec_size = HV1_FEC;
		fec = OPC_TRUE;
		break;
		
		case HV2:
		packet_type = "HV2";
		pk_size = HV2_PAYLOAD;
		fec_size = HV2_FEC;
		fec = OPC_TRUE;
		break;
		
		case HV3:
		packet_type = "HV3";
		pk_size = HV3_PAYLOAD;
		fec_size = HV3_FEC;
		break;
		
		case DM1:
		packet_type = "DM1";
		pk_size = DM1_PAYLOAD;
		/* DM1's are used for Link Manager messages; flag if this is a LM message */
		if (Logical_channel == CONTROL)
			tx_type = CONTROL;
		else
			tx_type = DATA;
		fec = OPC_TRUE;
		slave_response_slot = Current_slot + 1;
		break;
		
		case DM3:
		packet_type = "DM3";
		pk_size = DM3_PAYLOAD;
		tx_type = DATA;
		fec = OPC_TRUE;
		slave_response_slot = Current_slot + 3;
		break;
		
		case DM5:
		packet_type = "DM5";
		pk_size = DM5_PAYLOAD;
		tx_type = DATA;
		fec = OPC_TRUE;
		slave_response_slot = Current_slot + 5;
		break;
		
		case DH1:
		packet_type = "DH1";
		pk_size = DH1_PAYLOAD;
		tx_type = DATA;
		slave_response_slot = Current_slot + 1;
		break;
		
		case DH3:
		packet_type = "DH3";
		pk_size = DH3_PAYLOAD;
		tx_type = DATA;
		slave_response_slot = Current_slot + 3;
		break;
		
		case DH5:
		packet_type = "DH5";
		pk_size = DH5_PAYLOAD;
		tx_type = DATA;
		slave_response_slot = Current_slot + 5;
		break;
		
		case POLL_PKT:
		packet_type = "POLL";
		fec_size = 0;
		break;
		
		case NULL_PKT:
		packet_type = "NULL";
		fec_size = 0;
		break;
		}
	
	if ((strcmp(packet_type, "error"))) 
		bt_pkt = op_pk_create_fmt(packet_type);
	else
		bt_mst_mac_error ("packet_create()","bad packet_type parameter", "");
	
	
	
	op_pk_nfd_set (bt_pkt, "AM_ADDR", Dest_addr);
	op_pk_nfd_set (bt_pkt, "Way", MASTER_TO_SLAVE);
	op_pk_nfd_set (bt_pkt, "PICO_ADDR", My_piconet_address);
	op_pk_nfd_set (bt_pkt, "ARQ", Arq [Dest_addr]);
	op_pk_nfd_set (bt_pkt, "TYPE", pk_type);

	
	/* insert the payload and fec*/
	
	/* for voice packets, */
	if (pk_type == HV1 || pk_type == HV2 || pk_type == HV3)
		{
	
		if (op_sar_buf_size(Sco_seg_buf[SCO_con[Dest_addr]-1]) > 0)
			{
			payload_pkt = op_sar_srcbuf_seg_remove (Sco_seg_buf[SCO_con[Dest_addr]-1], (double)pk_size);			
					
			if(BT_TRACE_ACTIVE)
				{
				printf ("  packet type  : %s\n", packet_type);
				printf ("  payload size : %d\n", (int)op_pk_total_size_get (payload_pkt));
				if (strcmp(packet_type,"HV3"))
					printf ("  fec size     : %d\n\n", fec_size);
				else
					printf ("\n");

				}
		
			op_pk_nfd_set (bt_pkt, "Frame Body", payload_pkt);
		
		
		
			
			}
		else
			{
			op_pk_nfd_set (bt_pkt, "empty_voice_flag", OPC_TRUE);
			if(BT_TRACE_ACTIVE)
				printf ("  empty voice packet sent\n\n");
			}
		}
	else if (pk_type == POLL_PKT)
		{
		//do nothing - we'll set the arq fields below
		}
	else if (tx_type == DATA || tx_type == CONTROL)
		{
		/* we're transmitting a new payload */
		if (Retx [Dest_addr] == OPC_FALSE)
			{
			if (tx_type == DATA)
				{
				/* get a payload of at most what the ACL packet can contain but not more than is in the buffer */
				bitcount = op_sar_buf_size (Acl_seg_buf [Dest_addr]) >= pk_size?pk_size:op_sar_buf_size (Acl_seg_buf [Dest_addr]);		
				payload_pkt = op_sar_srcbuf_seg_remove (Acl_seg_buf [Dest_addr], bitcount);
				}
			else if (tx_type == CONTROL)
				{
				if (!op_subq_empty (Dest_addr))
					{
					payload_pkt = op_subq_pk_remove (Dest_addr, OPC_QPOS_HEAD);
					}
				else
					printf ("no control data in subqueue %d\n", Dest_addr);
				}
			/* store copy of payload in retransmission packet pointer */
		    if (Retx_pkptr [Dest_addr] != OPC_NIL)
				op_pk_destroy (Retx_pkptr [Dest_addr]);
			Retx_pkptr [Dest_addr] = op_pk_copy (payload_pkt); 
			/* since this is a new ACL packet, toggle the Seqn field */
			if (BT_ARQ_TRACE_ACTIVE)
				printf ("\n\nMaster %d sending new ACL pkt.  Seqn was %d", My_piconet_address,Seqn[Dest_addr]);
			Seqn[Dest_addr] = Seqn[Dest_addr]?0:1;
			if (BT_ARQ_TRACE_ACTIVE)
				printf (" and was toggled to %d before setting field\n",Seqn[Dest_addr] );
			}
		/* else we're retransmitting a payload */
		else
			{
			 if (Retx_pkptr [Dest_addr] != OPC_NIL)
				payload_pkt = op_pk_copy (Retx_pkptr [Dest_addr]);
			/* leave copy in retx packet pointer */
			}
		
		if (Logical_channel == CONTROL)
			{
			 op_stat_write (Control_packets_sent_gb_stat, 1);
			 op_stat_write (Control_packets_sent_stat, 1);
			 op_stat_write_t (Control_packets_to_slave_stat, Dest_addr, 1);
			}
		
		/* set the Seqn packet field */
	    op_pk_nfd_set (bt_pkt, "SEQN", Seqn[Dest_addr]);

		
		
		/* if its a medium data rate packet, create the fec packet*/
	    if (fec)
			{
			/* fec packet size must be a multiple of 10 for FEC; pad if needed */
			/* Add 16 bits of CRC and the payload header (8 bits for DM1,  */
			/* 16 bits for DM3 and DM5) for FEC size calculation           */
			header_plus_crc = pk_type == DM1?24:32;
			pk_size = op_pk_total_size_get (payload_pkt) + header_plus_crc;
			pk_size = (((int)pk_size % 10) == 0)?pk_size:((pk_size/10)*10 + 10);
			fec_size = pk_size/2;
			fec_pkt = op_pk_create (fec_size);
			op_pk_nfd_set (bt_pkt, "FEC", fec_pkt);

			
			}
		op_pk_nfd_set (bt_pkt, "Frame Body", payload_pkt);
		op_pk_nfd_set (bt_pkt, "L_CH", Logical_channel);



		}
	op_pk_nfd_set (bt_pkt, "Access Code", slave_response_slot);
	
	FRET(bt_pkt);
	}
	
/****************************************************************************************/
/* Function get_pk_type()                                    	                        */
/* Purpose:  Returns the defined constant value of the packet type given it's           */
/*              string interpretation; also returns # of header bits.   	            */                              
/*                                                                                      */
/* In:   bt_pk_type.									                                */
/* Return:  Integer defined constant value of bt_pk_type as type[TYPE].                 */
/*             Returns # of overhead bits as type[OVERHEAD].                            */
/*             Returns # of slots used as type[SLOTS].                                  */
/*             Returns connection type used as type[CON].                               */
/*             Returns -1 if no packet type was found.                                  */
/****************************************************************************************/

void get_pk_type(char* bt_pk_type, int* type)
{
 		
	FIN (get_pk_type(char* bt_pk_type, int* type));
	
	type[TYPE] = -1;
	type[OVERHEAD] = -1;
		
	if (!(strcmp(bt_pk_type, "HV1")))
		{
		type[TYPE] = HV1;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON] = SCO;
		}
	else if (!(strcmp(bt_pk_type, "HV2")))
		{
		type[TYPE] = HV2;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON] = SCO;

		}
	else if (!(strcmp(bt_pk_type, "HV3")))
		{
		type[TYPE] = HV3;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON] = SCO;
		}
	else if (!(strcmp(bt_pk_type, "POLL")))
		{
		type[TYPE] = POLL_PKT;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON] = POLL;
		}
	else if (!(strcmp(bt_pk_type, "NULL")))
		{
		type[TYPE] = NULL_PKT;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON] = NULL_TX;

		}
	else if (!(strcmp(bt_pk_type, "DM1")))
		{
		type[TYPE] = DM1;
		type[OVERHEAD] = ACCESS_CODE + HEADER + SS_PAYLOAD_HEADER;
		type[SLOTS] = 1;
		type[CON] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DM3")))
		{
		type[TYPE] = DM3;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 3;
		type[CON] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DM5")))
		{
		type[TYPE] = DM5;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 5;
		type[CON] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DH1")))
		{
		type[TYPE] = DH1;
		type[OVERHEAD] = ACCESS_CODE + HEADER + SS_PAYLOAD_HEADER;
		type[SLOTS] = 1;
		type[CON] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DH3")))
		{
		type[TYPE] = DH3;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 3;
		type[CON] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DH5")))
		{
		type[TYPE] = DH5;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 5;
		type[CON] = ACL;
		}
	
	
	FOUT;
			
	
}

/****************************************************************************************/
/* Function update_last_poll                                                            */
/* Purpose:  accounting for poll packet delivery.                                       */
/* In:   none   																		*/
/* Out:  none                                                                           */
/*																				        */
/****************************************************************************************/
void update_last_poll()
{
	int slave_count;
	
	FIN (update_last_poll ());
	
	for (slave_count = 0; slave_count < Number_of_slaves; slave_count++)
	{
		Last_poll[slave_count] += Current_slot - Last_poll_update;
	}
	Last_poll_update = Current_slot;
	FOUT;
}

/****************************************************************************************/
/* Function hop()                                                                       */
/* Purpose:  call neccessary functions to complete a frequency hop.                     */
/* In:   none   																		*/
/* Out:  none                                                                           */
/* Result: all Bluetooth tranceivers' frequencies are changed by the next hop frequency.*/
/****************************************************************************************/
void hop(int hop_slot)
	{
	int i;
	double next_hop;
	
	FIN(hop());
	
	/* call next hop for each timeslot that has passed since the last hop */
	for (i=0; i<(hop_slot - Last_hop_slot); i++)
		next_hop = (double) bt_next_freq_hop ();

	op_stat_write (Hop_value_stat, next_hop);

	change_frequencies(next_hop);

	Last_hop_slot = Current_slot;
	
	FOUT;
	}


/****************************************************************************************/
/* Function send_bt_pk()                                                                */
/* Purpose:  call neccessary functions to complete a packet send, manage state vars,    */
/*            write stats.                                                              */
/* In:   int tx_type (SCO, ACL, NULL, POLL, CONTROL)   									*/
/* Out:  none                                                                           */
/****************************************************************************************/
void send_bt_pk(int tx_type, char* caller)
	{
	int pk_type, pk_stats[4], timeslots;
	double hop_time, no_response_time, bitcount;
	char BT_packet_type[6];
	Packet* pk_to_send;
	
	FIN (send_bt_pk(tx_type));
	
	hop(Current_slot);

	pk_type = packet_select(tx_type);

	pk_to_send  =  packet_create(pk_type);

	/* Schedule no_response event for ARQ transmissions */

	op_pk_format (pk_to_send, BT_packet_type);

	get_pk_type(BT_packet_type, pk_stats);
	
	timeslots = pk_stats[SLOTS];

	
	if (tx_type == ACL || tx_type == ACL_RETX)
		{
		Last_acl_pk_type [Dest_addr] = pk_stats [TYPE];
		Acl_pending = OPC_TRUE;
		Last_poll[Dest_addr] = 0;
		}
	Slave_response_slot = Current_slot + timeslots;



	/* hop 10 usec before the slaves will respond */
	hop_time = op_sim_time() + timeslots*SLOT_TIME -.000010; 
	op_intrpt_schedule_self (hop_time, FREQ_HOP);

	/* schedule the next tx event for non-acl traffic */
	if (tx_type == SCO)
		{	   
		Slave_response_slot = Current_slot + 1;
		Next_free_slot = Current_slot + 2;
		op_stat_write (Sco_pkt_sent_stat, 1);
		}
	else /* schedule a no response event for ACL traffic */
		{
	//	if (BT_ACL_TRACE_ACTIVE)
			printf ("Master %d setting no response event for end of slot %d\n", My_piconet_address, Current_slot + timeslots);
		no_response_time = op_sim_time() + (timeslots + 1)*SLOT_TIME -.000030;
		No_response_evh = op_intrpt_schedule_self (no_response_time, 20 + Dest_addr);
		}


	op_pk_send (pk_to_send, BT_OUTSTREAM);

	op_stat_write (Mac_packets_sent_stat, 1);
	if (tx_type == ACL || tx_type == ACL_RETX)
		{
		op_stat_write (Acl_pk_sent_stat, 1);
		if (tx_type == ACL_RETX)
			op_stat_write (Retx_stat, 1);
		/* Set retx flag to true since we are sending an ACL transmission */
		Retx [Dest_addr] = OPC_TRUE;
		}
	else if (tx_type == NULL_TX)
		op_stat_write (Null_pk_sent_stat, 1);

	if (tx_type != POLL && tx_type != SCO)
		Slave_to_ack [Dest_addr] = OPC_FALSE;

	if (pk_stats[TYPE] == POLL_PKT)
		op_stat_write (Poll_pkts_sent_stat, 1);

	
	/* Setting Last_poll to 0 for a slave means it won't be polled for the next Poll_interval slots */
	/* Don't send polls to slaves if SCO has maxed the channel, since they won't be able to respond */
	/*  with an ACL packet anyway.  If the slaves need to send CONTROL over an ACL link, their algorithm */
	/*  allows them to pre-empt a scheduled SCO slot */
	if ((Num_SCO_cons == 1 && Tsco == 2) || (Tsco == 4 && Num_SCO_cons == 2) || (Tsco == 6 && Num_SCO_cons == 3)\
		|| tx_type != SCO)
		{	
		Last_poll[Dest_addr] = 0;
		}
	
	/* LTRACE for SCO traffic */
	if ((BT_SCO_TRACE_ACTIVE && tx_type == SCO))
		{
		printf ("Master %d sent %s to slave %d at time %.8f for connection %d, slot modulo is %d, slot %d\n", My_piconet_address,BT_packet_type,\
			Dest_addr, op_sim_time(), SCO_con[Dest_addr], Current_slot_mod, Current_slot);
		}
	if ((tx_type != SCO) && BT_ACL_TRACE_ACTIVE)
		{
		if (tx_type != NULL_TX && tx_type != POLL)
			printf ("Master %d sent %s to slave %d at time %.8f , currrent slot %d, %s, caller: %s\n", My_piconet_address, BT_packet_type, Dest_addr,\
				op_sim_time(), Current_slot, tx_type == ACL?"new":"retx", caller);
		else
			printf ("Master %d sent %s to slave %d at time %.8f , currrent slot %d, caller: %s\n", My_piconet_address, BT_packet_type, Dest_addr,\
				op_sim_time(), Current_slot, caller);

		}
	if ((op_sim_time() - tx_old)<.000625)
		{
		printf("Master %d: tx diff is %8f at %8f\n\n", My_piconet_address, op_sim_time() - tx_old, op_sim_time());
		}
	tx_old = op_sim_time();


	FOUT;
	}

		



/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void bt_master (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_bt_master_init (int * init_block_ptr);
	void _op_bt_master_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_bt_master_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_bt_master_alloc (VosT_Obtype, int);
	void _op_bt_master_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
bt_master (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (bt_master ());

		{
		/* Temporary Variables */
		int i, j = 0;
		
		Objid	my_objid;
		Objid	tr_id;     		// transceiver id
		Objid	ch_id;			// channel attribute id
		int 	acl_level;      // ACL FEC level to start with
		double  offset, tx_time, hop_time, no_response_time;
		Packet* stoch_pkt, *pk_to_send, *bt_pkt, *up_pkt, *payload_pkt, *fec_pkt;
		Ici*    stoch_ici;
		int     qos, dest_addr, con_index, display_slot;
		int     timeslots, tx_type, pk_type;
		double  next_hop, tput_size, bitcount;
		int way, pico_addr, accept, source_addr, slave_addr;
		//char  BT_packet_type[6];
		char BT_packet_type[6];
		int empty_voice, packet_accept;
		char* pk_name = "empty";
		int pk_stats[4], scheduled_it;
		int ev_code,  ev_strm, int_code, self_i_count;
		Evhandle ev_type;
		char* ev_name;
		int seqn, logical_channel, remove_fec, arq, num_events;
		double fec_size, ev_time, temp_time;
		Objid my_node_id;
		Prohandle own_prohandle;
		char proc_model_name[30];
		OmsT_Pr_Handle own_process_record_handle;
		Evhandle next_event, poll_ev;
		int temp_slot;
		int payload_errors;
		int packet_type;
		
		/* End of Temporary Variables */


		FSM_ENTER ("bt_master")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (Init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "Init", "bt_master [Init enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [Init enter execs]", state0_enter_exec)
				{
				/* Initialize log handles and pathloss variable */
				if (sim_log_initialized == OPC_FALSE)
					{
					/* Set flag to prevent re-initialization.*/
					sim_log_initialized = OPC_TRUE;
				
					/* Configuration related notification handles.*/
					config_log_handle = op_prg_log_handle_create (OpC_Log_Category_Configuration,"Bluetooth", "Setup", 20);
					protocol_log_handle = op_prg_log_handle_create (OpC_Log_Category_Protocol,"Bluetooth", "Operation", 5);
					}
				
				
				
				/* Object id of this process. */
					my_objid = op_id_self ();
					
					// read attributes
					op_ima_obj_attr_get(my_objid, "Piconet Address", &My_piconet_address);
					op_ima_obj_attr_get(my_objid, "SCO Packet Type", &Tsco);
					op_ima_obj_attr_get(my_objid, "Polling Interval", &Poll_interval);
					/* make sure the polling interval is an even number */
					Poll_interval = Poll_interval % 2 == 0?Poll_interval:(Poll_interval + 1);
					op_ima_obj_attr_get(my_objid, "Initial ACL Data Rate", &Channel_condition);
					op_ima_obj_attr_get(my_objid, "ACL Slot Length", &Tx_slots);
					op_ima_obj_attr_get (my_objid, "Timing Offset", &offset);
					op_ima_obj_attr_get(my_objid, "Slave ACL Slot Length", &Slave_tx_slots);
					
				
				    /* random value with which to offset timeslot boundaries per piconet */
					/* "Random" is chosen by the user */
					if (offset == -1.0)
						Offset = op_dist_uniform (.00125);  
				    else
					/* a number was input by the user */	
						Offset = offset;
					
					if(BT_TRACE_ACTIVE)
						{
						printf ("  Master of Piconet %d has Offset %.7f\n", My_piconet_address, Offset);
						}
				
					
					// get the object id of my receiver channel
					tr_id = op_topo_child(op_topo_parent(my_objid), OPC_OBJTYPE_RARX, 0);
					op_ima_obj_attr_get(tr_id, "channel", &ch_id);
					rx_channel_objid = op_topo_child(ch_id, OPC_OBJTYPE_RARXCH, 0);
								
					// get the object id of my transmitter channel
					tr_id = op_topo_child(op_topo_parent(my_objid), OPC_OBJTYPE_RATX, 0);
					op_ima_obj_attr_get(tr_id, "channel", &ch_id);
					tx_channel_objid = op_topo_child(ch_id, OPC_OBJTYPE_RATXCH, 0);
				
					/* The hop table is initialized by sorting hop frequencies as specified */
					/* in the Bluetooth specification. The table is organized with the Even frequencies */
					/* first and then the Odd frequencies */
					for (i=0,j=0; i<NUMBER_OF_HOPS; i+=2)
						hop_table[j++]	= i;		/* Set the Even frequencies first */
					for (i=1; i<NUMBER_OF_HOPS; i+=2)
						hop_table[j++]	= i;		/* Then set the Odd frequencies */
					
				
					/* Make sure each piconet starts with a different freq segment */
					hop_segment_index += DELTA * My_piconet_address;
					hop_segment_index %= (NUMBER_OF_HOPS);    /* 0,16,32,48,64,1,17... in the 79 Hop model */
					bt_init_seg_hop_table ();		/* Init the first hopping sequence */
				
						
					// create the segmentation and reassembly buffers
					for (i=0;i<8;i++)// the 8th buffer is intended for broadcast traffic
						{
						Acl_seg_buf[i] = op_sar_buf_create(OPC_SAR_BUF_TYPE_SEGMENT, OPC_SAR_BUF_OPT_DEFAULT);		
						}
					for (i=0;i<3;i++) // bluetooth framing supports maximum of 3 voice connections
						{
						Sco_seg_buf[i] = op_sar_buf_create(OPC_SAR_BUF_TYPE_SEGMENT, OPC_SAR_BUF_OPT_SEG_PAD);
						}
					for (i=0;i<7;i++)
						{
						Rsm_buf[i] = op_sar_buf_create(OPC_SAR_BUF_TYPE_REASSEMBLY, OPC_SAR_BUF_OPT_DEFAULT);
						SCO_con[i]= -1;
						}
				
					/* initialize state variables */
					Num_SCO_cons             = 0;
					Voice_source_pk_size     = 0;
					Poll_slave_synch         = 0;
					/* Pk_count is used for a custom "packet whacker" that operates at L2 */
					Pk_count [0]             = 21;
					Pk_count [1]             = 4;
					Next_free_slot           = 0;
					Next_acl_slave           = 0;
					tx_old                   = 0;
					Next_control_slave       = 0;	
					Use_next_free_slot       = OPC_FALSE;
					
					// initialize piconet table and set slave attributes
					Number_of_slaves = init_piconet(my_objid);
					printf("number of slaves : %d\n",Number_of_slaves);
					
					/* register stats and initialize state variables related to the number of slaves */
					for (i = 0; i < Number_of_slaves; i++)
						{
						Control_packets_to_slave_stat = op_stat_reg("baseband.Control Packets to Slave", i, OPC_STAT_LOCAL);
						Control_packets_from_slave_stat = op_stat_reg("baseband.Control Packets from Slave", i, OPC_STAT_LOCAL);
						 // will be toggled before first ACL packet is sent; Seqn begins at 1 
						Seqn[i] = 0; 
						Last_poll[i] = 1;		
						//Slave_to_ack[i] = OPC_FALSE;
						Retx[i] = OPC_FALSE;
						Seqn_old[i] = 0;
						Slave_to_ack[i] = OPC_FALSE;
						} 
					
					/* Register local statistics */
					
					Mac_packets_sent_stat	= op_stat_reg("baseband.Packets sent (pkt)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_packets_recv_stat	= op_stat_reg("baseband.Packets received (pkt)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Retx_stat		        = op_stat_reg("baseband.Retransmissions", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_pkt_lost_stat		= op_stat_reg("baseband.Packet Loss", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Sco_pkt_received_stat   = op_stat_reg("baseband.SCO Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Sco_pkt_sent_stat       = op_stat_reg("baseband.SCO Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Acl_pk_received_stat    = op_stat_reg("baseband.ACL Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Acl_pk_sent_stat        = op_stat_reg("baseband.ACL Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_throughput_stat     = op_stat_reg("baseband.Throughput (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_fec_throughput_stat = op_stat_reg("baseband.FEC Throughput (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
				    Hop_value_stat          = op_stat_reg("baseband.Hop Value", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Null_pk_sent_stat       = op_stat_reg("baseband.Null Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Tx_skipped_stat         = op_stat_reg("baseband.Skipped Transmissions", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Nulls_received_stat     = op_stat_reg("baseband.Null Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Dropped_sco_stat        = op_stat_reg("baseband.Dropped SCO Packets", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_sdu_delay_stat      = op_stat_reg("baseband.MAC SDU Delay", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Control_packets_received_stat = op_stat_reg("baseband.Control Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Control_packets_sent_stat = op_stat_reg("baseband.Control Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Poll_pkts_sent_stat     = op_stat_reg("baseband.Poll packets sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Residual_sco_payload_errors_stat = op_stat_reg("baseband.Residual SCO Payload Errors", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					/* Register global statistics */
					Offset_gb_stat          = op_stat_reg("BT Clock Offset", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
					Gb_tput_stat            = op_stat_reg("Bluetooth Throughput.BT Throughput (bits/sec)", My_piconet_address, OPC_STAT_GLOBAL);
					Gb_overhead_tput_stat   = op_stat_reg("Bluetooth Overhead.BT Overhead (bits/sec)", My_piconet_address, OPC_STAT_GLOBAL);
					Gb_fec_tput_stat        = op_stat_reg("Bluetooth FEC Throughput.BT FEC Throughput (bits/sec)", My_piconet_address, OPC_STAT_GLOBAL);
					Control_packets_sent_gb_stat = op_stat_reg("Master Control Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
					Control_packets_received_gb_stat = op_stat_reg("Master Control Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
					Gb_aggregate_tput_stat  = op_stat_reg("Aggregate Bluetooth Tput", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				
					
					/* global stathandle.  This stat is written to in the pipeline. */
					Gb_bt_pkloss_rate_stat  = op_stat_reg("Bluetooth Packet Loss Rate", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
					
					op_stat_write_t (Offset_gb_stat, Offset, My_piconet_address); 
					
					/* schedule first event to check for required Poll transmissions */
					/* Occurs no sooner than first slot of 2nd SCO period */
					/*   and is guaranteed to occur on an odd slot - master to slave slot */
					/* The interrupts are staggered by Tsco periods                       */
					timeslots = (Poll_interval % 2 == 0)?Poll_interval:(Poll_interval + 1);
					for(i=0; i<Number_of_slaves; i++)
						{
						tx_time = (double)(Offset + (timeslots + 6 + 2 * i + Tsco)*SLOT_TIME);
						op_intrpt_schedule_self (tx_time, POLL);
						//if (BT_SCHEDULER_TRACE_ACTIVE)
							//{
				
							printf ("Initial POLL set for slave %d, slot %d\n", i, timeslots + 6 + 2 * i + Tsco);
						//	}
						}
				
				
					
				/* Also obtain the object ID of the surrounding node.		*/
				my_node_id = op_topo_parent (my_objid);
												
				/* Obtain the prohandle for this process.					*/
				own_prohandle = op_pro_self ();
												
				/*	Obtain the name of the process. It is the process model	*/
				/*	attribute on the surrounding module.					*/
				op_ima_obj_attr_get (my_objid, "process model", proc_model_name);
												
				/**	Register the process in the model-wide registry.				**/
				own_process_record_handle = (OmsT_Pr_Handle) oms_pr_process_register 
											  (my_node_id, my_objid, own_prohandle, proc_model_name);
				/*	Register my piconet and address.  */
				oms_pr_attr_set (own_process_record_handle, 
								 "piconet", 	OMSC_PR_NUMBER, (double)My_piconet_address,
								 "slave address", 	OMSC_PR_NUMBER, 99.0,
								  OPC_NIL);
				
				
				/* Write the message to the notification log*/
				op_prg_log_entry_write (config_log_handle,"Master INIT: Master of piconet %d initialized", My_piconet_address);
				
				printf("Master INIT: Master of piconet %d initialized\n", My_piconet_address);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (Init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "Init", "bt_master [Init exit execs]")


			/** state (Init) transition processing **/
			FSM_TRANSIT_ONLY ((BEGSIM), 1, state1_enter_exec, ;, Init, "BEGSIM", "", "Init", "Master Wait", "tr_0", "bt_master [Init -> Master Wait : BEGSIM / ]")
				/*---------------------------------------------------------*/



			/** state (Master Wait) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "Master Wait", state1_enter_exec, "bt_master [Master Wait enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"bt_master")


			/** state (Master Wait) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "Master Wait", "bt_master [Master Wait exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [Master Wait exit execs]", state1_exit_exec)
				{
				/* store the current slot as a state var; calculate it's value */
				/* upon exit from Master Wait */
				Current_slot = (int)(floor((op_sim_time() + .000001 - Offset) / SLOT_TIME));
				Current_slot_mod = Current_slot % Tsco;
				
				//if (BT_TIMING_TRACE_ACTIVE)
				//	{
					ev_type = op_ev_current();// op_intrpt_type (op_ev_current());//
					
				//	printf(" event type: %d\n", ev_type);
					if (op_ev_type(ev_type) ==  OPC_INTRPT_SELF)//op_intrpt_type() == OPC_INTRPT_SELF)////(ev_type == OPC_INTRPT_SELF)//
					{
						ev_code = op_ev_code (op_ev_current());
						printf("Ev code : %d\n", ev_code);
						switch (ev_code)
							{
							case TX:
							ev_name = "TX";
							break;
							case FREQ_HOP:
							ev_name = "FREQUENCY HOP";
							break;
							case POLL:
							ev_name = "POLL";
							break;
							case SCHEDULED_VOICE:
							ev_name = "SCHEDULED_VOICE";
							break;
							}
						}
					else if (PACKET_RECEIVED)
				   		ev_name = "BT PKT RECEIVED";
					else if (SLAVE_DONE)
						ev_name = "REMOTE FROM SLAVE";
					else if (FROM_STOC_OR_APP_OR_LM)
						ev_name = "FROM HIGHER LAYER";
					else
						ev_name = "UNKNOWN";
					
					printf ("Current slot: %d, Modulo: %d, Event: %s\n\n", Current_slot, Current_slot_mod, ev_name);
				//	}
				
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (Master Wait) transition processing **/
			FSM_PROFILE_SECTION_IN ("bt_master [Master Wait trans conditions]", state1_trans_conds)
			FSM_INIT_COND (TRANSMIT)
			FSM_TEST_COND (FROM_STOC_OR_APP_OR_LM)
			FSM_TEST_COND (PACKET_RECEIVED)
			FSM_TEST_COND (HOP)
			FSM_TEST_COND (NO_RESPONSE)
			FSM_TEST_COND (SLAVE_RESPONSE)
			FSM_TEST_LOGIC ("Master Wait")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "TRANSMIT", "", "Master Wait", "To BT Radio", "tr_2", "bt_master [Master Wait -> To BT Radio : TRANSMIT / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "FROM_STOC_OR_APP_OR_LM", "", "Master Wait", "From Stoc/App/LM", "tr_6", "bt_master [Master Wait -> From Stoc/App/LM : FROM_STOC_OR_APP_OR_LM / ]")
				FSM_CASE_TRANSIT (2, 4, state4_enter_exec, ;, "PACKET_RECEIVED", "", "Master Wait", "From BT Radio", "tr_14", "bt_master [Master Wait -> From BT Radio : PACKET_RECEIVED / ]")
				FSM_CASE_TRANSIT (3, 5, state5_enter_exec, ;, "HOP", "", "Master Wait", "Freq Hop", "tr_17", "bt_master [Master Wait -> Freq Hop : HOP / ]")
				FSM_CASE_TRANSIT (4, 6, state6_enter_exec, ;, "NO_RESPONSE", "", "Master Wait", "No Response", "tr_23", "bt_master [Master Wait -> No Response : NO_RESPONSE / ]")
				FSM_CASE_TRANSIT (5, 7, state7_enter_exec, ;, "SLAVE_RESPONSE", "", "Master Wait", "Slave Response", "tr_26", "bt_master [Master Wait -> Slave Response : SLAVE_RESPONSE / ]")
				}
				/*---------------------------------------------------------*/



			/** state (To BT Radio) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "To BT Radio", state2_enter_exec, "bt_master [To BT Radio enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [To BT Radio enter execs]", state2_enter_exec)
				{
				
				update_last_poll();
				Acl_pending = OPC_FALSE;
				
				/* if this is a voice interrupt, schedule the next voice slot for this connection*/
				int_code = (int )op_ev_code (op_ev_current ()); //op_intrpt_code (op_ev_current()); or op_ev_state(op_ev_current())
				printf("Int code : %d\n", int_code);
				if (int_code == SCHEDULED_VOICE)
					{
					Evh_voice = op_intrpt_schedule_self ((Current_slot + Tsco) * SLOT_TIME + Offset, SCHEDULED_VOICE);
					//if (BT_SCHEDULER_TRACE_ACTIVE)
					    printf ("Master %d: Voice slot scheduled for %d from %d, To BT Radio\n",\
							My_piconet_address, (Current_slot + Tsco), Current_slot);
					}
				else if (int_code == POLL)
					{
					/* schedule next event to check for required Poll transmissions */
					/*   Its guaranteed to occur on an odd slot - master to slave slot */
					timeslots = (Poll_interval % 2 == 0)?Poll_interval:(Poll_interval + 1);
					tx_time = (double)((Current_slot + timeslots)*SLOT_TIME) + Offset;
					Evh_poll = op_intrpt_schedule_self (tx_time, POLL);
					//if (BT_SCHEDULER_TRACE_ACTIVE)
					   printf ("master scheduled tx from 'POLL' for %d from slot %d\n", Current_slot + timeslots, Current_slot);
					}
					
				tx_type = get_tx_type();
				
				/* check to make sure there are enough upcoming free slots (not reserved by SCO) */
				/*  to complete this transmission */
				if (tx_type == ACL && Num_SCO_cons > 0 && Tx_slots > 1)
					{
					/* we can never send 5 slot packets under these conditions */
					if (Tx_slots == 5)
						{
						op_sim_message ("Master can't use 5 slots for ACL in presence of SCO", "Defaulting to single slot ACL for master");
						op_prg_log_entry_write (config_log_handle,"Master of piconet %d cannot use 5 slots for ACL in the presence of SCO\n"\
							"Defaulting to single slot ACL", My_piconet_address);
						Tx_slots = 1;
						}
					/* only other viable case is where tx slots is 3 and tsco is 6 */
					else if (Num_SCO_cons == 1 && Tsco == 6 && Tx_slots == 3)
						{
						/* can only use 3 slots from the 3rd slot of the Tsco period */
						/* If were in another slot, we have to wait to transmit */
						if (Current_slot_mod != 2)
							{
							tx_type = TX_WAIT;
							op_stat_write (Tx_skipped_stat, 1);
							}
						}
					else
						/* any other cases are invalid scenario configurations; default to */
						/*  single slot and show a message */
						{
						op_sim_message ("Master's 'Tx slots' configuration conflicts with SCO", "Defaulting to single slot");
						op_prg_log_entry_write (config_log_handle,"Master of piconet %d 'Tx slots' configuration conflicts with SCO\n"\
							"Defaulting to single slot ACL", My_piconet_address);
				
						Tx_slots = 1;
						}
					}
				if (tx_type != TX_ERROR && tx_type != TX_WAIT)
					{
					send_bt_pk(tx_type, "To BT Radio");
				
					/* make sure no POLL events are scheduled before the end of the slave's return slot*/
					/* and that no polls are scheduled for the next voice slot if scheduled */
					/* reschedule any that are scheduled. */
					num_events = op_ev_count_local ();
					next_event = op_ev_current ();
					for (i = 0; i<num_events; i++)
						{
						temp_time = op_ev_time (next_event);
						temp_slot = (int)(floor((temp_time + .000001 - Offset) / SLOT_TIME));
						/* check for POLLs scheduled for voice slot */
						if (((temp_slot <= Slave_response_slot)\
							&& (op_ev_code(next_event) == POLL) && i>0) ||\
							(int_code == SCHEDULED_VOICE && temp_slot == (Current_slot + Tsco)\
							&& op_ev_code(next_event) == POLL))
							{		
							poll_ev = next_event;
							next_event = op_ev_next_local (next_event);
							op_ev_cancel (poll_ev);
				
							Evh_poll = op_intrpt_schedule_self (temp_time + (Poll_interval * SLOT_TIME), POLL);
							if (BT_SCHEDULER_TRACE_ACTIVE)
								printf ("TO BT RADIO: poll(%d) at %d rescheduled for %d\n", i, temp_slot, temp_slot + Poll_interval);
							
							}
						else
							next_event = op_ev_next_local (next_event);
						}		
				
					}
				else
					{
					if (tx_type == TX_ERROR && int_code != POLL)
						{
						op_sim_message ("No transmission: see sim log", "");
						op_prg_log_entry_write (protocol_log_handle,"Transmission error: No TX occcured at slot %d\n", Current_slot);
						}
					}
				
				
				
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (To BT Radio) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "To BT Radio", "bt_master [To BT Radio exit execs]")


			/** state (To BT Radio) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "To BT Radio", "Master Wait", "tr_3", "bt_master [To BT Radio -> Master Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (From Stoc/App/LM) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "From Stoc/App/LM", state3_enter_exec, "bt_master [From Stoc/App/LM enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [From Stoc/App/LM enter execs]", state3_enter_exec)
				{
				/* get packet from stream and the event ICI */
				stoch_pkt = op_pk_get(op_intrpt_strm());
				stoch_ici = op_ev_ici(op_ev_current());
				
				/* stamp the packet so we can get the MAC SDU Delay stat */
				op_pk_stamp (stoch_pkt);
				
				/* is this a control, acl, or sco packet? */
				op_ici_attr_get (stoch_ici, "QOS", &qos);
				op_ici_attr_get (stoch_ici, "destination", &dest_addr);
				
				scheduled_it = OPC_FALSE;
				
				/* voice packet for slave that doesn't have an SCO connection */
				if(qos == VOICE && SCO_con[dest_addr] == -1) 
				{
					if ((Tsco == 2 && Num_SCO_cons > 0) ||(Tsco == 4 && Num_SCO_cons > 1) || (Tsco == 6 && Num_SCO_cons > 2)) 
					{
						/* Maximum number of SCO connections present; deny connection */
						op_pk_destroy(stoch_pkt); 
						op_sim_message ("connection denied, ignoring voice source packet\n", \
							"check sim voice configurations");
						op_prg_log_entry_write (config_log_handle,"Maximum number of voice connections already set for piconet %d: connection denied.\n" 
							"Ignoring voice source packet for destination %d. Check voice configurations.", My_piconet_address, dest_addr);
					}
					else
					/* create a voice connection */
						{
						Num_SCO_cons++;
						if (BT_SCHEDULER_TRACE_ACTIVE)
							{
							printf("New SCO Connection, # %d\n", Num_SCO_cons);
							}
						
						/* store the connection number used to index the SCO_seg_buf */
						SCO_con[dest_addr] = Num_SCO_cons;
						Voice_source_pk_size = op_pk_total_size_get (stoch_pkt);
						op_sar_segbuf_pk_insert (Sco_seg_buf[Num_SCO_cons-1], stoch_pkt, 0);
						
					    /* find number of timeslots in the future to schedule this connection */
						/* this slot corresponds to the slot in the next Tsco period with */
						/*  a modulus of 0 for con 1, 2 for con 2, and 4 for con 3 */
						/* time to transmit */	 
						timeslots = Tsco - Current_slot_mod + 2*Num_SCO_cons -2;
						tx_time = (Current_slot + timeslots) * SLOT_TIME + Offset;
				
						/* Schedule a tx interrupt if none are pending */
						if (op_ev_valid (Evh_tx))
							{
							/* check for time conflict */
							temp_slot = (int)(floor((op_ev_time (Evh_tx) + .000001 - Offset) / SLOT_TIME));
							if (temp_slot == (timeslots + Current_slot))
								{
								op_ev_cancel (Evh_tx);
								if (BT_SCHEDULER_TRACE_ACTIVE)
									{
									printf ("FROM STOCH: TX at %d cancelled, curr slot is %d\n",\
										temp_slot, Current_slot);
									}
									
								}
							}		
								
						/* schedule the first VOICE interrupt for this connection  */
						op_intrpt_schedule_self (tx_time, SCHEDULED_VOICE);
						scheduled_it = OPC_TRUE;
						if (BT_SCHEDULER_TRACE_ACTIVE)
							printf ("master scheduled first SCHEDULED VOICE for %d at slot %d for con %d\n", Current_slot + timeslots, Current_slot, Num_SCO_cons);
				
						}
				
					}
					
				else if (qos == VOICE)
				{
					/* VOICE packet for an existing connection.  Determine with what connection */
					/* (1, 2 or 3 is the range) it is associated.                               */
				    /* The first SCO connection to be established uses Sco_seg_buf[0], the seconds */
				    /*   uses Sco_seg_buf[1]...                                                    */
					con_index = SCO_con[dest_addr] - 1;
					Voice_source_pk_size = op_pk_total_size_get (stoch_pkt);
					op_sar_segbuf_pk_insert (Sco_seg_buf[con_index], stoch_pkt, 0);
				}
				
				else if (qos == DATA || qos == CONTROL)
					{
					/* enqueue the packet in either the ACL SAR buffer or CONTROL subqueue, depending on qos */
					if (qos == DATA)
						{
						op_sar_segbuf_pk_insert (Acl_seg_buf[dest_addr], stoch_pkt, 0);
						}
					/* CONTROL messages aren't segmented, so we're using a subqueue for lower overhead */
					else if (qos == CONTROL)
						{
						op_subq_pk_insert (dest_addr, stoch_pkt, OPC_QPOS_TAIL);
						}
					if (!op_ev_valid (Evh_tx))
						{
						/* determine next master to slave slot */
						if ((Current_slot % 2) == 0)
							Next_free_slot = Current_slot + 2;
						else
							Next_free_slot = Current_slot + 1;
						if(!Acl_pending)
							{
							next_tx_event("From Stoc/App: qos = DATA");
							}
				
							
						}
					}
				if (scheduled_it)
					{
					/* reschedule any POLL events scheduled at the same time */
					num_events = op_ev_count_local ();
					next_event = op_ev_current ();
					for (i = 0; i<num_events; i++)
						{
						temp_time = op_ev_time (next_event);
						temp_slot = (int)(floor((temp_time + .000001 - Offset) / SLOT_TIME));
						if ((temp_slot == (Current_slot + timeslots))\
							&& (op_ev_code(next_event) == POLL) && i>0)
							{
							poll_ev = next_event;
							next_event = op_ev_next_local (next_event);
							op_ev_cancel (poll_ev);
							Evh_poll = op_intrpt_schedule_self (temp_time + (Poll_interval * SLOT_TIME), POLL);
							if (BT_SCHEDULER_TRACE_ACTIVE)
								printf ("FROM STOCH: poll(%d) at %d rescheduled for %d\n",i, temp_slot, temp_slot + Poll_interval);
							
							}
						else
							next_event = op_ev_next_local (next_event);
				
						}
				
					}
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (From Stoc/App/LM) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "From Stoc/App/LM", "bt_master [From Stoc/App/LM exit execs]")


			/** state (From Stoc/App/LM) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "From Stoc/App/LM", "Master Wait", "tr_7", "bt_master [From Stoc/App/LM -> Master Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (From BT Radio) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "From BT Radio", state4_enter_exec, "bt_master [From BT Radio enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [From BT Radio enter execs]", state4_enter_exec)
				{
				/* get BT packet */
				bt_pkt = op_pk_get (BT_INSTREAM);
				
				op_pk_nfd_get (bt_pkt, "Way", &way);
				op_pk_nfd_get (bt_pkt, "PICO_ADDR", &pico_addr);
				op_pk_nfd_get (bt_pkt, "Accept", &accept);
				op_pk_nfd_get (bt_pkt, "AM_ADDR", &source_addr);
				op_pk_nfd_get (bt_pkt, "TYPE", &packet_type);
				printf("packet type received from slave : %d\n", packet_type);
				
				//op_pk_format (bt_pkt, BT_packet_type);
				//op_pk_nfd_get (bt_pkt, "TYPE", &pk_type);
				
				if(packet_type == 0)
					strcpy(BT_packet_type,"NULL");
				
				else if(packet_type == 1)
					strcpy(BT_packet_type,"HV1");	
				
				else if(packet_type == 2)
					strcpy(BT_packet_type,"HV2");
				
				else if(packet_type == 3)
					strcpy(BT_packet_type,"HV3");
				
				else if(packet_type == 4)
					strcpy(BT_packet_type,"DM1");
				
				else if(packet_type == 5)
					strcpy(BT_packet_type,"DM3");
				
				else if(packet_type == 6)
					strcpy(BT_packet_type,"DM5");
				
				else if(packet_type == 7)
					strcpy(BT_packet_type,"DH1");
				
				else if(packet_type == 8)
					strcpy(BT_packet_type,"DH3");
				
				else if(packet_type == 9)
					strcpy(BT_packet_type,"DH5");
				
				else if(packet_type == 10)
					strcpy(BT_packet_type,"POLL");
				
				printf("BT packet type received from slave %s\n", BT_packet_type);
				get_pk_type(BT_packet_type, pk_stats);
				
				/**************************************************/
				/* Custom packet whacker to test retransmissions  */
				/* Remove comments to use, it sets the accept flag*/
				/*  to false in 4 consecutive received BT packets */
				/*  every 20 packets.                             */
				/**************************************************/
				 /*if (++Pk_count[0] % 20 == 0)
					 {
					 accept = OPC_FALSE;
					 if(--Pk_count[1]>0)
						 Pk_count[0]--;
					 else
						 Pk_count[1] = 4;
					 }*/
				
				/* Flag:  accept the payload packet of this packet */
				packet_accept = OPC_FALSE;
				/* Flag:  remove fec pkt from ACL transmission */
				remove_fec    = OPC_FALSE;
				/* default logical channel to DATA */
				logical_channel = DATA;
				
				
				/* the BT packet is for me; process it */
				if (way == SLAVE_TO_MASTER && pico_addr == My_piconet_address)
					{
						
					if (accept)
						{
						/* The global variables Gb_overhead_tput and Gb_tput are */
						/*  declared in the master and externed in the slave.    */
						Gb_overhead_tput[My_piconet_address] += pk_stats[1];
						op_stat_write (Gb_overhead_tput_stat, Gb_overhead_tput[My_piconet_address]);
						Gb_overhead_tput[My_piconet_address] = 0;
						op_stat_write (Mac_packets_recv_stat, 1);
						op_stat_write (Gb_tput_stat, Gb_tput[My_piconet_address]);
						op_stat_write (Gb_aggregate_tput_stat, Gb_tput[My_piconet_address]);
						Gb_tput[My_piconet_address] = 0;
				
						/* update arq variables */
						op_pk_nfd_get (bt_pkt, "SEQN", &seqn);
						op_pk_nfd_get (bt_pkt, "ARQ", &arq);
						if (arq)
							{
							Retx [source_addr] = OPC_FALSE;
							Acl_pending = OPC_FALSE;
							}
				
						if (BT_ACL_TRACE_ACTIVE || BT_SCO_TRACE_ACTIVE)
							printf ("Master %d received %s from slave %d at slot %d\n", My_piconet_address, BT_packet_type, source_addr, Current_slot); 
				
						if (pk_stats[TYPE] == NULL_PKT)
							op_stat_write (Nulls_received_stat, 1);
						
							/* Assume this is a voice packet */
							/* Get the empty_voice_flag */
						if (pk_stats[CON] == SCO)
							{
							Next_free_slot = Current_slot + 1;
							
							/* LTRACE for SCO traffic */
							if (BT_SCO_TRACE_ACTIVE)
								{
								printf ("Master received %s from slave %d at time %.8f for connection %d, slot modulo is %d\n", BT_packet_type, source_addr, op_sim_time(), SCO_con[source_addr], Current_slot_mod);
								}
				
							
							op_stat_write (Sco_pkt_received_stat, 1);
							
							op_pk_nfd_get(bt_pkt, "empty_voice_flag", &empty_voice);
							if (!empty_voice)
								packet_accept = OPC_TRUE;
							}
						/* this could be a new acl packet, a retranmitted packet, or a control packet */
						else if (pk_stats[CON] == ACL)
							{
							op_pk_nfd_get (bt_pkt, "L_CH", &logical_channel);
							/* If this is a normal ACL or ACL_RETX packet */
							Slave_to_ack [source_addr] = OPC_TRUE;
							Arq [source_addr] = OPC_TRUE;
							op_stat_write (Acl_pk_received_stat, 1);
							/* if this payload is new to me */
							if (Seqn_old[source_addr] != seqn)
								{
								packet_accept = OPC_TRUE;
								/* Only medium data rate packets contain FEC */
								if(pk_stats[TYPE] == DM1 || pk_stats[TYPE] == DM3 || pk_stats[TYPE] == DM5)
									remove_fec    = OPC_TRUE;
								}
							if (BT_ARQ_TRACE_ACTIVE)
								{
								printf ("Master %s ACL, Seqn is %d, slot %d\n", packet_accept?"ACCEPTED":"DIDN'T ACCEPT", seqn, Current_slot);
								}
							Seqn_old[source_addr] = seqn;
							}
					
						
						 if (packet_accept)
							{
							/* get the payload segment and place in the reassembly buffer */
							op_pk_nfd_get (bt_pkt, "Frame Body", &payload_pkt);
							tput_size = op_pk_total_size_get (payload_pkt);
							if (pk_stats[CON] == SCO)
								{
								op_pk_nfd_get (bt_pkt, "Errors", &payload_errors);
								tput_size -= (double)(payload_errors);
								op_stat_write (Residual_sco_payload_errors_stat, payload_errors); 
								}
							op_stat_write (Gb_tput_stat, tput_size);
							op_stat_write (Gb_aggregate_tput_stat, tput_size);
							op_stat_write (Mac_throughput_stat, tput_size);
							
							/* calculate or measure fec tput depending on packet received */
							/* HV1 and HV2 packets aren't modeled with explicit fec packets because they are */
							/* of a constant size.  Simply record their known bit values. */
							if (!(strcmp(BT_packet_type,"HV1")))
								{
								op_stat_write (Mac_fec_throughput_stat, HV1_FEC);
								Gb_fec_tput[My_piconet_address] += HV1_FEC;
								}
							else if (!(strcmp(BT_packet_type,"HV2")))
								{
								op_stat_write (Mac_fec_throughput_stat, HV2_FEC);
								Gb_fec_tput[My_piconet_address] += HV2_FEC;
								}
							
							/* ACL packets can have varying numbers of FEC bits.  Get the size of the FEC packet */
							/* sent and add it to the stat */
							else if (remove_fec)
								{
								op_pk_nfd_get (bt_pkt, "FEC", &fec_pkt);
								fec_size = op_pk_total_size_get (fec_pkt);
								op_pk_destroy (fec_pkt);
								
								op_stat_write (Mac_fec_throughput_stat, fec_size);
								Gb_fec_tput[My_piconet_address] += fec_size;
								}
							
							/* Send control packets directly to the Link Manager source/sink */
							if (logical_channel == CONTROL)
								{
								op_stat_write (Control_packets_received_gb_stat, 1);
								op_stat_write (Control_packets_received_stat, 1);
								op_stat_write_t (Control_packets_from_slave_stat, source_addr, 1);
								op_stat_write (Mac_sdu_delay_stat, op_sim_time() - op_pk_stamp_time_get (payload_pkt));
								op_pk_send (payload_pkt, CONTROL_OUTSTREAM);
								}
				
							else /* all other traffic goes thru SAR */
								op_sar_rsmbuf_seg_insert (Rsm_buf[source_addr], payload_pkt);
						
							/* Null and Poll packets don't carry payload packets */
							/* get all completed packets from the Rsm buf and send to the sink */
							while (op_sar_rsmbuf_pk_count (Rsm_buf[source_addr]) > 0)
								{
								up_pkt = op_sar_rsmbuf_pk_remove (Rsm_buf[source_addr]);
								op_stat_write (Mac_sdu_delay_stat, op_sim_time() - op_pk_stamp_time_get (up_pkt));
											
								strcpy(BT_packet_type, "empty");
								pk_type = op_pk_type (up_pkt);
								if (pk_type == OPC_PACKET_TYPE_FORMATTED)
									{
									op_pk_format(up_pkt, BT_packet_type);
									}
								if (strcmp(BT_packet_type, "ip_dgram_v4") == 0)
									{
									op_pk_send (up_pkt, APP_OUTSTREAM);
									}
								else 
									{
									 op_pk_send (up_pkt, STOCHASTIC_OUTSTREAM);
									}
								}
							}/* end packet_accept (not to be confused with accept) */
						op_stat_write (Gb_fec_tput_stat, Gb_fec_tput[My_piconet_address]);
						Gb_fec_tput[My_piconet_address] = 0;
						
					   	
						/* Determine the next free slot on which I can transmit */	
						if (pk_stats[CON] != SCO)
							{
							Use_next_free_slot = OPC_TRUE;
							Next_free_slot = Slave_response_slot + pk_stats[SLOTS];
				
							}
						else
							{
							Next_free_slot = Current_slot + 1;
							}
							
							display_slot = next_tx_event("FROM BT");
							
							if(!display_slot)
								{
								Acl_pending = OPC_FALSE;
								}
							
							Use_next_free_slot = OPC_FALSE;
						}
					else /* not accepted, packet is for me but received too many errors in the pipeline */
						{
						if (pk_stats[CON] == ACL || pk_stats[CON] == ACL_RETX)
							Arq [source_addr] = NAK;
						op_stat_write(Mac_pkt_lost_stat, 1);
						if (BT_ACL_TRACE_ACTIVE || BT_SCO_TRACE_ACTIVE)
						   printf ("Master %d LOST %s from slave %d at slot %d\n", My_piconet_address, BT_packet_type, source_addr, Current_slot); 
						
						}
					}
				/* the packet processing is done so destroy it */
				op_pk_destroy (bt_pkt);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (From BT Radio) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "From BT Radio", "bt_master [From BT Radio exit execs]")


			/** state (From BT Radio) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "From BT Radio", "Master Wait", "tr_15", "bt_master [From BT Radio -> Master Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (Freq Hop) enter executives **/
			FSM_STATE_ENTER_FORCED (5, "Freq Hop", state5_enter_exec, "bt_master [Freq Hop enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [Freq Hop enter execs]", state5_enter_exec)
				{
				/* this hop is for the slave's transmission */
				hop(Current_slot + 1);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** state (Freq Hop) exit executives **/
			FSM_STATE_EXIT_FORCED (5, "Freq Hop", "bt_master [Freq Hop exit execs]")


			/** state (Freq Hop) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Freq Hop", "Master Wait", "tr_18", "bt_master [Freq Hop -> Master Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (No Response) enter executives **/
			FSM_STATE_ENTER_FORCED (6, "No Response", state6_enter_exec, "bt_master [No Response enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [No Response enter execs]", state6_enter_exec)
				{
				int_code = op_intrpt_code();
				slave_addr = int_code - 20;
				
				//if (BT_ACL_TRACE_ACTIVE)
					printf ("in no response from slave %d\n", slave_addr);
				
				/* we didn't get the expected response from this slave. */
				/* We will signal it to retransmit */
				Arq[slave_addr] = NAK;
				
				/* schedule the next master tx */
				Next_free_slot = Slave_response_slot + 1;
				
				Use_next_free_slot = OPC_TRUE;
				display_slot = next_tx_event("NO RESPONSE");
				if (!display_slot)
					{
					Acl_pending = OPC_FALSE;
					}
							
				
				Use_next_free_slot = OPC_FALSE;
				}
				FSM_PROFILE_SECTION_OUT (state6_enter_exec)

			/** state (No Response) exit executives **/
			FSM_STATE_EXIT_FORCED (6, "No Response", "bt_master [No Response exit execs]")


			/** state (No Response) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "No Response", "Master Wait", "tr_24", "bt_master [No Response -> Master Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (Slave Response) enter executives **/
			FSM_STATE_ENTER_FORCED (7, "Slave Response", state7_enter_exec, "bt_master [Slave Response enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master [Slave Response enter execs]", state7_enter_exec)
				{
				int_code = op_intrpt_code ();
				
				/* cancel the no response event */
				op_ev_cancel (No_response_evh);
				
				/* the interrupt code is the value of the number of slots used by slave for it's tx */
				/* Schedule a tx event for next master to slave slot */
				if (int_code != NO_TX)
					{
					Next_free_slot = Slave_response_slot + int_code;
					
					Use_next_free_slot = OPC_TRUE;
					
					
					/* make sure no POLL events are scheduled before the end of the slave's final return slot*/
					/* reschedule any that are scheduled. */
					num_events = op_ev_count_local ();
					next_event = op_ev_current ();
					for (i = 0; i<num_events; i++)
						{
						temp_time = op_ev_time (next_event);
						temp_slot = (int)(floor((temp_time + .000001 - Offset) / SLOT_TIME));
						/* check for POLLs scheduled before next free slot */
						if (((temp_slot < Next_free_slot)\
							&& (op_ev_code(next_event) == POLL) && i>0) )
							{	
							poll_ev = next_event;
							next_event = op_ev_next_local (next_event);
							op_ev_cancel (poll_ev);
				
							Evh_poll = op_intrpt_schedule_self (temp_time + (Poll_interval * SLOT_TIME), POLL);
							if (BT_SCHEDULER_TRACE_ACTIVE)
								printf ("Slave Response: poll(%d) at %d rescheduled for %d\n", i, temp_slot, temp_slot + Poll_interval);
							
							}
						else
							next_event = op_ev_next_local (next_event);
						}
				
					display_slot = next_tx_event("SLAVE RESPONSE (TX)");
					if (!display_slot)
						{
						Acl_pending = OPC_FALSE;
						}
							
				
					Use_next_free_slot = OPC_FALSE;
					
					}
				else
					{
					Next_free_slot = Slave_response_slot + 1;
				    Use_next_free_slot = OPC_TRUE;
				
					display_slot = next_tx_event("SLAVE RESPONSE (NO TX)");
					if (!display_slot)
						{
						Acl_pending = OPC_FALSE;
						}
					Use_next_free_slot = OPC_FALSE;
					}
				}
				FSM_PROFILE_SECTION_OUT (state7_enter_exec)

			/** state (Slave Response) exit executives **/
			FSM_STATE_EXIT_FORCED (7, "Slave Response", "bt_master [Slave Response exit execs]")


			/** state (Slave Response) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Slave Response", "Master Wait", "tr_27", "bt_master [Slave Response -> Master Wait : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"bt_master")
		}
	}




void
_op_bt_master_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_bt_master_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_bt_master_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (pr_state_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_bt_master_svar function. */
#undef piconet_table
#undef rx_channel_objid
#undef tx_channel_objid
#undef Acl_seg_buf
#undef Sco_seg_buf
#undef Rsm_buf
#undef My_piconet_address
#undef hop_inside_index
#undef segment_hop_table
#undef hop_segment_index
#undef hop_table
#undef Tsco
#undef Poll_interval
#undef Channel_condition
#undef Tx_slots
#undef Slave_tx_slots
#undef Number_of_slaves
#undef Slave_channel_condition_ptrs
#undef Slave_channel_condition
#undef SCO_con
#undef Num_SCO_cons
#undef Current_slot
#undef Current_slot_mod
#undef Last_hop_slot
#undef Dest_addr
#undef Last_poll
#undef Last_poll_update
#undef Last_slave_polled
#undef Poll_slave_synch
#undef Retx
#undef Next_acl_slave
#undef Seqn
#undef Seqn_old
#undef Slave_to_ack
#undef Arq
#undef Last_acl_pk_type
#undef Slave_response_slot
#undef Next_free_slot
#undef Acl_pending
#undef Use_next_free_slot
#undef Pk_count
#undef Next_control_slave
#undef Logical_channel
#undef Mac_packets_sent_stat
#undef Mac_packets_recv_stat
#undef Mac_pkt_lost_stat
#undef Sco_pkt_received_stat
#undef Sco_pkt_sent_stat
#undef Mac_throughput_stat
#undef Hop_value_stat
#undef Mac_fec_throughput_stat
#undef Offset_gb_stat
#undef Gb_tput_stat
#undef Gb_overhead_tput_stat
#undef Gb_fec_tput_stat
#undef Poll_pkts_sent_stat
#undef Acl_pk_sent_stat
#undef Acl_pk_received_stat
#undef Retx_stat
#undef Null_pk_sent_stat
#undef Tx_skipped_stat
#undef Dropped_sco_stat
#undef Nulls_received_stat
#undef Control_packets_sent_stat
#undef Control_packets_received_stat
#undef Mac_sdu_delay_stat
#undef Control_packets_from_slave_stat
#undef Control_packets_to_slave_stat
#undef Control_packets_sent_gb_stat
#undef Control_packets_received_gb_stat
#undef Gb_aggregate_tput_stat
#undef Residual_sco_payload_errors_stat
#undef Evh_poll
#undef No_response_evh
#undef Evh_tx
#undef Evh_voice
#undef Voice_source_pk_size
#undef Offset
#undef tx_old
#undef Retx_pkptr

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_bt_master_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_bt_master_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (bt_master)",
		sizeof (bt_master_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_bt_master_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	bt_master_state * ptr;
	FIN_MT (_op_bt_master_alloc (obtype))

	ptr = (bt_master_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "bt_master [Init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_bt_master_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	bt_master_state		*prs_ptr;

	FIN_MT (_op_bt_master_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (bt_master_state *)gen_ptr;

	if (strcmp ("piconet_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->piconet_table);
		FOUT
		}
	if (strcmp ("rx_channel_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rx_channel_objid);
		FOUT
		}
	if (strcmp ("tx_channel_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->tx_channel_objid);
		FOUT
		}
	if (strcmp ("Acl_seg_buf" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Acl_seg_buf);
		FOUT
		}
	if (strcmp ("Sco_seg_buf" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Sco_seg_buf);
		FOUT
		}
	if (strcmp ("Rsm_buf" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Rsm_buf);
		FOUT
		}
	if (strcmp ("My_piconet_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->My_piconet_address);
		FOUT
		}
	if (strcmp ("hop_inside_index" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hop_inside_index);
		FOUT
		}
	if (strcmp ("segment_hop_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->segment_hop_table);
		FOUT
		}
	if (strcmp ("hop_segment_index" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->hop_segment_index);
		FOUT
		}
	if (strcmp ("hop_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->hop_table);
		FOUT
		}
	if (strcmp ("Tsco" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Tsco);
		FOUT
		}
	if (strcmp ("Poll_interval" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Poll_interval);
		FOUT
		}
	if (strcmp ("Channel_condition" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Channel_condition);
		FOUT
		}
	if (strcmp ("Tx_slots" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Tx_slots);
		FOUT
		}
	if (strcmp ("Slave_tx_slots" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Slave_tx_slots);
		FOUT
		}
	if (strcmp ("Number_of_slaves" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Number_of_slaves);
		FOUT
		}
	if (strcmp ("Slave_channel_condition_ptrs" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Slave_channel_condition_ptrs);
		FOUT
		}
	if (strcmp ("Slave_channel_condition" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Slave_channel_condition);
		FOUT
		}
	if (strcmp ("SCO_con" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->SCO_con);
		FOUT
		}
	if (strcmp ("Num_SCO_cons" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Num_SCO_cons);
		FOUT
		}
	if (strcmp ("Current_slot" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Current_slot);
		FOUT
		}
	if (strcmp ("Current_slot_mod" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Current_slot_mod);
		FOUT
		}
	if (strcmp ("Last_hop_slot" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Last_hop_slot);
		FOUT
		}
	if (strcmp ("Dest_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Dest_addr);
		FOUT
		}
	if (strcmp ("Last_poll" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Last_poll);
		FOUT
		}
	if (strcmp ("Last_poll_update" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Last_poll_update);
		FOUT
		}
	if (strcmp ("Last_slave_polled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Last_slave_polled);
		FOUT
		}
	if (strcmp ("Poll_slave_synch" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Poll_slave_synch);
		FOUT
		}
	if (strcmp ("Retx" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Retx);
		FOUT
		}
	if (strcmp ("Next_acl_slave" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Next_acl_slave);
		FOUT
		}
	if (strcmp ("Seqn" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Seqn);
		FOUT
		}
	if (strcmp ("Seqn_old" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Seqn_old);
		FOUT
		}
	if (strcmp ("Slave_to_ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Slave_to_ack);
		FOUT
		}
	if (strcmp ("Arq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Arq);
		FOUT
		}
	if (strcmp ("Last_acl_pk_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Last_acl_pk_type);
		FOUT
		}
	if (strcmp ("Slave_response_slot" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Slave_response_slot);
		FOUT
		}
	if (strcmp ("Next_free_slot" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Next_free_slot);
		FOUT
		}
	if (strcmp ("Acl_pending" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acl_pending);
		FOUT
		}
	if (strcmp ("Use_next_free_slot" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Use_next_free_slot);
		FOUT
		}
	if (strcmp ("Pk_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Pk_count);
		FOUT
		}
	if (strcmp ("Next_control_slave" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Next_control_slave);
		FOUT
		}
	if (strcmp ("Logical_channel" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Logical_channel);
		FOUT
		}
	if (strcmp ("Mac_packets_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_packets_sent_stat);
		FOUT
		}
	if (strcmp ("Mac_packets_recv_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_packets_recv_stat);
		FOUT
		}
	if (strcmp ("Mac_pkt_lost_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_pkt_lost_stat);
		FOUT
		}
	if (strcmp ("Sco_pkt_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Sco_pkt_received_stat);
		FOUT
		}
	if (strcmp ("Sco_pkt_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Sco_pkt_sent_stat);
		FOUT
		}
	if (strcmp ("Mac_throughput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_throughput_stat);
		FOUT
		}
	if (strcmp ("Hop_value_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Hop_value_stat);
		FOUT
		}
	if (strcmp ("Mac_fec_throughput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_fec_throughput_stat);
		FOUT
		}
	if (strcmp ("Offset_gb_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Offset_gb_stat);
		FOUT
		}
	if (strcmp ("Gb_tput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Gb_tput_stat);
		FOUT
		}
	if (strcmp ("Gb_overhead_tput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Gb_overhead_tput_stat);
		FOUT
		}
	if (strcmp ("Gb_fec_tput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Gb_fec_tput_stat);
		FOUT
		}
	if (strcmp ("Poll_pkts_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Poll_pkts_sent_stat);
		FOUT
		}
	if (strcmp ("Acl_pk_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acl_pk_sent_stat);
		FOUT
		}
	if (strcmp ("Acl_pk_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acl_pk_received_stat);
		FOUT
		}
	if (strcmp ("Retx_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Retx_stat);
		FOUT
		}
	if (strcmp ("Null_pk_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Null_pk_sent_stat);
		FOUT
		}
	if (strcmp ("Tx_skipped_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Tx_skipped_stat);
		FOUT
		}
	if (strcmp ("Dropped_sco_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Dropped_sco_stat);
		FOUT
		}
	if (strcmp ("Nulls_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Nulls_received_stat);
		FOUT
		}
	if (strcmp ("Control_packets_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_packets_sent_stat);
		FOUT
		}
	if (strcmp ("Control_packets_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_packets_received_stat);
		FOUT
		}
	if (strcmp ("Mac_sdu_delay_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_sdu_delay_stat);
		FOUT
		}
	if (strcmp ("Control_packets_from_slave_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_packets_from_slave_stat);
		FOUT
		}
	if (strcmp ("Control_packets_to_slave_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_packets_to_slave_stat);
		FOUT
		}
	if (strcmp ("Control_packets_sent_gb_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_packets_sent_gb_stat);
		FOUT
		}
	if (strcmp ("Control_packets_received_gb_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_packets_received_gb_stat);
		FOUT
		}
	if (strcmp ("Gb_aggregate_tput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Gb_aggregate_tput_stat);
		FOUT
		}
	if (strcmp ("Residual_sco_payload_errors_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Residual_sco_payload_errors_stat);
		FOUT
		}
	if (strcmp ("Evh_poll" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Evh_poll);
		FOUT
		}
	if (strcmp ("No_response_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->No_response_evh);
		FOUT
		}
	if (strcmp ("Evh_tx" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Evh_tx);
		FOUT
		}
	if (strcmp ("Evh_voice" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Evh_voice);
		FOUT
		}
	if (strcmp ("Voice_source_pk_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Voice_source_pk_size);
		FOUT
		}
	if (strcmp ("Offset" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Offset);
		FOUT
		}
	if (strcmp ("tx_old" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->tx_old);
		FOUT
		}
	if (strcmp ("Retx_pkptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Retx_pkptr);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

