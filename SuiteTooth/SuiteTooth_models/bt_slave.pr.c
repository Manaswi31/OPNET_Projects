/* Process model C form file: bt_slave.pr.c */
/* Portions of this file copyright 2014 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from bt_slave.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char bt_slave_pr_c [] = "MIL_3_Tfile_Hdr_ 1800 30A op_runsim_opt 7 55BC8ACE 55BC8ACE 1 volta chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 468d 2                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/***********************************************/
// The SuiteTooth model set was developed by
// HIGHLAND SYSTEMS, INC.
//
// It incorporates code available in the public
// domain and other code that is the property of
// OPNET Technologies, Inc.
//
// Inquiries may be addressed to:
// 
// Highland Systems, Inc.
// (703) 312 0830
// info@highsys.com
// www.highsys.com
/***********************************************/

#include <math.h>
#include "oms_pr.h"

#define ACK          1
#define NAK          0

#define CONTROL_Q    0

#define TYPE         0
#define OVERHEAD     1
#define SLOTS        2
#define CON_TYPE     3

#define SLOT_TIME     .000625
#define INIT          -1
#define VOICE_TX      0
#define TX            1
#define VOICELESS     2
#define MAX_PICONETS  100

/* define streams */
#define STOCHASTIC_INSTREAM  			0
#define BT_INSTREAM          			1
#define BT_OUTSTREAM         			1
#define STOCHASTIC_OUTSTREAM 			0
#define APP_INSTREAM		 			2
#define APP_OUTSTREAM		 			2
#define CONTROL_INSTREAM   				3
#define CONTROL_OUTSTREAM				3


/* define possible transmission types */
/* CONTROL must have an identical value in the master HB */
#define CONTROL     10
#define POLL        1
#define SCO         2
#define ACL_RETX    4
#define ACL         5
#define NULL_TX     6
#define NO_TX       12
#define FLUSH       14
#define ERROR       101

/* define packet types */

#define NULL_PKT            0
#define HV1                 1
#define HV2                 2
#define HV3                 3
#define DM1                 4
#define DM3                 5
#define DM5                 6
#define DH1                 7
#define DH3                 8
#define DH5                 9
#define POLL_PKT            10

/* define header bit sizes */
#define ACCESS_CODE         72
#define HEADER              54
#define SS_PAYLOAD_HEADER    8
#define MS_PAYLOAD_HEADER   16

/* define constant packet payload values */
#define HV1_PAYLOAD         80        
#define HV2_PAYLOAD        160 
#define HV3_PAYLOAD        240 
#define HV1_FEC            160
#define HV2_FEC             80
#define HV3_FEC              0
#define DM1_PAYLOAD        136        
#define DH1_PAYLOAD        216 
#define DM3_PAYLOAD        968 
#define DH3_PAYLOAD        1464
#define DM5_PAYLOAD        1792
#define DH5_PAYLOAD        2712


#define SLAVE_0             0
#define SLAVE_6             6

#define MASTER_TO_SLAVE     0
#define SLAVE_TO_MASTER     1

/* Define the transition macros */
#define SELF                op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code() == INIT
#define BEGSIM              op_intrpt_type() == OPC_INTRPT_BEGSIM
#define FROM_STOC_OR_APP_OR_LM    op_intrpt_type() == OPC_INTRPT_STRM &&\
	(op_intrpt_strm() == STOCHASTIC_INSTREAM || op_intrpt_strm() == APP_INSTREAM ||\
	op_intrpt_strm() == CONTROL_INSTREAM)
#define PACKET_RECEIVED     op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm() == BT_INSTREAM
#define TRANSMIT            op_intrpt_type() == OPC_INTRPT_SELF && (op_intrpt_code() == TX ||\
								op_intrpt_code() == VOICE_TX)
#define NO_VOICE            op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code() == VOICELESS
#define FROM_LM             op_intrpt_type() == OPC_INTRPT_STRM && op_intrpt_strm() == CONTROL_INSTREAM 


#define SET_AT_SLAVE       -1
#define CUSTOM              0
#define CLEAR				0
#define CONGESTED			1

#define VOICE               0
#define DATA                1

#define MIN_FREQ		2402
#define FREQ_OFFSET		   1
#define NUMBER_OF_HOPS		79	
#define	SEGMENT_SIZE		32	
#define	DELTA				16	
#define NUMBER_OF_SLOTS		134217728	/* 2^27 modulo for slots counter */
#define	TS			   		.000625		/* The TS unit is 625uS */

#define BT_TRACE_ACTIVE				(op_prg_odb_ltrace_active ("bluetooth_slave"))
#define BT_SCO_TRACE_ACTIVE			(op_prg_odb_ltrace_active ("slave_sco"))
#define BT_ACL_TRACE_ACTIVE			(op_prg_odb_ltrace_active ("acl"))
#define BT_ARQ_TRACE_ACTIVE			(op_prg_odb_ltrace_active ("arq"))
#define BT_SCHEDULER_TRACE_ACTIVE	(op_prg_odb_ltrace_active ("scheduler"))
#define BT_NOTX_TRACE_ACTIVE		(op_prg_odb_ltrace_active ("notx"))
#define BT_ADDR_TRACE_ACTIVE		(op_prg_odb_ltrace_active ("addressing"))


/* used for global tput tracking */
extern double Gb_tput[MAX_PICONETS];
extern double Gb_overhead_tput[MAX_PICONETS];
extern double Gb_fec_tput[MAX_PICONETS];

/* Global payload_errors as determined in coexist_ecc.ps.c */

/* global vars for logs */
Log_Handle config_log_handle;
Log_Handle protocol_log_handle;
int sim_log_initialized;


/* define datatypes */
typedef struct
	{
	int					slave_obj_id;
	int					tx_channel_attr_id;
	int					rx_channel_attr_id;
	}Piconet_Slave;

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		master_id                                       ;	/* Objid of my master */
	Objid	                  		my_objid                                        ;
	Sbhandle	               		Acl_seg_buf                                     ;	/* Channel condition - CLEAR or CONGESTED.       */
	                        		                                                	/* Determines FEC settings and ACL pakcet types. */
	                        		                                                	/* Pointer to masters value                      */
	                        		                                                	/*                                               */
	Sbhandle	               		Rsm_buf                                         ;
	Sbhandle	               		Sco_seg_buf                                     ;
	Sbhandle	               		Control_seg_buf                                 ;	/* control traffic SAR buffer */
	int*	                   		Channel_condition                               ;
	int	                    		Logical_channel                                 ;
	int	                    		My_piconet                                      ;
	int	                    		My_address                                      ;	/* Slave address (0-6) */
	int*	                   		Tsco                                            ;
	int	                    		SCO_con                                         ;	/* boolean; does this slave have a current SCO connection? */
	int	                    		Last_acl_pk_type                                ;	/* last transmitted ACL packet type:  DM1, DM3... */
	                        		                                                	/* used to ensure a retransmitted payload is sent */
	                        		                                                	/* in the same packet type.                       */
	int	                    		Current_slot                                    ;	/* Current time slot integer value */
	int	                    		Last_received_pk_type                           ;	/* Last received packet type.  Use by get_tx_type() to know */
	                        		                                                	/* what type of transmission is required.                   */
	int	                    		Voice_slot_mod                                  ;	/* Slot modulo when a voice packet is expected. */
	int	                    		Current_slot_mod                                ;	/* Slot counter within a Tsco period */
	int	                    		Last_pk_for_me[2]                               ;	/* 2 values - the first is the slot # when the values were set. */
	                        		                                                	/* The second is a boolean - was the last pk addressed to me?   */
	int	                    		Seqn                                            ;	/* Seqn to be sent in ACL packets */
	int	                    		Seqn_old                                        ;	/* Last received Seqn value. */
	int	                    		Retx                                            ;	/* Boolean:  does master require a retransmission? */
	int	                    		Need_to_ack                                     ;
	int	                    		Acl_slot_length                                 ;
	int	                    		Arq                                             ;
	int*	                   		Num_sco_cons                                    ;
	int	                    		Send_remote                                     ;
	int	                    		Pk_count[2]                                     ;
	double*	                		Offset                                          ;
	double	                 		Voice_source_pk_size                            ;
	Packet *	               		Retx_pkt                                        ;
	Evhandle	               		init_evh                                        ;	/* event to transition from init1 to init2 */
	Stathandle	             		Mac_packets_sent_stat                           ;
	Stathandle	             		Mac_packets_recv_stat                           ;
	Stathandle	             		Mac_pkt_lost_stat                               ;
	Stathandle	             		Sco_pkt_received_stat                           ;
	Stathandle	             		Sco_pkt_sent_stat                               ;
	Stathandle	             		Mac_throughput_stat                             ;
	Stathandle	             		Mac_fec_throughput_stat                         ;
	Stathandle	             		Gb_tput_stat                                    ;
	Stathandle	             		Poll_pkt_received_stat                          ;
	Stathandle	             		Acl_pk_received_stat                            ;
	Stathandle	             		Acl_pk_sent_stat                                ;
	Stathandle	             		Control_pk_received_stat                        ;
	Stathandle	             		Control_pk_sent_stat                            ;
	Stathandle	             		Nulls_received_stat                             ;
	Stathandle	             		Retx_stat                                       ;
	Stathandle	             		Dropped_sco_stat                                ;
	Stathandle	             		Mac_sdu_delay_stat                              ;
	Stathandle	             		Residual_sco_errors_stat                        ;
	Stathandle	             		Null_pk_sent_stat                               ;
	} bt_slave_state;

#define pr_state_ptr            		((bt_slave_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))
#define master_id               		pr_state_ptr->master_id
#define my_objid                		pr_state_ptr->my_objid
#define Acl_seg_buf             		pr_state_ptr->Acl_seg_buf
#define Rsm_buf                 		pr_state_ptr->Rsm_buf
#define Sco_seg_buf             		pr_state_ptr->Sco_seg_buf
#define Control_seg_buf         		pr_state_ptr->Control_seg_buf
#define Channel_condition       		pr_state_ptr->Channel_condition
#define Logical_channel         		pr_state_ptr->Logical_channel
#define My_piconet              		pr_state_ptr->My_piconet
#define My_address              		pr_state_ptr->My_address
#define Tsco                    		pr_state_ptr->Tsco
#define SCO_con                 		pr_state_ptr->SCO_con
#define Last_acl_pk_type        		pr_state_ptr->Last_acl_pk_type
#define Current_slot            		pr_state_ptr->Current_slot
#define Last_received_pk_type   		pr_state_ptr->Last_received_pk_type
#define Voice_slot_mod          		pr_state_ptr->Voice_slot_mod
#define Current_slot_mod        		pr_state_ptr->Current_slot_mod
#define Last_pk_for_me          		pr_state_ptr->Last_pk_for_me
#define Seqn                    		pr_state_ptr->Seqn
#define Seqn_old                		pr_state_ptr->Seqn_old
#define Retx                    		pr_state_ptr->Retx
#define Need_to_ack             		pr_state_ptr->Need_to_ack
#define Acl_slot_length         		pr_state_ptr->Acl_slot_length
#define Arq                     		pr_state_ptr->Arq
#define Num_sco_cons            		pr_state_ptr->Num_sco_cons
#define Send_remote             		pr_state_ptr->Send_remote
#define Pk_count                		pr_state_ptr->Pk_count
#define Offset                  		pr_state_ptr->Offset
#define Voice_source_pk_size    		pr_state_ptr->Voice_source_pk_size
#define Retx_pkt                		pr_state_ptr->Retx_pkt
#define init_evh                		pr_state_ptr->init_evh
#define Mac_packets_sent_stat   		pr_state_ptr->Mac_packets_sent_stat
#define Mac_packets_recv_stat   		pr_state_ptr->Mac_packets_recv_stat
#define Mac_pkt_lost_stat       		pr_state_ptr->Mac_pkt_lost_stat
#define Sco_pkt_received_stat   		pr_state_ptr->Sco_pkt_received_stat
#define Sco_pkt_sent_stat       		pr_state_ptr->Sco_pkt_sent_stat
#define Mac_throughput_stat     		pr_state_ptr->Mac_throughput_stat
#define Mac_fec_throughput_stat 		pr_state_ptr->Mac_fec_throughput_stat
#define Gb_tput_stat            		pr_state_ptr->Gb_tput_stat
#define Poll_pkt_received_stat  		pr_state_ptr->Poll_pkt_received_stat
#define Acl_pk_received_stat    		pr_state_ptr->Acl_pk_received_stat
#define Acl_pk_sent_stat        		pr_state_ptr->Acl_pk_sent_stat
#define Control_pk_received_stat		pr_state_ptr->Control_pk_received_stat
#define Control_pk_sent_stat    		pr_state_ptr->Control_pk_sent_stat
#define Nulls_received_stat     		pr_state_ptr->Nulls_received_stat
#define Retx_stat               		pr_state_ptr->Retx_stat
#define Dropped_sco_stat        		pr_state_ptr->Dropped_sco_stat
#define Mac_sdu_delay_stat      		pr_state_ptr->Mac_sdu_delay_stat
#define Residual_sco_errors_stat		pr_state_ptr->Residual_sco_errors_stat
#define Null_pk_sent_stat       		pr_state_ptr->Null_pk_sent_stat

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	bt_slave_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((bt_slave_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/**************************************************************************************************/
/* Function:		bt_sl_mac_error															  */
/* Description:	Error handling procedure													      */
/* ParamIn:		char * : fcnt																      */
/*						The function in the process     										  */
/*						where the error occured													  */
/* ParamIn:		char * : msg																      */
/*						The description of the error											  */
/* ParamIn:		char * : opt																      */
/*						An optional message														  */
/**************************************************************************************************/

void	bt_sl_mac_error (char * fcnt, char * msg, char * opt)
{
	/* Terminates simulation and print an error message. */
	FIN (bt_mst_mac_error (fcnt, msg, opt));


	op_sim_end ("Error in BlueTooth Slave MAC process: ", fcnt, msg, opt);


	FOUT;
}

/****************************************************************************************/
/* Function get_sl_tx_type                                    	                        */
/* Purpose:  Called upon entrance to "To BT Radio".                                  	*/
/*            - determines what type of transmission is needed for this slot            */
/* In:   none                    									                    */
/* Return:  tx_type, ie, NULL, SCO, ACL, ACL_RETX, CONTROL, ERROR                       */
/****************************************************************************************/

int get_sl_tx_type()
{
	int tx_type, bool_tx_acl=OPC_FALSE, done = OPC_FALSE; 
	
	FIN(get_sl_tx_type());

	tx_type = ERROR;
		

/* Was last packet received in the previous slot? */
/* Was it addressed to me? */
/* Is this a reserved voice slot? */
	/* first check if I can transmit ACL */
	if (Last_pk_for_me [0] == (Current_slot -1) && Last_pk_for_me [1] == OPC_TRUE)
		bool_tx_acl = OPC_TRUE;
	
	/* I can TX SCO if this is a reserved SCO slot and the packet received in the last slot */
	/*  was addressed to me or there was no packet received in the last slot */
	if (Current_slot_mod == Voice_slot_mod && ((Last_pk_for_me [0] ==\
		(Current_slot -1) && Last_pk_for_me [1] == OPC_TRUE) ||\
		Last_pk_for_me [0] != (Current_slot -1))) 
		{
		/* If the channel is maxed by SCO, we need to pre-empt this SCO packet with */
		/*  any retransmission or CONTROL/LM data */
		if ((*Tsco == 6 && *Num_sco_cons == 3) || (*Tsco == 4 && *Num_sco_cons == 2) || *Tsco == 2)
			{
			if (Retx)
				{
				tx_type = ACL_RETX;
				done = OPC_TRUE;
				}
			else if (!op_subq_empty (CONTROL_Q))
				{
				Logical_channel = CONTROL;
				tx_type = ACL;
				done = OPC_TRUE;
				}
			else /* nothing to pre-empt the scheduled SCO */
				{
				tx_type = SCO;
				done = OPC_TRUE;
				}
			}
		/* Channel is not full; only pre-empt the scheduled SCO for CONTROL*/
		else
			{
			if (!op_subq_empty (CONTROL_Q))
				{
				tx_type = ACL;
				Logical_channel = CONTROL;
				}
			else
				{
				tx_type = SCO;
				}
			done = OPC_TRUE;
			}
		
	
   		}
	/* The master transmitted a packet to a different slave in the previous slot */
	else if (Current_slot_mod == Voice_slot_mod && (Last_pk_for_me [0] ==\
		(Current_slot -1) && Last_pk_for_me [1] == OPC_FALSE) ) 
			{
			/* I'll need to flush my SCO buffer by one packet payload */
			tx_type = FLUSH;
			done = OPC_TRUE;
			}
	
	/* if I can send acl and I have data to send */
	if (!done && bool_tx_acl)
		{
		if (Retx)
			tx_type = ACL_RETX;
		else if (!op_subq_empty (CONTROL_Q))
			{
			tx_type = ACL;
			Logical_channel = CONTROL;
			}
		else if (op_sar_buf_size (Acl_seg_buf) > 0)
			{
			Logical_channel = DATA;
			tx_type = ACL;
			}
		/* I need to return an ack for a packet received in the previous slot */
		else if (Need_to_ack) 
			{
			tx_type = NULL_TX;
			Need_to_ack = OPC_FALSE;
			Logical_channel = DATA;
			}
		else
			tx_type = ERROR;
		}
		
		
	FRET(tx_type);
}

/****************************************************************************************/
/* Function packet_sl_select()                                   	                        */
/* Purpose:  Determines the next packet type given the next transmission type.       	*/
/*                                                                                      */
/* In:   tx_type:  POLL, SCO, ACL, CONTROL, NULL.                                       */
/* Return:  packet type for the transmission (DM1, HV1...)                              */
/****************************************************************************************/

int packet_sl_select(int tx_type)
{
	int pk_type;
	double bitcount;
	
	FIN(packet_sl_select());
	
	switch (tx_type)
		{
		case SCO:
		if (*Tsco == 6)
			pk_type = HV3;
		else if (*Tsco == 4)
			pk_type = HV2;
		else
			pk_type = HV1;
		break;
		case ACL:
			{
			/* Model limitation:  if there is any SCO traffic in a piconet, Acl slot length */
			/*  is limited to a single slot.  Check for a configuration error and default to */
			/*  single slot acl if needed */
			if (Acl_slot_length > 1 && *Num_sco_cons > 0)
				{
				op_sim_message ("Can't hardwire Slave ACL Packet length to 3 or 5 in presence of SCO", "Defaulting to single slot ACL for slaves");
				op_prg_log_entry_write (config_log_handle,"Slaves cannot use ACL packet length of 3 or 5 in the presence of SCO\n"
					"Defaulting to single slot ACL for all slaves in piconet %d ", My_piconet);
				Acl_slot_length = 1;
				}
			/* Control/LM messages are sent in DM1 packets */
			if (Logical_channel == CONTROL)
				pk_type = DM1;
			/* packet type depends on how many slots the master can use for transmissions */
			/* Packet type will be D<H|M>X depending on channel conditions */
			else if (op_sar_buf_size (Acl_seg_buf) == 0)
				pk_type = NULL_PKT;
			else if (Acl_slot_length == 1)
				pk_type = *Channel_condition == CLEAR?DH1:DM1;
			else if (Acl_slot_length == 3)
				pk_type = *Channel_condition == CLEAR?DH3:DM3;
			else if (Acl_slot_length == 5)
				pk_type = *Channel_condition == CLEAR?DH5:DM5;
			else if (Acl_slot_length == CUSTOM)
				{
				/* sample custom algorithm -- choose the smallest ACL packet type neccessary */
				/*  based on buffer size for Dest_addr                                       */
				bitcount = op_sar_buf_size (Acl_seg_buf);
				if (bitcount > (*Channel_condition == CLEAR?DH3_PAYLOAD:DM3_PAYLOAD))
					pk_type = *Channel_condition == CLEAR?DH5:DM5;
				else if (bitcount > (*Channel_condition == CLEAR?DH1_PAYLOAD:DM1_PAYLOAD))
					pk_type = *Channel_condition == CLEAR?DH3:DM3;
				else
					pk_type = *Channel_condition == CLEAR?DH1:DM1;

				}
			}
		break;
		case ACL_RETX:
		pk_type = Last_acl_pk_type;
		break;
		case NULL_TX:
		pk_type = NULL_PKT;
		}
	FRET(pk_type);
}

/****************************************************************************************/
/* Function packet_sl_create()                                   	                        */
/* Purpose:  creates the packet to be sent, inserts payload, fec and sets ARQ fields.  	*/
/*                                                                                      */
/* In:   pk_type:  HV1, DM1...   				                                        */
/* Return:  Packet pointer                                                              */
/****************************************************************************************/

Packet* packet_sl_create(int pk_type)
{

	Packet* bt_pkt, *payload_pkt, *fec_pkt;
	char* packet_type = "empty";
	int fec = OPC_FALSE, tx_type = -1, bitcount, header_plus_crc;
	double pk_size, fec_size;
	int sample_type;
	
	FIN (packet_sl_create(pk_type));
	
	switch (pk_type)
		{
		case HV1:
		packet_type = "HV1";
		pk_size = HV1_PAYLOAD;
		fec_size = HV1_FEC;
		break;
		
		case HV2:
		packet_type = "HV2";
		pk_size = HV2_PAYLOAD;
		fec_size = HV2_FEC;
		break;
		
		case HV3:
		packet_type = "HV3";
		pk_size = HV3_PAYLOAD;
		fec_size = HV3_FEC;
		break;		
		
		case DM1:
		packet_type = "DM1";
		pk_size = DM1_PAYLOAD;
		tx_type = DATA;
		fec = OPC_TRUE;
		break;
		
		case DM3:
		packet_type = "DM3";
		pk_size = DM3_PAYLOAD;
		tx_type = DATA;
		fec = OPC_TRUE;
		break;
		
		case DM5:
		packet_type = "DM5";
		pk_size = DM5_PAYLOAD;
		tx_type = DATA;
		fec = OPC_TRUE;
		break;
		
		case DH1:
		packet_type = "DH1";
		pk_size = DH1_PAYLOAD;
		tx_type = DATA;
		break;
		
		case DH3:
		packet_type = "DH3";
		pk_size = DH3_PAYLOAD;
		tx_type = DATA;
		break;
		
		case DH5:
		packet_type = "DH5";
		pk_size = DH5_PAYLOAD;
		tx_type = DATA;
		break;
		
		case POLL_PKT:
		packet_type = "POLL";
		fec_size = 0;
		
		case NULL_PKT:
		packet_type = "NULL";
		fec_size = 0;
		break;
		}
	
	bt_pkt = op_pk_create_fmt(packet_type);
	
	
	
	op_pk_nfd_set (bt_pkt, "AM_ADDR", My_address);
	op_pk_nfd_set (bt_pkt, "Way", SLAVE_TO_MASTER);
	op_pk_nfd_set (bt_pkt, "PICO_ADDR", My_piconet);
	op_pk_nfd_set (bt_pkt, "ARQ", Arq);
	op_pk_nfd_set (bt_pkt, "TYPE", pk_type);

	/* insert the payload and fec*/
	
	/* for voice packets, */
	if (pk_type == HV1 || pk_type == HV2 || pk_type == HV3)
		{
	
		if (op_sar_buf_size(Sco_seg_buf) > 0)
			{
			payload_pkt = op_sar_srcbuf_seg_remove (Sco_seg_buf, (double)pk_size);
		
			if(BT_TRACE_ACTIVE)
				{
				printf ("  packet type  : %s\n", packet_type);
				printf ("  payload size : %d\n", (int)op_pk_total_size_get (payload_pkt));
				if (strcmp(packet_type,"HV3"))
					printf ("  fec size     : %d\n\n", fec_size);
				else
					printf ("\n");

				}
		
			op_pk_nfd_set (bt_pkt, "Frame Body", payload_pkt);
			
			}
		else
			{
			op_pk_nfd_set (bt_pkt, "empty_voice_flag", OPC_TRUE);
			if(BT_TRACE_ACTIVE)
				printf ("  empty voice packet sent\n\n");
			}
		}
	else if (tx_type == DATA)
		{
		if (!Retx)
			{
			/* We're selecting a new payload; It is either CONTROL/LM data or user data */
			if (Logical_channel == CONTROL)
				{
				payload_pkt = op_subq_pk_remove (CONTROL_Q, OPC_QPOS_HEAD);
				}
			else
				{
				/* get a payload of at most what the ACL packet can contain but not more than is in the buffer */
				pk_size = op_sar_buf_size (Acl_seg_buf) >= pk_size?pk_size:op_sar_buf_size (Acl_seg_buf);
				bitcount = (int)pk_size;
				payload_pkt = op_sar_srcbuf_seg_remove (Acl_seg_buf, bitcount);
				}
			}
		/* if this is a new ACL packet, toggle the Seqn field and store a copy in the retransmission ptr */
		if (!Retx)
			{
			/* store copy of payload in retransmission packet pointer */
		    if (Retx_pkt != OPC_NIL)
				op_pk_destroy (Retx_pkt);
			Retx_pkt = op_pk_copy (payload_pkt); 
			
			Seqn = Seqn?0:1;
			if (BT_ARQ_TRACE_ACTIVE)
				 printf ("Slave %d of pico %d creating NEW ACL pkt\n", My_address, My_piconet);
			}
		/* else we're retransmitting a payload */
		else
			{
			 if (Retx_pkt != OPC_NIL)
				payload_pkt = op_pk_copy (Retx_pkt); 
			/* leave copy in retx packet pointer */
			 if (BT_ARQ_TRACE_ACTIVE)
				 printf ("Slave %d of pico %d creating Retx pkt\n", My_address, My_piconet);
			}
		/* set the Seqn packet field */
	    op_pk_nfd_set (bt_pkt, "SEQN", Seqn);

		if (Logical_channel == CONTROL)
			{
			op_stat_write (Control_pk_sent_stat, 1);
			}
		
		/* if its a medium data rate packet, create the fec packet*/
	    if (fec)
			{
			/* fec packet size must be a multiple of 10 for FEC; pad if needed */
			/* Add 16 bits of CRC and the payload header (8 bits for DM1,  */
			/* 16 bits for DM3 and DM5) for FEC size calculation           */
			header_plus_crc = pk_type == DM1?24:32;
			pk_size = op_pk_total_size_get (payload_pkt) + header_plus_crc;
			pk_size = (((int)pk_size % 10) == 0)?pk_size:((pk_size/10)*10 + 10);
			fec_size = pk_size/2;
			fec_pkt = op_pk_create (fec_size);
			op_pk_nfd_set (bt_pkt, "FEC", fec_pkt);
		
			}
		op_pk_nfd_set (bt_pkt, "Frame Body", payload_pkt);
		op_pk_nfd_set (bt_pkt, "L_CH", Logical_channel);
		}

	
	FRET(bt_pkt);
	}

/****************************************************************************************/
/* Function get_sl_pk_type()                                    	                        */
/* Purpose:  Returns the defined constant value of the packet type given it's           */
/*              string interpretation; also returns # of header bits.   	            */                              
/*                                                                                      */
/* In:   bt_pk_type.									                                */
/* Return:  Integer defined constant value of bt_pk_type as type[TYPE].                 */
/*             Returns # of overhead bits as type[OVERHEAD].                            */
/*             Returns # of slots used as type[SLOTS].                                  */
/*             Returns -1 if no packet type was found.                                  */
/****************************************************************************************/

void get_sl_pk_type(char* bt_pk_type, int* type)
{
 		
	FIN (get_sl_pk_type(char* bt_pk_type, int* type));
	
	type[TYPE] = -1;
	type[OVERHEAD] = -1;
	type[SLOTS] = -1;
	type[CON_TYPE] = -1;
	
	if (!(strcmp(bt_pk_type, "HV1")))
		{
		type[TYPE] = HV1;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON_TYPE] = SCO;
		}
	else if (!(strcmp(bt_pk_type, "HV2")))
		{
		type[TYPE] = HV2;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON_TYPE] = SCO;
		}
	else if (!(strcmp(bt_pk_type, "HV3")))
		{
		type[TYPE] = HV3;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON_TYPE] = SCO;
		}
	else if (!(strcmp(bt_pk_type, "POLL")))
		{
		type[TYPE] = POLL_PKT;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON_TYPE] = POLL;
		
		}
	else if (!(strcmp(bt_pk_type, "NULL")))
		{
		type[TYPE] = NULL_PKT;
		type[OVERHEAD] = ACCESS_CODE + HEADER;
		type[SLOTS] = 1;
		type[CON_TYPE] = NULL_TX;
		}
	else if (!(strcmp(bt_pk_type, "DM1")))
		{
		type[TYPE] = DM1;
		type[OVERHEAD] = ACCESS_CODE + HEADER + SS_PAYLOAD_HEADER;
		type[SLOTS] = 1;
		type[CON_TYPE] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DM3")))
		{
		type[TYPE] = DM3;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 3;
		type[CON_TYPE] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DM5")))
		{
		type[TYPE] = DM5;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 5;
		type[CON_TYPE] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DH1")))
		{
		type[TYPE] = DH1;
		type[OVERHEAD] = ACCESS_CODE + HEADER + SS_PAYLOAD_HEADER;
		type[SLOTS] = 1;
		type[CON_TYPE] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DH3")))
		{
		type[TYPE] = DH3;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 3;
		type[CON_TYPE] = ACL;
		}
	else if (!(strcmp(bt_pk_type, "DH5")))
		{
		type[TYPE] = DH5;
		type[OVERHEAD] = ACCESS_CODE + HEADER + MS_PAYLOAD_HEADER;
		type[SLOTS] = 5;
		type[CON_TYPE] = ACL;
		}
	
	
	FOUT;
			
	
}

	

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void bt_slave (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_bt_slave_init (int * init_block_ptr);
	void _op_bt_slave_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_bt_slave_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_bt_slave_alloc (VosT_Obtype, int);
	void _op_bt_slave_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
bt_slave (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (bt_slave ());

		{
		/* Temporary Variables */
		Packet* stoch_pkt, *pk_to_send, *bt_pkt, *payload_pkt, *up_pkt, *fec_pkt;
		Ici* stoch_ici;
		int qos, dest_addr, i;
		int tx_type, pk_type;
		int way, pico_addr, accept, empty_voice, payload_accept;
		char BT_packet_type[6];
		char* pk_name = "empty";
		double tx_time, tput_size, bitcount, fec_size, int_time;
		int pk_stats[4], num_events;
		Evhandle next_event;
		int next_slot_mod;
		int logical_channel, seqn, remove_fec, tx_slot, arq;
		int* acl_slot_length_from_master;
		Objid my_id, my_node_id;
		Prohandle own_prohandle;
		char proc_model_name[32];
		OmsT_Pr_Handle own_process_record_handle;
		int temp_address, payload_errors;
		char str0[128];
		int packet_type;
		/* End of Temporary Variables */


		FSM_ENTER ("bt_slave")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (Init) enter executives **/
			FSM_STATE_ENTER_FORCED (0, "Init", state0_enter_exec, "bt_slave [Init enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave [Init enter execs]", state0_enter_exec)
				{
				/* Obtain the address assigned to this node during auto-addressing.	*/
				if (op_ima_obj_attr_get (my_objid, "Slave Address", &My_address) == OPC_COMPCODE_FAILURE)
					{
					bt_sl_mac_error ("INIT","Unable to read slave address attribute.", OPC_NIL);
					}
				
				/* Obtain the object ID of the surrounding processor. 	*/
				my_id = op_id_self ();
												
				/* Also obtain the object ID of the surrounding node.	*/
				my_node_id = op_topo_parent (my_id);
				
				/* Write the message to the notification log.  			*/
				op_prg_log_entry_write (config_log_handle,"Objid %d: Slave %d of piconet %d initialized", my_id, My_address, My_piconet);
				
				
				/* Obtain the prohandle for this process.				*/
				own_prohandle = op_pro_self ();
									
				/*	Obtain the name of the process. It is the process model	*/
				/*	attribute on the surrounding module.					*/
				op_ima_obj_attr_get (my_id, "process model", proc_model_name);
				
				
				/*	Register the process in the model-wide registry.	*/
				own_process_record_handle = (OmsT_Pr_Handle) oms_pr_process_register 
								(my_node_id, my_id, own_prohandle, proc_model_name);
								
				/*	Register my piconet and address. 					 */
				oms_pr_attr_set (own_process_record_handle, 
								"piconet", 	OMSC_PR_NUMBER, (double)My_piconet,
								"slave address", 	OMSC_PR_NUMBER, (double)My_address,
							    "node id", OMSC_PR_OBJID, my_id,
								OPC_NIL);
				
				Tsco = op_ima_obj_svar_get (master_id, "Tsco");
				
				Offset = op_ima_obj_svar_get (master_id, "Offset");
				
				Channel_condition = op_ima_obj_svar_get (master_id, "Channel_condition");
				
				Num_sco_cons = op_ima_obj_svar_get (master_id, "Num_SCO_cons");
				
				
				/* Get pointer to master's value for slave tx slots in this piconet	*/
				/* Slave's "Acl Slot Length" must be set to "master will assign" 	*/
				/*  to be initialized by the masters set value.  Otherwise, the 	*/
				/*  slave's value will be used for initialization.              	*/
				acl_slot_length_from_master = op_ima_obj_svar_get (master_id, "Slave_tx_slots");
				op_ima_obj_attr_get (my_objid, "ACL Slot Length", &Acl_slot_length);
				
				
				if (Acl_slot_length == -1)
					Acl_slot_length = *acl_slot_length_from_master;
				/* else get it from my local setting.  If local setting is not valid, 	*/
				/* default to 1 slot 													*/
				else
					{
					if (Acl_slot_length == -1)
						{
						Acl_slot_length = 1;
						op_sim_message ("Slave 'Acl Slot Length' configuration error", "Using default of 1 slot"); 
						op_prg_log_entry_write (config_log_handle,"ACL Slot Length not set for Slave %d of piconet %d\n"
							"Defaulting to single slot ACL", My_address, My_piconet);
						}
					}
				/* Register statistic handles. */
					Mac_packets_sent_stat	  = op_stat_reg("baseband.Packets sent (pkt)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_packets_recv_stat	  = op_stat_reg("baseband.Packets received (pkt)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_pkt_lost_stat		  = op_stat_reg("baseband.Packet Loss", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Sco_pkt_received_stat     = op_stat_reg("baseband.SCO Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Sco_pkt_sent_stat         = op_stat_reg("baseband.SCO Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_throughput_stat       = op_stat_reg("baseband.Throughput (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_fec_throughput_stat   = op_stat_reg("baseband.FEC Throughput (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Poll_pkt_received_stat    = op_stat_reg("baseband.Poll Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Acl_pk_received_stat      = op_stat_reg("baseband.ACL Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Acl_pk_sent_stat          = op_stat_reg("baseband.ACL Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Control_pk_received_stat  = op_stat_reg("baseband.Control Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Control_pk_sent_stat      = op_stat_reg("baseband.Control Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Null_pk_sent_stat         = op_stat_reg("baseband.Null Packets Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Nulls_received_stat       = op_stat_reg("baseband.Null Packets Received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Retx_stat                 = op_stat_reg("baseband.Retransmissions", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Dropped_sco_stat          = op_stat_reg("baseband.Dropped SCO Packets", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Mac_sdu_delay_stat        = op_stat_reg("baseband.MAC SDU Delay", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					Residual_sco_errors_stat  = op_stat_reg("baseband.Residual SCO Payload Errors", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
					
					Gb_tput_stat              = op_stat_reg("Bluetooth Slave Throughput.Slave Throughput (bits/sec)", My_piconet, OPC_STAT_GLOBAL);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (Init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "Init", "bt_slave [Init exit execs]")


			/** state (Init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Init", "Slave Wait", "tr_0", "bt_slave [Init -> Slave Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (Slave Wait) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "Slave Wait", state1_enter_exec, "bt_slave [Slave Wait enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave [Slave Wait enter execs]", state1_enter_exec)
				{
				printf("Entered %d\n",My_address);
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"bt_slave")


			/** state (Slave Wait) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "Slave Wait", "bt_slave [Slave Wait exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave [Slave Wait exit execs]", state1_exit_exec)
				{
				Current_slot = (int)(floor((op_sim_time() + .000001 - *Offset) / .000625));
				Current_slot_mod = Current_slot % *Tsco;
				printf("enetred %d\n",My_address);
				
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (Slave Wait) transition processing **/
			FSM_PROFILE_SECTION_IN ("bt_slave [Slave Wait trans conditions]", state1_trans_conds)
			FSM_INIT_COND (FROM_STOC_OR_APP_OR_LM)
			FSM_TEST_COND (TRANSMIT)
			FSM_TEST_COND (PACKET_RECEIVED)
			FSM_TEST_LOGIC ("Slave Wait")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "FROM_STOC_OR_APP_OR_LM", "", "Slave Wait", "From Stochastic", "tr_3", "bt_slave [Slave Wait -> From Stochastic : FROM_STOC_OR_APP_OR_LM / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, ;, "TRANSMIT", "", "Slave Wait", "To BT Radio", "tr_7", "bt_slave [Slave Wait -> To BT Radio : TRANSMIT / ]")
				FSM_CASE_TRANSIT (2, 3, state3_enter_exec, ;, "PACKET_RECEIVED", "", "Slave Wait", "From BT Radio", "tr_9", "bt_slave [Slave Wait -> From BT Radio : PACKET_RECEIVED / ]")
				}
				/*---------------------------------------------------------*/



			/** state (From Stochastic) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "From Stochastic", state2_enter_exec, "bt_slave [From Stochastic enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave [From Stochastic enter execs]", state2_enter_exec)
				{
				stoch_pkt = op_pk_get(op_intrpt_strm());
				stoch_ici = op_ev_ici(op_ev_current());
				
				
				op_pk_stamp (stoch_pkt);
				
				op_ici_attr_get (stoch_ici, "QOS", &qos);
				
				if (qos == VOICE)
					{
					Voice_source_pk_size = op_pk_total_size_get (stoch_pkt);
					op_sar_segbuf_pk_insert (Sco_seg_buf, stoch_pkt, 0);
					}
				else if (qos == DATA)
					{
					op_sar_segbuf_pk_insert (Acl_seg_buf, stoch_pkt, 0);
					
					}
				else if (qos == CONTROL)
					{
					op_subq_pk_insert (CONTROL_Q, stoch_pkt, OPC_QPOS_TAIL);
					
					}
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (From Stochastic) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "From Stochastic", "bt_slave [From Stochastic exit execs]")


			/** state (From Stochastic) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "From Stochastic", "Slave Wait", "tr_4", "bt_slave [From Stochastic -> Slave Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (From BT Radio) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "From BT Radio", state3_enter_exec, "bt_slave [From BT Radio enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave [From BT Radio enter execs]", state3_enter_exec)
				{
				printf("From BT Radio\n");
				/* get BT packet */
				bt_pkt = op_pk_get (BT_INSTREAM);
				
				op_pk_nfd_get (bt_pkt, "Way", &way);
				op_pk_nfd_get (bt_pkt, "PICO_ADDR", &pico_addr);
				op_pk_nfd_get (bt_pkt, "Accept", &accept);
				op_pk_nfd_get (bt_pkt, "AM_ADDR", &dest_addr);
				op_pk_nfd_get (bt_pkt, "TYPE", &packet_type);
				//op_pk_format  (bt_pkt, BT_packet_type);
				printf("Received packet from master %d\n", packet_type);
				
				
				if(packet_type == 0)
					strcpy(BT_packet_type,"NULL");
				
				else if(packet_type == 1)
					strcpy(BT_packet_type,"HV1");	
				
				else if(packet_type == 2)
					strcpy(BT_packet_type,"HV2");
				
				else if(packet_type == 3)
					strcpy(BT_packet_type,"HV3");
				
				else if(packet_type == 4)
					strcpy(BT_packet_type,"DM1");
				
				else if(packet_type == 5)
					strcpy(BT_packet_type,"DM3");
				
				else if(packet_type == 6)
					strcpy(BT_packet_type,"DM5");
				
				else if(packet_type == 7)
					strcpy(BT_packet_type,"DH1");
				
				else if(packet_type == 8)
					strcpy(BT_packet_type,"DH3");
				
				else if(packet_type == 9)
					strcpy(BT_packet_type,"DH5");
				
				else if(packet_type == 10)
					strcpy(BT_packet_type,"POLL");
				
				
				
				/**************************************************/
				/* Custom packet whacker to test retransmissions  */
				/* Remove comments to use, it sets the accept flag*/
				/*  to false in 2 consecutive received BT packets */
				/*  every 30 packets.                             */
				/**************************************************/
				
				/*if (++Pk_count[0] % 30 == 0)
					 {
					 accept = OPC_FALSE;
					 if(--Pk_count[1]>0)
						 Pk_count[0]--;
					 else
						 Pk_count[1] = 2;
					 }*/
				
				get_sl_pk_type(BT_packet_type, pk_stats);
				/* my master tells me the slot # on which to transmit */
				op_pk_nfd_get (bt_pkt, "Access Code", &tx_slot);
				//printf("Master told me to Tx in slot %d\n", tx_slot);
				
				payload_accept = OPC_FALSE;
				remove_fec = OPC_FALSE;
				Send_remote = OPC_FALSE;
				
				
				/* the BT packet is for me; process it */
				if (way == MASTER_TO_SLAVE && pico_addr == My_piconet && dest_addr == My_address)
					{
					/* These SV's let us know if we can transmit on the next slot in the case that */
					/* the next slot is a reserved SCO but this packet wasn't accepted.            */
					
					/* remember which slot this value is for */
					/* If tx_slot is greater than 0, this is an ACL packet and we must set */
					/*  this value to correspond to the slot before the return slave slot */
					if (tx_slot > 0)
						Last_pk_for_me [0] = tx_slot -1;
					/* otherwise this is a one slot poll, null, control, or sco packet */
					else
						Last_pk_for_me [0] = Current_slot;
				
					/* remember that this packet was sent to my address */
					Last_pk_for_me [1] = OPC_TRUE;
				
						
					if (accept)
						{
						
						op_pk_nfd_get (bt_pkt, "ARQ", &arq);
						
						if (arq)
							Retx = OPC_FALSE;
						/* get the slot modulo for the next timeslot */
						next_slot_mod = (Current_slot + 1) % *Tsco;
						Last_received_pk_type = pk_stats[TYPE];
						Gb_overhead_tput[My_piconet] += pk_stats[1];
						op_stat_write (Mac_packets_recv_stat, 1);
						if (pk_stats[TYPE] == POLL_PKT)
							op_stat_write (Poll_pkt_received_stat, 1);
				
						
						/* If its a voice packet */
						if (pk_stats[CON_TYPE] == SCO)
							{
							/* we received the first voice packet, remember which slot we expect it */
							/* Schedule the first SCO transmit interrupt for the new voice connection */
							if (Voice_slot_mod < 0)
								{
								Voice_slot_mod = next_slot_mod;
								int_time = (Current_slot + 1) * TS + *Offset;
								if (BT_SCO_TRACE_ACTIVE)
									{
									printf ("Slave %d of pico [%d]: first voice slot scheduled for slot %d at time %6f\n", My_address, My_piconet, Current_slot +1, int_time);
									
									}
								op_intrpt_schedule_self (int_time, VOICE_TX);
								}
							
								op_stat_write (Sco_pkt_received_stat, 1);
								 /* if the empty voice field is set, the packet doesn't contain any data */	
								op_pk_nfd_get(bt_pkt, "empty_voice_flag", &empty_voice);
								if (empty_voice)
									{
									payload_accept = OPC_FALSE;
									}
								else
									{
									payload_accept = OPC_TRUE;
									printf("Payload accept: %d\n", payload_accept);
										
									}
								
									/* LTRACE for SCO traffic */
								if (BT_SCO_TRACE_ACTIVE)
									{
									if (pk_stats[TYPE] == HV1)
										pk_name = "HV1";
									else if (pk_stats[TYPE] == HV2)
										pk_name = "HV2";
									else if (pk_stats[TYPE] == HV3)
										pk_name = "HV3";
									else
										pk_name = "error";
							
									printf ("Slave %d received %s at time %.8f, slot modulo is %d\n", My_address, pk_name, op_sim_time(), Current_slot % *Tsco);
									}
				
								
				
				
							} /* end voice pkt */
						/* If its an ACL packet */
						else if (pk_stats[CON_TYPE] == ACL)
							{
				
							op_pk_nfd_get (bt_pkt, "L_CH", &logical_channel);
							/* If this is a normal ACL or ACL_RETX packet */
							op_pk_nfd_get (bt_pkt, "SEQN", &seqn);
							if (BT_ARQ_TRACE_ACTIVE)
								printf ("Slave received ACL, Seqn is %d, Seqn_old is %d\n", seqn, Seqn_old);
				
				
							Send_remote = OPC_TRUE;
							Arq = OPC_TRUE;
							Need_to_ack = OPC_TRUE;
							op_stat_write (Acl_pk_received_stat, 1);
				
				
							/* if this payload is new to me */
							if (Seqn_old != seqn)
								{
								if (BT_ARQ_TRACE_ACTIVE)
									printf ("Payload accepted\n");
								payload_accept = OPC_TRUE;
								/* Only medium data rate packets contain FEC */
								if(pk_stats[TYPE] == DM1 || pk_stats[TYPE] == DM3 || pk_stats[TYPE] == DM5)
									remove_fec    = OPC_TRUE;
								Seqn_old = seqn;
								}
							else if (BT_ARQ_TRACE_ACTIVE)
								printf ("Payload NOT accepted\n");
				
							} /* end ACL packet */
						else if (pk_stats[CON_TYPE] == NULL_TX || pk_stats[CON_TYPE] == POLL)
							{
							if (pk_stats[CON_TYPE] == POLL)
								{
								Need_to_ack = OPC_TRUE;
								}
							else
								{
								op_stat_write (Nulls_received_stat, 1);
								Need_to_ack = OPC_FALSE;
								}
							Send_remote = OPC_TRUE;
				
							}
				
						if (payload_accept)
						   {
							op_pk_nfd_get (bt_pkt, "Frame Body", &payload_pkt);
							tput_size = op_pk_total_size_get (payload_pkt);
							if (pk_stats[CON_TYPE] == SCO)
								{
								op_pk_nfd_get (bt_pkt, "Errors", &payload_errors);
								tput_size -= (double)(payload_errors);
								op_stat_write (Residual_sco_errors_stat, payload_errors); 
								}
				
							op_stat_write (Mac_throughput_stat, tput_size);
							op_stat_write (Gb_tput_stat, tput_size);
							Gb_tput[My_piconet] += tput_size;
							if(!(strcmp(BT_packet_type,"HV1")))
								{
								op_stat_write (Mac_fec_throughput_stat, HV1_FEC);
								Gb_fec_tput[My_piconet] += HV1_FEC;
								}
							else if(!(strcmp(BT_packet_type,"HV2")))
								{
								op_stat_write (Mac_fec_throughput_stat, HV2_FEC);
								Gb_fec_tput[My_piconet] += HV2_FEC;
								}
							/* ACL packets can have varying numbers of FEC bits.  Get the size of the FEC packet */
							/* sent and add it to the stat */
							else if (remove_fec)
								{
								op_pk_nfd_get (bt_pkt, "FEC", &fec_pkt);
								fec_size = op_pk_total_size_get (fec_pkt);
								op_pk_destroy (fec_pkt);
								
								op_stat_write (Mac_fec_throughput_stat, fec_size);
								Gb_fec_tput[My_piconet] += fec_size;
								}
							/* CONTROL packets aren't SAR'd; send directly to the link manager */
							if (logical_channel == CONTROL)
								{
								op_stat_write (Control_pk_received_stat, 1);
							    op_stat_write (Mac_sdu_delay_stat, op_sim_time() - op_pk_stamp_time_get (payload_pkt));
								op_pk_send (payload_pkt, CONTROL_OUTSTREAM);
								}
							else /* Logical channel is user data */
								{
								op_sar_rsmbuf_seg_insert (Rsm_buf, payload_pkt);		
								/* get all completed packets from the Rsm buf and send to the sink */
								while (op_sar_rsmbuf_pk_count (Rsm_buf) > 0)
									{
									up_pkt = op_sar_rsmbuf_pk_remove (Rsm_buf);
									op_pk_format(up_pkt, BT_packet_type);
									op_stat_write (Mac_sdu_delay_stat, op_sim_time() - op_pk_stamp_time_get (up_pkt));
									if (strcmp(BT_packet_type, "ip_dgram_v4") == 0)
										{
										op_pk_send (up_pkt, APP_OUTSTREAM);
										}
									else
										op_pk_send (up_pkt, STOCHASTIC_OUTSTREAM);
									}
								}
							} /* end payload_accept */
				
							
						/* Set next tx interrupt if its not a voice packet and I have something to say. */
						/* Voice interrupts are scheduled from Transmit SCO*/
						//printf("%d checking next tx...", My_address);
						if (next_slot_mod != Voice_slot_mod && (Need_to_ack || Retx || op_sar_buf_size (Acl_seg_buf) > 0 || Send_remote))
							{
							tx_time = (tx_slot) * SLOT_TIME + *Offset;
							if (BT_SCHEDULER_TRACE_ACTIVE)
								printf ("slave else tx slot scheduled for %d\n", tx_slot);
							op_intrpt_schedule_self (tx_time, TX);
							}
							
						} /* end accept */
					else /* packet was for me but received unrecoverable errors in the pipeline */
						{
						if (pk_stats[CON_TYPE] == ACL)
							Arq = NAK;
						op_stat_write (Mac_pkt_lost_stat, 1);
						}
					
					} /* end this packet is for me */
				else if (way == MASTER_TO_SLAVE && pico_addr == My_piconet && dest_addr != My_address)
					{
					/* This packet is not addressed to me, but to someone else in this piconet */
					/* This tells us that we cannot transmit in the next slot under any circumstance as per the BT spec */
					/* If tx_slot is greater than 0, this is an ACL packet and we must set */
					/*  this value to correspond to the slot before the return slave slot */
					if (tx_slot > 0)
						Last_pk_for_me [0] = tx_slot -1;
					/* otherwise this is a one slot poll, null, control, or sco packet */
					else
						Last_pk_for_me [0] = Current_slot;
					Last_pk_for_me [1] = OPC_FALSE;
					}
				op_pk_destroy (bt_pkt);
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (From BT Radio) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "From BT Radio", "bt_slave [From BT Radio exit execs]")


			/** state (From BT Radio) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "From BT Radio", "Slave Wait", "tr_10", "bt_slave [From BT Radio -> Slave Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (To BT Radio) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "To BT Radio", state4_enter_exec, "bt_slave [To BT Radio enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave [To BT Radio enter execs]", state4_enter_exec)
				{
				printf("Entered To Bt radio\n");
				tx_type = get_sl_tx_type();
				printf("Current slot mode slave To BT Radio: %d\n", Current_slot_mod);
				if(Current_slot_mod % 2 == 0)
					printf ("Slave %d sending in M to S slot %d , mod %d\n", My_address, Current_slot, Current_slot_mod);
				
				if (Send_remote && tx_type == ERROR)
					{
					/* send remote interrupt to master so it can cancel the no response event */
					/* send as the code the next slot in which the master may transmit */
					if (BT_ACL_TRACE_ACTIVE)
						printf("slave sending remote interrupt for SINGLE SLOT\n");
					   
					op_intrpt_force_remote (NO_TX, master_id);
					Send_remote = OPC_FALSE;
					}
				   
				
				if (tx_type != ERROR && tx_type != FLUSH)
					{
				
					pk_type = packet_sl_select(tx_type);
				
					pk_to_send  =  packet_sl_create(pk_type);
					printf("Packet sent from slave of %d type\n", pk_type);
					
					op_pk_format (pk_to_send, BT_packet_type);
				
					get_sl_pk_type(BT_packet_type, pk_stats);
				
					op_pk_send (pk_to_send, BT_OUTSTREAM);
				
				
					op_stat_write (Mac_packets_sent_stat, 1);
				
				
					if (Send_remote)
						{
						/* send remote interrupt to master so it can cancel the no response event */
						/* send as the code the next slot in which the master may transmit */
						if (BT_ACL_TRACE_ACTIVE)
							printf("slave sending remote interrupt for %d slots\n", pk_stats[SLOTS]);
					   
						op_intrpt_force_remote (pk_stats[SLOTS], master_id);
						Send_remote = OPC_FALSE;
						}
				
					if (tx_type == ACL)
						op_stat_write (Acl_pk_sent_stat, 1);
					if (tx_type == ACL_RETX)
						{
						op_stat_write (Retx_stat, 1);
						op_stat_write (Acl_pk_sent_stat, 1);
						}
					
					if (pk_stats[CON_TYPE] == NULL_TX)
						op_stat_write (Null_pk_sent_stat, 1);
					
				
					if (tx_type == ACL || tx_type == ACL_RETX)
						{
						Last_acl_pk_type = pk_type;
						Retx = OPC_TRUE;
						}
					
					if (tx_type == SCO)
						{
						op_stat_write (Sco_pkt_sent_stat, 1);
				
						}
				
					/* LTRACE for SCO traffic */
					/*if (BT_SCO_TRACE_ACTIVE && (pk_type == HV1 || pk_type == HV2 || pk_type == HV3))
						{
						printf ("Slave sent %s from TX at time %.8f, slot modulo %d, slot %d\n", BT_packet_type, op_sim_time(), Current_slot % *Tsco, Current_slot);
						}
					if ((pk_stats[CON_TYPE] == ACL || pk_stats[CON_TYPE] == NULL_TX) && (BT_ACL_TRACE_ACTIVE || BT_ARQ_TRACE_ACTIVE))
						{
					   	printf ("Slave %d of pico[%d] sent %s at time %.8f , currrent slot %d\n\n", My_address, My_piconet, BT_packet_type, op_sim_time(), Current_slot);
						}
					*/
					
					if ( (pk_type == HV1 || pk_type == HV2 || pk_type == HV3))
						{
						printf ("Slave sent %s from TX at time %.8f, slot modulo %d, slot %d\n", BT_packet_type, op_sim_time(), Current_slot % *Tsco, Current_slot);
						}
					if ((pk_stats[CON_TYPE] == ACL || pk_stats[CON_TYPE] == NULL_TX) )
						{
					   	printf ("Slave %d of pico[%d] sent %s at time %.8f , currrent slot %d\n\n", My_address, My_piconet, BT_packet_type, op_sim_time(), Current_slot);
						}
				
					} 
				else 
					printf ("No TX by slave %d - pico %d on slot %d\n\n", My_address, My_piconet, Current_slot); 
				
				/* If this is a scheduled voice slot */
				if (op_intrpt_code() == VOICE_TX)
					{
					/* This is an SCO slot, schedule the next SCO interrupt */
					op_intrpt_schedule_self (op_sim_time() + *Tsco*TS, VOICE_TX);
					/* tx_type can be "FLUSH" if this SCO TX was pre-empted */
					if (tx_type != ERROR && tx_type != SCO)
						{
						/* The scheduled SCO transmission was pre-empted */
						/* Flush the scheduled SCO payload from the buffer */
						op_stat_write (Dropped_sco_stat, 1);
				
						/* flush an SCO of bitcount at most what can fit into an */
						if (op_sar_buf_size (Sco_seg_buf) >= Voice_source_pk_size && Voice_source_pk_size > 0)
							{
							bitcount = Voice_source_pk_size > (*Tsco * 5 * 8)?(*Tsco * 5 * 8):Voice_source_pk_size;
							op_sar_srcbuf_bits_flush (Sco_seg_buf, 0, bitcount);
							}
				
						}
					}
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (To BT Radio) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "To BT Radio", "bt_slave [To BT Radio exit execs]")


			/** state (To BT Radio) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "To BT Radio", "Slave Wait", "tr_8", "bt_slave [To BT Radio -> Slave Wait : default / ]")
				/*---------------------------------------------------------*/



			/** state (Init Wait) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (5, "Init Wait", "bt_slave [Init Wait enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave [Init Wait enter execs]", state5_enter_exec)
				{
				/* Get my object id and the piconet I belong to. */
				
				my_objid = op_id_self ();
				op_ima_obj_attr_get (my_objid, "Piconet Address", &My_piconet);
				
				Voice_slot_mod                = -1;
				Voice_source_pk_size          = 0;
				Last_pk_for_me[0]             = -1;
				Last_pk_for_me[1]             = OPC_FALSE;
				Send_remote                   = OPC_TRUE;
				Pk_count [0]                  = 31;
				Pk_count [1]                  = 2;
				Retx_pkt                      = OPC_NIL;
				
				
				/* create the segmentation and reassembly buffers */
				Acl_seg_buf = op_sar_buf_create(OPC_SAR_BUF_TYPE_SEGMENT, OPC_SAR_BUF_OPT_DEFAULT);
				
				Rsm_buf = op_sar_buf_create(OPC_SAR_BUF_TYPE_REASSEMBLY, OPC_SAR_BUF_OPT_DEFAULT);
				
				Sco_seg_buf = op_sar_buf_create(OPC_SAR_BUF_TYPE_SEGMENT, OPC_SAR_BUF_OPT_SEG_PAD);
				
				Control_seg_buf = op_sar_buf_create(OPC_SAR_BUF_TYPE_SEGMENT, OPC_SAR_BUF_OPT_DEFAULT);
				
				/* initialize state variables */
				Seqn            = 0;
				Seqn_old        = 0;
				Need_to_ack     = OPC_FALSE;
				Retx            = OPC_FALSE;
				Arq             = NAK;
				
				if (BT_ADDR_TRACE_ACTIVE)
					op_sim_message("Initialization paused for address assignment by master","");
						
				/* set a self-interrupt to be sure the master has time to set 	*/
				/* the slave addresses 											*/
				
				init_evh = op_intrpt_schedule_self (op_sim_time () + .003, INIT);
				
				if (sim_log_initialized == OPC_FALSE)
					{
					/* Set flag to prevent re-initialization.*/
					sim_log_initialized = OPC_TRUE;
				
					/* Configuration related notification handles.*/
					config_log_handle = op_prg_log_handle_create (OpC_Log_Category_Configuration,"Bluetooth", "Setup", 30);
					protocol_log_handle = op_prg_log_handle_create (OpC_Log_Category_Protocol,"Bluetooth", "Operation", 5);
					}
				
				temp_address = -10;
				
				if (op_ima_obj_attr_get (my_objid, "Slave Address", &temp_address) == OPC_COMPCODE_FAILURE)
					{
					bt_sl_mac_error ("Init Wait","Unable to read slave address attribute.", OPC_NIL);
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (11,"bt_slave")


			/** state (Init Wait) exit executives **/
			FSM_STATE_EXIT_UNFORCED (5, "Init Wait", "bt_slave [Init Wait exit execs]")


			/** state (Init Wait) transition processing **/
			FSM_TRANSIT_ONLY ((SELF), 0, state0_enter_exec, ;, Init Wait, "SELF", "", "Init Wait", "Init", "tr_12", "bt_slave [Init Wait -> Init : SELF / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (5,"bt_slave")
		}
	}




void
_op_bt_slave_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_bt_slave_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_bt_slave_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (pr_state_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_bt_slave_svar function. */
#undef master_id
#undef my_objid
#undef Acl_seg_buf
#undef Rsm_buf
#undef Sco_seg_buf
#undef Control_seg_buf
#undef Channel_condition
#undef Logical_channel
#undef My_piconet
#undef My_address
#undef Tsco
#undef SCO_con
#undef Last_acl_pk_type
#undef Current_slot
#undef Last_received_pk_type
#undef Voice_slot_mod
#undef Current_slot_mod
#undef Last_pk_for_me
#undef Seqn
#undef Seqn_old
#undef Retx
#undef Need_to_ack
#undef Acl_slot_length
#undef Arq
#undef Num_sco_cons
#undef Send_remote
#undef Pk_count
#undef Offset
#undef Voice_source_pk_size
#undef Retx_pkt
#undef init_evh
#undef Mac_packets_sent_stat
#undef Mac_packets_recv_stat
#undef Mac_pkt_lost_stat
#undef Sco_pkt_received_stat
#undef Sco_pkt_sent_stat
#undef Mac_throughput_stat
#undef Mac_fec_throughput_stat
#undef Gb_tput_stat
#undef Poll_pkt_received_stat
#undef Acl_pk_received_stat
#undef Acl_pk_sent_stat
#undef Control_pk_received_stat
#undef Control_pk_sent_stat
#undef Nulls_received_stat
#undef Retx_stat
#undef Dropped_sco_stat
#undef Mac_sdu_delay_stat
#undef Residual_sco_errors_stat
#undef Null_pk_sent_stat

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_bt_slave_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_bt_slave_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (bt_slave)",
		sizeof (bt_slave_state));
	*init_block_ptr = 10;

	FRET (obtype)
	}

VosT_Address
_op_bt_slave_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	bt_slave_state * ptr;
	FIN_MT (_op_bt_slave_alloc (obtype))

	ptr = (bt_slave_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "bt_slave [Init Wait enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_bt_slave_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	bt_slave_state		*prs_ptr;

	FIN_MT (_op_bt_slave_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (bt_slave_state *)gen_ptr;

	if (strcmp ("master_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->master_id);
		FOUT
		}
	if (strcmp ("my_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_objid);
		FOUT
		}
	if (strcmp ("Acl_seg_buf" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acl_seg_buf);
		FOUT
		}
	if (strcmp ("Rsm_buf" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Rsm_buf);
		FOUT
		}
	if (strcmp ("Sco_seg_buf" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Sco_seg_buf);
		FOUT
		}
	if (strcmp ("Control_seg_buf" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_seg_buf);
		FOUT
		}
	if (strcmp ("Channel_condition" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Channel_condition);
		FOUT
		}
	if (strcmp ("Logical_channel" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Logical_channel);
		FOUT
		}
	if (strcmp ("My_piconet" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->My_piconet);
		FOUT
		}
	if (strcmp ("My_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->My_address);
		FOUT
		}
	if (strcmp ("Tsco" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Tsco);
		FOUT
		}
	if (strcmp ("SCO_con" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->SCO_con);
		FOUT
		}
	if (strcmp ("Last_acl_pk_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Last_acl_pk_type);
		FOUT
		}
	if (strcmp ("Current_slot" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Current_slot);
		FOUT
		}
	if (strcmp ("Last_received_pk_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Last_received_pk_type);
		FOUT
		}
	if (strcmp ("Voice_slot_mod" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Voice_slot_mod);
		FOUT
		}
	if (strcmp ("Current_slot_mod" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Current_slot_mod);
		FOUT
		}
	if (strcmp ("Last_pk_for_me" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Last_pk_for_me);
		FOUT
		}
	if (strcmp ("Seqn" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Seqn);
		FOUT
		}
	if (strcmp ("Seqn_old" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Seqn_old);
		FOUT
		}
	if (strcmp ("Retx" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Retx);
		FOUT
		}
	if (strcmp ("Need_to_ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Need_to_ack);
		FOUT
		}
	if (strcmp ("Acl_slot_length" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acl_slot_length);
		FOUT
		}
	if (strcmp ("Arq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Arq);
		FOUT
		}
	if (strcmp ("Num_sco_cons" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Num_sco_cons);
		FOUT
		}
	if (strcmp ("Send_remote" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Send_remote);
		FOUT
		}
	if (strcmp ("Pk_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->Pk_count);
		FOUT
		}
	if (strcmp ("Offset" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Offset);
		FOUT
		}
	if (strcmp ("Voice_source_pk_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Voice_source_pk_size);
		FOUT
		}
	if (strcmp ("Retx_pkt" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Retx_pkt);
		FOUT
		}
	if (strcmp ("init_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->init_evh);
		FOUT
		}
	if (strcmp ("Mac_packets_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_packets_sent_stat);
		FOUT
		}
	if (strcmp ("Mac_packets_recv_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_packets_recv_stat);
		FOUT
		}
	if (strcmp ("Mac_pkt_lost_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_pkt_lost_stat);
		FOUT
		}
	if (strcmp ("Sco_pkt_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Sco_pkt_received_stat);
		FOUT
		}
	if (strcmp ("Sco_pkt_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Sco_pkt_sent_stat);
		FOUT
		}
	if (strcmp ("Mac_throughput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_throughput_stat);
		FOUT
		}
	if (strcmp ("Mac_fec_throughput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_fec_throughput_stat);
		FOUT
		}
	if (strcmp ("Gb_tput_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Gb_tput_stat);
		FOUT
		}
	if (strcmp ("Poll_pkt_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Poll_pkt_received_stat);
		FOUT
		}
	if (strcmp ("Acl_pk_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acl_pk_received_stat);
		FOUT
		}
	if (strcmp ("Acl_pk_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acl_pk_sent_stat);
		FOUT
		}
	if (strcmp ("Control_pk_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_pk_received_stat);
		FOUT
		}
	if (strcmp ("Control_pk_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Control_pk_sent_stat);
		FOUT
		}
	if (strcmp ("Nulls_received_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Nulls_received_stat);
		FOUT
		}
	if (strcmp ("Retx_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Retx_stat);
		FOUT
		}
	if (strcmp ("Dropped_sco_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Dropped_sco_stat);
		FOUT
		}
	if (strcmp ("Mac_sdu_delay_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_sdu_delay_stat);
		FOUT
		}
	if (strcmp ("Residual_sco_errors_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Residual_sco_errors_stat);
		FOUT
		}
	if (strcmp ("Null_pk_sent_stat" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Null_pk_sent_stat);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

