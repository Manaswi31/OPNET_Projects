/* Process model C form file: bt_master_arp.pr.c */
/* Portions of this file copyright 2014 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from bt_master_arp.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char bt_master_arp_pr_c [] = "MIL_3_Tfile_Hdr_ 1800 30A op_runsim_dev 7 55594754 55594754 1 volta chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 468d 2                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/***********************************************/
// The SuiteTooth model set was developed by
// HIGHLAND SYSTEMS, INC.
//
// It incorporates code available in the public
// domain and other code that is the property of
// OPNET Technologies, Inc.
//
// Inquiries may be addressed to:
// 
// Highland Systems, Inc.
// (703) 312 0830
// info@highsys.com
// www.highsys.com
/***********************************************/

#include <nato.h>
#include <oms_pr.h>
#include <oms_tan.h>
#include <ip_addr_v4.h>
#include <ip_rte_v4.h>
#include <ip_dgram_sup.h>


typedef struct
	{
	IpT_Address ip_addr;
	int slave_addr;
	} arp_entry;


/*	Define a transition condition corresponding 	*/
/*	to the IP datagram arrival.						*/
#define IP_ARRIVAL	(intrpt_type == OPC_INTRPT_STRM && intrpt_strm == 0)

/*	Define a transition condition corresponding 	*/
/*	to a packet arrival from the data link layer.	*/
#define DLL_ARRIVAL	(intrpt_type == OPC_INTRPT_STRM && intrpt_strm == 1)

/*	Define constants for debugging/ltrace information*/
#define ARPC_LTRACE_DATA_ACTIVE		(op_prg_odb_ltrace_active ("arp"))
#define	SELF_NOTIF		 		intrpt_type == OPC_INTRPT_SELF

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		my_id                                           ;	/* Variable for storing objid of the surrounding	 */
	                        		                                                	/* ARP processor, and the surr. node objid.		     */
	Objid	                  		my_node_id                                      ;
	char	                   		proc_model_name [32]                            ;	/* Variables used in registering the process in OMS	 */
	                        		                                                	/* Process Registry.								                         */
	Prohandle	              		own_prohandle                                   ;
	OmsT_Pr_Handle	         		own_process_record_handle                       ;
	char	                   		pid_string [512]                                ;	/* State variables for use while tracing/debugging	 */
	Objid	                  		my_pro_id                                       ;
	List*	                  		arp_list                                        ;
	} bt_master_arp_state;

#define pr_state_ptr            		((bt_master_arp_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))
#define my_id                   		pr_state_ptr->my_id
#define my_node_id              		pr_state_ptr->my_node_id
#define proc_model_name         		pr_state_ptr->proc_model_name
#define own_prohandle           		pr_state_ptr->own_prohandle
#define own_process_record_handle		pr_state_ptr->own_process_record_handle
#define pid_string              		pr_state_ptr->pid_string
#define my_pro_id               		pr_state_ptr->my_pro_id
#define arp_list                		pr_state_ptr->arp_list

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	bt_master_arp_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((bt_master_arp_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

static void
ip_arp_error (const char *msg)
	{
	FIN (ip_arp_error (msg));

	op_sim_end ("Error in IP ARP process model (ip_arp_v4):",
		msg, OPC_NIL, OPC_NIL);

	FOUT;
	}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void bt_master_arp (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_bt_master_arp_init (int * init_block_ptr);
	void _op_bt_master_arp_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_bt_master_arp_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_bt_master_arp_alloc (VosT_Obtype, int);
	void _op_bt_master_arp_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
bt_master_arp (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (bt_master_arp ());

		{
		/* Temporary Variables */
		int					intrpt_type = OPC_INT_UNDEF;
		int					intrpt_strm = OPC_INT_UNDEF;
		Packet*				pkptr;
		char				str0 [512], str1 [512];
		Ici*				iciptr;
		List*				proc_record_handle_list_ptr;
		List*				ip_record_handle_list_ptr;
		OmsT_Pr_Handle		process_record_handle;
		int					instrm = OPC_INT_UNDEF;
		IpT_Interface_Info* ip_iface_elem_ptr;
		int					i;
		IpT_Address			ip_address;
		IpT_Address			next_addr;
		char				next_addr_str [IPC_ADDR_STR_LEN];
		char				msg_string [512];
		char				msg_string1 [512];
		
		char				addr_str [IPC_ADDR_STR_LEN];
		double 		slave_addr;
		double 		my_piconet;
		Objid 		node_id;
		char 		add_str[30];
		int 		ip_handle_list_size;
		arp_entry* 	next_arp_entry;
		Ici* 		bt_ici;
		Boolean 	addr_found;
		int 		record_handle_list_size;
		IpT_Info* 	ip_info_ptr;
		/* End of Temporary Variables */


		FSM_ENTER ("bt_master_arp")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (INIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (0, "INIT", "bt_master_arp [INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [INIT enter execs]", state0_enter_exec)
				{
				/* Obtain the object ID of the surrounding ARP processor. 	*/
				my_id = op_id_self ();
				
				/* Also obtain the object ID of the surrounding node.		*/
				my_node_id = op_topo_parent (my_id);
				
				/* Obtain the prohandle for this process.					*/
				own_prohandle = op_pro_self ();
				
				/*	Obtain the name of the process. It is the process model	*/
				/*	attribute on the surrounding module.					*/
				op_ima_obj_attr_get (my_id, "process model", proc_model_name);
				
				/**	Register the process in the model-wide registry.				**/
				own_process_record_handle = (OmsT_Pr_Handle) oms_pr_process_register 
					(my_node_id, my_id, own_prohandle, proc_model_name);
				
				/*	Register the protocol attribute in the registry. No other	*/
				/*	process should use the string "ipx" as the value for its	*/
				/*	"protocol" attribute!										*/
				oms_pr_attr_set (own_process_record_handle, 
					"protocol", 	OMSC_PR_STRING, 	"arp",
					"location", 	OMSC_PR_STRING, 	"mac_if", 
					OPC_NIL);
				
				/* 	Schedule a self interrupt to allow the lower layer		*/
				/*	modules (MACs) and the higher IP module to get 			*/
				/*	their addresses assigned. 				*/
				op_intrpt_schedule_self (op_sim_time (), 0);
				
				/* Create an Ici to communicate with data link layer. 		*/
				
				/*	Initialize the state variable used to keep track of the	*/
				/*	ARP module object ID and to generate trace/debugging 	*/
				/*	string information. Obtain process ID of this process. 	*/
				my_pro_id = op_pro_id (op_pro_self ());
				
				/* 	Set the process ID string, to be later used for trace	*/
				/*	and debugging information.								*/
				sprintf (pid_string, "ARP PID (%d)", my_pro_id);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"bt_master_arp")


			/** state (INIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "INIT", "bt_master_arp [INIT exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [INIT exit execs]", state0_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state0_exit_exec)


			/** state (INIT) transition processing **/
			FSM_TRANSIT_ONLY ((SELF_NOTIF), 5, state5_enter_exec, ;, INIT, "SELF_NOTIF", "", "INIT", "wait", "tr_35", "bt_master_arp [INIT -> wait : SELF_NOTIF / ]")
				/*---------------------------------------------------------*/



			/** state (WAIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "WAIT", state1_enter_exec, "bt_master_arp [WAIT enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [WAIT enter execs]", state1_enter_exec)
				{
				
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"bt_master_arp")


			/** state (WAIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "WAIT", "bt_master_arp [WAIT exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [WAIT exit execs]", state1_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (WAIT) transition processing **/
			FSM_PROFILE_SECTION_IN ("bt_master_arp [WAIT trans conditions]", state1_trans_conds)
			FSM_INIT_COND (IP_ARRIVAL)
			FSM_TEST_COND (DLL_ARRIVAL)
			FSM_TEST_LOGIC ("WAIT")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "IP_ARRIVAL", "", "WAIT", "ip_arrival", "tr_39", "bt_master_arp [WAIT -> ip_arrival : IP_ARRIVAL / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, ;, "DLL_ARRIVAL", "", "WAIT", "dll_aarival", "tr_40", "bt_master_arp [WAIT -> dll_aarival : DLL_ARRIVAL / ]")
				}
				/*---------------------------------------------------------*/



			/** state (ip_arrival) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "ip_arrival", state2_enter_exec, "bt_master_arp [ip_arrival enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [ip_arrival enter execs]", state2_enter_exec)
				{
				/**	Packet has arrived from the higher layer.		**/
				/**	IP address is obtained from the ici	**/
				/** Map IP address to slave address, put in ici.**/
				/** 
					
				/* Obtain the packet and the accompanying ICI.	*/
				pkptr = op_pk_get (intrpt_strm);
				if (pkptr == OPC_NIL)
					ip_arp_error ("Unable to get packet from input stream.");
				iciptr = op_intrpt_ici ();  
				if (iciptr == OPC_NIL)
					ip_arp_error ("Unable to get ICI accompanying received packet.");
				
				
				/* Obtain the next node number.						*/
				if (op_ici_attr_get (iciptr, "next_addr", &next_addr) == OPC_COMPCODE_FAILURE)
					{
					ip_arp_error ("Unable to get IP address of next hop from ICI.");
					}
					
				/*	Print diagnostic/trace information.				*/
				if (ARPC_LTRACE_DATA_ACTIVE)
					{
					/*	Generate message strings.					*/
					ip_address_print (addr_str, next_addr);
					
					sprintf (msg_string, "Packet ID: %d has arrived from higher layer", op_pk_id (pkptr));
					sprintf (msg_string1,"and is destined for IP address %s.", addr_str);
				
					/*	Print trace information.					*/
					op_prg_odb_print_major (pid_string, msg_string, msg_string1, OPC_NIL);
					}
				
				// Look for the ip address in the list.
				addr_found = OPC_FALSE;
				for (i = 0; i < op_prg_list_size(arp_list); i++)
					{
					next_arp_entry = op_prg_list_access(arp_list, i);
					// If the ip address in the list matches the one in the packet this is it.
					if (ip_address_equal(next_arp_entry->ip_addr, next_addr))
					{
						/* Create an ici and set destination and service */
						bt_ici = op_ici_create("bluetooth_mac_ind");
						op_ici_attr_set (bt_ici, "destination", next_arp_entry->slave_addr);
						op_ici_attr_set (bt_ici, "QOS", 1);
						// Install the ici and send the packet forced.
						op_ici_install(bt_ici);
						addr_found = OPC_TRUE;
						op_pk_send_forced(pkptr, 1);
						// Uninstall the ici.
						op_ici_install(OPC_NIL);
				
					}
					
					}
				// If the address was not found then put out a message.
				if (addr_found == OPC_FALSE)
				{
				    ip_address_print (next_addr_str, next_addr);
					sprintf (str0, "BTARP Slave: discarding unmappable packet (%d)", op_pk_id (pkptr));
					sprintf (str1, "IP Address: (%s)", next_addr_str);
					
					op_pk_destroy (pkptr);
					op_sim_message (str0, str1);	
				}
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (ip_arrival) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "ip_arrival", "bt_master_arp [ip_arrival exit execs]")


			/** state (ip_arrival) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "ip_arrival", "WAIT", "tr_42", "bt_master_arp [ip_arrival -> WAIT : default / ]")
				/*---------------------------------------------------------*/



			/** state (arp_table) enter executives **/
			FSM_STATE_ENTER_UNFORCED (3, "arp_table", state3_enter_exec, "bt_master_arp [arp_table enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [arp_table enter execs]", state3_enter_exec)
				{
				/* Schedule another self interrupt for this process to allow
				the lower modules and IP to register their addresses into the model-wide
				registry. */
				op_intrpt_schedule_self (op_sim_time () + .0035, 0); 
				
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (7,"bt_master_arp")


			/** state (arp_table) exit executives **/
			FSM_STATE_EXIT_UNFORCED (3, "arp_table", "bt_master_arp [arp_table exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [arp_table exit execs]", state3_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				
				/* 	Get my piconet that was registered by the master. */
				proc_record_handle_list_ptr = op_prg_list_create ();
				ip_record_handle_list_ptr= op_prg_list_create ();
				arp_list = op_prg_list_create();
				
				oms_pr_process_discover (my_id, proc_record_handle_list_ptr,
					"slave address", OMSC_PR_NUMBER, 99.0, OPC_NIL);
				record_handle_list_size = op_prg_list_size(proc_record_handle_list_ptr);
				
				if (record_handle_list_size == 0)
					{
					printf("ERROR\n");
					}
				else
					{
					process_record_handle = (OmsT_Pr_Handle) op_prg_list_remove(proc_record_handle_list_ptr, OPC_LISTPOS_HEAD);
					oms_pr_attr_get(process_record_handle, "piconet", OMSC_PR_NUMBER, &my_piconet);
					}
				op_prg_mem_free (proc_record_handle_list_ptr);
				proc_record_handle_list_ptr = op_prg_list_create();
				/* Get a list of the slaves that have my piconet. */
				oms_pr_process_discover (OPC_OBJID_INVALID, proc_record_handle_list_ptr, 
					"piconet",	OMSC_PR_NUMBER, my_piconet,
					OPC_NIL);
				record_handle_list_size = op_prg_list_size (proc_record_handle_list_ptr);
				if (record_handle_list_size <= 0)
					{
					/* A master should always have at least one slave. */
					op_sim_end ("Error: Master has no slaves in piconet", "", "", "");
					}
				else
					{
					for (i = 0; i < record_handle_list_size; i++)
					{
					   /*	Obtain a handle on the process record.			*/
					    process_record_handle = (OmsT_Pr_Handle) op_prg_list_remove (proc_record_handle_list_ptr, OPC_LISTPOS_HEAD);
					    /* Get the slave address.  If it is 99 it is the master. */
					    oms_pr_attr_get (process_record_handle, "slave address", OMSC_PR_NUMBER, &slave_addr);
						if (slave_addr != 99.0)
						{
							oms_pr_attr_get (process_record_handle, "node objid", OMSC_PR_OBJID, &node_id);
							oms_pr_process_discover (OPC_OBJID_INVALID, ip_record_handle_list_ptr, 
					                                 "node objid",	OMSC_PR_OBJID,		node_id,
					                                 "protocol", 	OMSC_PR_STRING,		"ip", 
					                                 OPC_NIL);
				            ip_handle_list_size = op_prg_list_size (ip_record_handle_list_ptr);
				            if (ip_handle_list_size != 1)
					        {
					           /* 	An error should be created if there are more 	*/
					           /*	than one ip process in the local node, or		*/
					           /*	if no match is found. 							*/
					           //op_sim_end ("Error: either zero or several ip processes found in the slave", "", "", "");
					        }
				            else
					        {
				
					            /*	Obtain a handle on the process record.			*/
					            process_record_handle = (OmsT_Pr_Handle) op_prg_list_access (ip_record_handle_list_ptr, OPC_LISTPOS_HEAD);
				
					            /* Obtain a pointer to the ip interface table. 		*/
					            oms_pr_attr_get (process_record_handle, "interface information", OMSC_PR_ADDRESS, &ip_info_ptr);
								ip_iface_elem_ptr = (IpT_Interface_Info*) op_prg_list_access (ip_info_ptr->ip_iface_table_ptr, 0);
								ip_address = ip_iface_elem_ptr->addr_range_ptr->address;
								ip_address_print(add_str, ip_address);
								next_arp_entry = (arp_entry*) op_prg_mem_alloc(sizeof(arp_entry));
								next_arp_entry->ip_addr = ip_address_copy(ip_address);
								next_arp_entry->slave_addr = slave_addr;
								op_prg_list_insert(arp_list, next_arp_entry, OPC_LISTPOS_TAIL);
							}
						}
					}
				
				    op_prg_mem_free (proc_record_handle_list_ptr);
					op_prg_mem_free (ip_record_handle_list_ptr);
				
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state3_exit_exec)


			/** state (arp_table) transition processing **/
			FSM_TRANSIT_ONLY ((SELF_NOTIF), 1, state1_enter_exec, ;, arp_table, "SELF_NOTIF", "", "arp_table", "WAIT", "tr_18", "bt_master_arp [arp_table -> WAIT : SELF_NOTIF / ]")
				/*---------------------------------------------------------*/



			/** state (dll_aarival) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "dll_aarival", state4_enter_exec, "bt_master_arp [dll_aarival enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [dll_aarival enter execs]", state4_enter_exec)
				{
				/*	Packet has arrived from the lower layer. It is	*/
				/*	forwarded to the higher layer.	*/
				/* Obtain the packet. 								*/
				pkptr = op_pk_get (intrpt_strm);
				if (pkptr == OPC_NIL)
					ip_arp_error ("Unable to get packet from lower layer input stream.");
				
				op_pk_send (pkptr, 0);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (dll_aarival) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "dll_aarival", "bt_master_arp [dll_aarival exit execs]")


			/** state (dll_aarival) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "dll_aarival", "WAIT", "tr_43", "bt_master_arp [dll_aarival -> WAIT : default / ]")
				/*---------------------------------------------------------*/



			/** state (wait) enter executives **/
			FSM_STATE_ENTER_UNFORCED (5, "wait", state5_enter_exec, "bt_master_arp [wait enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [wait enter execs]", state5_enter_exec)
				{
				/* It takes the completion of two self interrupts (from BEGSIM) for IP to	*/
				/* complete building its IP interface table. There is nothing to be done	*/
				/* at this stage. Schedule a self interrupt and move on.					*/
				op_intrpt_schedule_self (op_sim_time (), 0);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (11,"bt_master_arp")


			/** state (wait) exit executives **/
			FSM_STATE_EXIT_UNFORCED (5, "wait", "bt_master_arp [wait exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_master_arp [wait exit execs]", state5_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state5_exit_exec)


			/** state (wait) transition processing **/
			FSM_TRANSIT_ONLY ((SELF_NOTIF), 3, state3_enter_exec, ;, wait, "SELF_NOTIF", "", "wait", "arp_table", "tr_56", "bt_master_arp [wait -> arp_table : SELF_NOTIF / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"bt_master_arp")
		}
	}




void
_op_bt_master_arp_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
#if defined (OPD_ALLOW_ODB)
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = __LINE__+1;
#endif

	FIN_MT (_op_bt_master_arp_diag ())

	if (1)
		{
		/* Temporary Variables */
		int					intrpt_type = OPC_INT_UNDEF;
		int					intrpt_strm = OPC_INT_UNDEF;
		Packet*				pkptr;
		char				str0 [512], str1 [512];
		Ici*				iciptr;
		List*				proc_record_handle_list_ptr;
		List*				ip_record_handle_list_ptr;
		OmsT_Pr_Handle		process_record_handle;
		int					instrm = OPC_INT_UNDEF;
		IpT_Interface_Info* ip_iface_elem_ptr;
		int					i;
		IpT_Address			ip_address;
		IpT_Address			next_addr;
		char				next_addr_str [IPC_ADDR_STR_LEN];
		char				msg_string [512];
		char				msg_string1 [512];
		
		char				addr_str [IPC_ADDR_STR_LEN];
		double 		slave_addr;
		double 		my_piconet;
		Objid 		node_id;
		char 		add_str[30];
		int 		ip_handle_list_size;
		arp_entry* 	next_arp_entry;
		Ici* 		bt_ici;
		Boolean 	addr_found;
		int 		record_handle_list_size;
		IpT_Info* 	ip_info_ptr;
		/* End of Temporary Variables */

		/* Diagnostic Block */

		BINIT
		{
		/*	Print out the address of the interface on which	*/
		/*	this ARP module is attached.					*/
		printf ("\n\n    Information on ARP module for: \n");
		printf ("  =================================\n");
		
		/*	Print the name of the surrounding node.			*/
		op_ima_obj_attr_get (op_topo_parent (my_id), "name", str0);
		op_ima_obj_attr_get (op_topo_parent (op_topo_parent (my_id)), "name", str1);
		printf ("\n                 Node Name:   %s\n", str0);
		printf ("               Subnet Name:   %s\n", str1);
		
		printf("Number of entries in table = %d\n",op_prg_list_size(arp_list));
		for(i=0; i < op_prg_list_size(arp_list); i++)
		{
			next_arp_entry = (arp_entry*) op_prg_list_access (arp_list, i);
			printf("Slave address = %d\n", next_arp_entry->slave_addr);
			ip_address_print(msg_string, next_arp_entry->ip_addr);
			printf("IP address = %s\n",msg_string);
		}
		}

		/* End of Diagnostic Block */

		}

	FOUT
#endif /* OPD_ALLOW_ODB */
	}




void
_op_bt_master_arp_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_bt_master_arp_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (pr_state_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_bt_master_arp_svar function. */
#undef my_id
#undef my_node_id
#undef proc_model_name
#undef own_prohandle
#undef own_process_record_handle
#undef pid_string
#undef my_pro_id
#undef arp_list

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_bt_master_arp_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_bt_master_arp_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (bt_master_arp)",
		sizeof (bt_master_arp_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_bt_master_arp_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	bt_master_arp_state * ptr;
	FIN_MT (_op_bt_master_arp_alloc (obtype))

	ptr = (bt_master_arp_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "bt_master_arp [INIT enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_bt_master_arp_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	bt_master_arp_state		*prs_ptr;

	FIN_MT (_op_bt_master_arp_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (bt_master_arp_state *)gen_ptr;

	if (strcmp ("my_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_id);
		FOUT
		}
	if (strcmp ("my_node_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_id);
		FOUT
		}
	if (strcmp ("proc_model_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->proc_model_name);
		FOUT
		}
	if (strcmp ("own_prohandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->own_prohandle);
		FOUT
		}
	if (strcmp ("own_process_record_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->own_process_record_handle);
		FOUT
		}
	if (strcmp ("pid_string" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->pid_string);
		FOUT
		}
	if (strcmp ("my_pro_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_pro_id);
		FOUT
		}
	if (strcmp ("arp_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->arp_list);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

