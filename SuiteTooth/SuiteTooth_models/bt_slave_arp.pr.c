/* Process model C form file: bt_slave_arp.pr.c */
/* Portions of this file copyright 2014 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from bt_slave_arp.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char bt_slave_arp_pr_c [] = "MIL_3_Tfile_Hdr_ 1800 30A op_runsim_dev 7 55594754 55594754 1 volta chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 468d 2                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/***********************************************/
// The SuiteTooth model set was developed by
// HIGHLAND SYSTEMS, INC.
//
// It incorporates code available in the public
// domain and other code that is the property of
// OPNET Technologies, Inc.
//
// Inquiries may be addressed to:
// 
// Highland Systems, Inc.
// (703) 312 0830
// info@highsys.com
// www.highsys.com
/***********************************************/

#include <nato.h>
#include <oms_pr.h>
#include <oms_tan.h>
#include <ip_addr_v4.h>
#include <ip_rte_v4.h>
#include <ip_dgram_sup.h>

/*	Define codes for different values for the state	*/
/*	field of an entry in the ARP cache.				*/
typedef enum
	{
	ArpC_Entry_Free = 10,
	ArpC_Entry_Pending,
	ArpC_Entry_Resolved,
	ArpC_Entry_Permanent
	} ArpT_Entry_Status;

typedef enum
	{
	ArpC_Respond_Always,
	ArpC_Respond_When_Destination
	} ArpT_Response_Mode;

typedef enum
	{
	ARPC_STATE_UPDATE_IGNORE = -1,
	ARPC_PHYS_ADDR_UPDATE_IGNORE = -2,
	ARPC_AGE_UPDATE_IGNORE = -3,
	ARPC_ATTEMPTS_UPDATE_IGNORE = -4,
	ARPC_ATTEMPTS_UPDATE = -5
	} ArpT_Entry_Update;

/*	Define macro which represents when the update  	*/
/*	for a particular field in a given arp entry is	*/
/*	ignored.										*/
extern		IpT_Address		IpI_Default_Addr;

#define		ARPC_IP_ADDR_UPDATE_IGNORE 	IpI_Default_Addr				
#define		ARPC_QUEUE_UPDATE_IGNORE	OPC_NIL	

/*	Define Macros for arp request and reply.		*/
#define 	ARP_REQUEST					1
#define		ARP_REPLY					2

/*	Define macro for intializing the physical 		*/
/*	address field in the ARP entry.					*/
#define		ARPC_PHYS_ADDR_UNSET		-1

/*	Data structure to contain information about an	*/
/*	entry in the ARP cache.							*/
typedef struct
	{
	ArpT_Entry_Status	state;			/*	status of this entry					*/
	IpT_Address			ip_addr;		/*	IP address for the next hop				*/
	int					phys_addr;		/*	physical layer address for the next hop	*/
	int					age;			/*	age of this entry						*/
	int					num_attempts;	/*	number of times an ARP request has been	*/
										/*	sent for this entry						*/
	List*				queue;			/*	queue of packets for this entry			*/
	int					protocol_type;	/*	protocol type							*/
	int					hardware_type;	/*	physical layer type						*/
	} IpT_Arp_Entry;


/*	Define a transition condition corresponding 	*/
/*	to the IP datagram arrival.						*/
#define IP_ARRIVAL	(intrpt_type == OPC_INTRPT_STRM && intrpt_strm == instrm_from_ip_rte)

/*	Define a transition condition corresponding 	*/
/*	to a packet arrival from the data link layer.	*/
#define DLL_ARRIVAL	(intrpt_type == OPC_INTRPT_STRM && intrpt_strm != instrm_from_ip_rte)

/*	Define a transition condition corresponding 	*/
/*	to an expiration of the ARP timer.				*/
#define TIMER_EXP				intrpt_type == OPC_INTRPT_SELF
#define	SELF_NOTIF		 		intrpt_type == OPC_INTRPT_SELF

/* 	Identification constant for IP protocol within 	*/
/*	Ethernet frames.								*/
#define NET_PROT_IP				0x800
#define	ARPC_BROADCAST_ADDR		-1
#define	ARPC_ADDR_TYPE_MAC		NATOC_LOWER_LAYER_ADDR_TYPE_0
#define ADDR_INDEX_INVALID		-1

/***** Globals *****/
extern IpT_Address	IpI_Broadcast_Addr;

/*	Define constants for debugging/ltrace information*/
#define ARPC_LTRACE_DATA_ACTIVE		(op_prg_odb_ltrace_active ("arp"))
#define ARPC_LTRACE_TIMER_ACTIVE	(op_prg_odb_ltrace_active ("arp_timer"))

/* Default value used to determine whether ARP Sim	*/
/* Efficiency mode is used.							*/
#define	ARP_SIM_EFF_USED		"Enabled"


static void				ip_arp_error (const char *msg);

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		my_id                                           ;	/* Variable for storing objid of the surrounding	 */
	                        		                                                	/* ARP processor, and the surr. node objid.		     */
	Objid	                  		my_node_id                                      ;
	char	                   		proc_model_name [32]                            ;	/* Variables used in registering the process in OMS	 */
	                        		                                                	/* Process Registry.								                         */
	Prohandle	              		own_prohandle                                   ;
	OmsT_Pr_Handle	         		own_process_record_handle                       ;
	Ici*	                   		mac_iciptr                                      ;	/* Variable that defines an ICI for conveying the 	 */
	                        		                                                	/* destination specific information to the mac 	    */
	                        		                                                	/* module.											                               */
	NatoT_Table_Handle	     		global_ip_table_handle                          ;	/* State variable to store the global IP table.		 */
	IpT_Interface_Info *	   		local_intf_ptr                                  ;	/* State variable to store the data structure 		 */
	                        		                                                	/* for an IP interface.							                   */
	int	                    		instrm_from_ip_rte                              ;	/* Define variables to store information on the 	   */
	                        		                                                	/* stream indexes on which to transmit and receive	 */
	                        		                                                	/* packets from the network.						                  */
	int	                    		outstrm_to_ip_rte                               ;
	int	                    		instrm_from_mac                                 ;
	int	                    		outstrm_to_mac                                  ;
	char	                   		pid_string [512]                                ;	/* State variables for use while tracing/debugging	 */
	Objid	                  		my_pro_id                                       ;
	} bt_slave_arp_state;

#define pr_state_ptr            		((bt_slave_arp_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))
#define my_id                   		pr_state_ptr->my_id
#define my_node_id              		pr_state_ptr->my_node_id
#define proc_model_name         		pr_state_ptr->proc_model_name
#define own_prohandle           		pr_state_ptr->own_prohandle
#define own_process_record_handle		pr_state_ptr->own_process_record_handle
#define mac_iciptr              		pr_state_ptr->mac_iciptr
#define global_ip_table_handle  		pr_state_ptr->global_ip_table_handle
#define local_intf_ptr          		pr_state_ptr->local_intf_ptr
#define instrm_from_ip_rte      		pr_state_ptr->instrm_from_ip_rte
#define outstrm_to_ip_rte       		pr_state_ptr->outstrm_to_ip_rte
#define instrm_from_mac         		pr_state_ptr->instrm_from_mac
#define outstrm_to_mac          		pr_state_ptr->outstrm_to_mac
#define pid_string              		pr_state_ptr->pid_string
#define my_pro_id               		pr_state_ptr->my_pro_id

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	bt_slave_arp_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((bt_slave_arp_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

static void
ip_arp_error (const char *msg)
	{
	FIN (ip_arp_error (msg));

	op_sim_end ("Error in IP ARP process model (ip_arp_v4):",
		msg, OPC_NIL, OPC_NIL);

	FOUT;
	}


/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void bt_slave_arp (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_bt_slave_arp_init (int * init_block_ptr);
	void _op_bt_slave_arp_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_bt_slave_arp_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_bt_slave_arp_alloc (VosT_Obtype, int);
	void _op_bt_slave_arp_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
bt_slave_arp (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (bt_slave_arp ());

		{
		/* Temporary Variables */
		int					intrpt_type = OPC_INT_UNDEF;
		int					intrpt_strm = OPC_INT_UNDEF;
		char				str0 [512], str1 [512];
		Packet*				pkptr;
		Ici*				bt_iciptr;
		Ici*				iciptr;
		int					status;
		double				phys_layer_addr;
		List*				proc_record_handle_list_ptr;
		List*				ip_record_handle_list_ptr;
		int					record_handle_list_size;
		Objid				own_node_objid;
		OmsT_Pr_Handle		process_record_handle;
		IpT_Info*			ip_info_ptr;
		
		int					outstrm = OPC_INT_UNDEF;
		int					instrm = OPC_INT_UNDEF;
		Boolean				ip_addrs_found;
		int					ip_iface_table_size;
		IpT_Interface_Info* ip_iface_elem_ptr;
		int					i;
		Objid				stream_objid;
		int					stream_status;
		IpT_Address			ip_address;
		IpT_Address			next_addr;
		char				next_addr_str [IPC_ADDR_STR_LEN];
		Boolean				broadcast_addr;
		Objid				mac_if_objid = OPC_OBJID_INVALID;
		Boolean				unconnected_node = OPC_FALSE;
		
		int 				cache_index;
		Boolean				entry_index_found;
		Boolean				is_arp_packet = OPC_FALSE;
		IpT_Arp_Entry*		arp_entry_ptr;
		IpT_Arp_Entry*		debug_entry_ptr;
		ArpT_Entry_Status	entry_status;
		char				arp_packet_format [128];
		int					src_hw_addr;
		int					dest_hw_addr;
		IpT_Address			src_protocol_addr;
		IpT_Address			dest_protocol_addr;
		int					op_code;
		char				addr_str [IPC_ADDR_STR_LEN];
		
		/*	Temoporary variables to denote the message generation	*/
		/*	bufferes for printing diagnostic/trace information.		*/
		char				msg_string [512];
		char				msg_string1 [512];
		
		double slave_addr;
		double my_piconet;
		Objid node_id;
		int my_address;
		Objid mac_id;
		/* End of Temporary Variables */


		FSM_ENTER ("bt_slave_arp")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (INIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (0, "INIT", "bt_slave_arp [INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [INIT enter execs]", state0_enter_exec)
				{
				/* Obtain the object ID of the surrounding ARP processor. 	*/
				my_id = op_id_self ();
				
				/* Also obtain the object ID of the surrounding node.		*/
				my_node_id = op_topo_parent (my_id);
				
				/* Obtain the prohandle for this process.					*/
				own_prohandle = op_pro_self ();
				
				/*	Obtain the name of the process. It is the process model	*/
				/*	attribute on the surrounding module.					*/
				op_ima_obj_attr_get (my_id, "process model", proc_model_name);
				
				/**	Register the process in the model-wide registry.				**/
				own_process_record_handle = (OmsT_Pr_Handle) oms_pr_process_register 
					(my_node_id, my_id, own_prohandle, proc_model_name);
				
				/*	Register the protocol attribute in the registry. No other	*/
				/*	process should use the string "ipx" as the value for its	*/
				/*	"protocol" attribute!										*/
				oms_pr_attr_set (own_process_record_handle, 
					"protocol", 	OMSC_PR_STRING, 	"arp",
					"location", 	OMSC_PR_STRING, 	"mac_if", 
					OPC_NIL);
				
				/* 	Schedule a self interrupt to allow the lower layer		*/
				/*	modules (MACs) and the higher IP module to get 			*/
				/*	their addresses assigned. 				*/
				op_intrpt_schedule_self (op_sim_time (), 0);
				
				/*	Initialize the state variable used to keep track of the	*/
				/*	ARP module object ID and to generate trace/debugging 	*/
				/*	string information. Obtain process ID of this process. 	*/
				my_pro_id = op_pro_id (op_pro_self ());
				
				/* 	Set the process ID string, to be later used for trace	*/
				/*	and debugging information.								*/
				sprintf (pid_string, "ARP PID (%d)", my_pro_id);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"bt_slave_arp")


			/** state (INIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "INIT", "bt_slave_arp [INIT exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [INIT exit execs]", state0_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state0_exit_exec)


			/** state (INIT) transition processing **/
			FSM_TRANSIT_ONLY ((SELF_NOTIF), 5, state5_enter_exec, ;, INIT, "SELF_NOTIF", "", "INIT", "wait", "tr_35", "bt_slave_arp [INIT -> wait : SELF_NOTIF / ]")
				/*---------------------------------------------------------*/



			/** state (WAIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "WAIT", state1_enter_exec, "bt_slave_arp [WAIT enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [WAIT enter execs]", state1_enter_exec)
				{
				
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"bt_slave_arp")


			/** state (WAIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "WAIT", "bt_slave_arp [WAIT exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [WAIT exit execs]", state1_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (WAIT) transition processing **/
			FSM_PROFILE_SECTION_IN ("bt_slave_arp [WAIT trans conditions]", state1_trans_conds)
			FSM_INIT_COND (IP_ARRIVAL)
			FSM_TEST_COND (DLL_ARRIVAL)
			FSM_TEST_LOGIC ("WAIT")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "IP_ARRIVAL", "", "WAIT", "ip_arrival", "tr_39", "bt_slave_arp [WAIT -> ip_arrival : IP_ARRIVAL / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, ;, "DLL_ARRIVAL", "", "WAIT", "dll_aarival", "tr_40", "bt_slave_arp [WAIT -> dll_aarival : DLL_ARRIVAL / ]")
				}
				/*---------------------------------------------------------*/



			/** state (ip_arrival) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "ip_arrival", state2_enter_exec, "bt_slave_arp [ip_arrival enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [ip_arrival enter execs]", state2_enter_exec)
				{
				/**	Packet has arrived from the higher layer.		**/	
				/* Obtain the packet and the accompanying ICI.	*/
				pkptr = op_pk_get (intrpt_strm);
				if (pkptr == OPC_NIL)
					ip_arp_error ("Unable to get packet from input stream.");
				iciptr = op_intrpt_ici ();  
				if (iciptr == OPC_NIL)
					ip_arp_error ("Unable to get ICI accompanying received packet.");
				
				/* Obtain the next node number.						*/
				if (op_ici_attr_get (iciptr, "next_addr", &next_addr) == OPC_COMPCODE_FAILURE)
					{
					ip_arp_error ("Unable to get IP address of next hop from ICI.");
					}
					
				/*	Print diagnostic/trace information.				*/
				if (ARPC_LTRACE_DATA_ACTIVE)
					{
					/*	Generate message strings.					*/
					ip_address_print (addr_str, next_addr);
					
					sprintf (msg_string, "Packet ID: %d has arrived from higher layer", op_pk_id (pkptr));
					sprintf (msg_string1,"and is destined for IP address %s.", addr_str);
				
					/*	Print trace information.					*/
					op_prg_odb_print_major (pid_string, msg_string, msg_string1, OPC_NIL);
					}
				/* Create an ici and set service to data.*/
				bt_iciptr = op_ici_create("bluetooth_mac_ind");
				op_ici_attr_set (bt_iciptr, "QOS", 1);
				// Install the ici and send the packet.
				op_ici_install(bt_iciptr);
				op_pk_send_forced(pkptr, 1);
				// Deinstall the ici.
				op_ici_install(OPC_NIL);
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (ip_arrival) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "ip_arrival", "bt_slave_arp [ip_arrival exit execs]")


			/** state (ip_arrival) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "ip_arrival", "WAIT", "tr_42", "bt_slave_arp [ip_arrival -> WAIT : default / ]")
				/*---------------------------------------------------------*/



			/** state (arp_table) enter executives **/
			FSM_STATE_ENTER_UNFORCED (3, "arp_table", state3_enter_exec, "bt_slave_arp [arp_table enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [arp_table enter execs]", state3_enter_exec)
				{
				/* Schedule another self interrupt for this process to allow
				the lower modules and IP to register their addresses into the model-wide
				registry. */
				op_intrpt_schedule_self (op_sim_time () + .0035, 0); 
				
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (7,"bt_slave_arp")


			/** state (arp_table) exit executives **/
			FSM_STATE_EXIT_UNFORCED (3, "arp_table", "bt_slave_arp [arp_table exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [arp_table exit execs]", state3_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				}
				FSM_PROFILE_SECTION_OUT (state3_exit_exec)


			/** state (arp_table) transition processing **/
			FSM_TRANSIT_ONLY ((SELF_NOTIF), 1, state1_enter_exec, ;, arp_table, "SELF_NOTIF", "", "arp_table", "WAIT", "tr_18", "bt_slave_arp [arp_table -> WAIT : SELF_NOTIF / ]")
				/*---------------------------------------------------------*/



			/** state (dll_aarival) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "dll_aarival", state4_enter_exec, "bt_slave_arp [dll_aarival enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [dll_aarival enter execs]", state4_enter_exec)
				{
				/*	Packet has arrived from the lower layer. It is forwarded to the higher layer.	*/
				/* Obtain the packet. 								*/
				pkptr = op_pk_get (intrpt_strm);
				if (pkptr == OPC_NIL)
					ip_arp_error ("Unable to get packet from lower layer input stream.");
				
				op_pk_send (pkptr, 0);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (dll_aarival) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "dll_aarival", "bt_slave_arp [dll_aarival exit execs]")


			/** state (dll_aarival) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "dll_aarival", "WAIT", "tr_43", "bt_slave_arp [dll_aarival -> WAIT : default / ]")
				/*---------------------------------------------------------*/



			/** state (wait) enter executives **/
			FSM_STATE_ENTER_UNFORCED (5, "wait", state5_enter_exec, "bt_slave_arp [wait enter execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [wait enter execs]", state5_enter_exec)
				{
				/* It takes the completion of two self interrupts (from BEGSIM) for IP to	*/
				/* complete building its IP interface table. There is nothing to be done	*/
				/* at this stage. Schedule a self interrupt and move on.					*/
				op_intrpt_schedule_self (op_sim_time (), 0);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (11,"bt_slave_arp")


			/** state (wait) exit executives **/
			FSM_STATE_EXIT_UNFORCED (5, "wait", "bt_slave_arp [wait exit execs]")
				FSM_PROFILE_SECTION_IN ("bt_slave_arp [wait exit execs]", state5_exit_exec)
				{
				/* Obtain interrupt parameters.	*/
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					{
					intrpt_strm = op_intrpt_strm ();
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state5_exit_exec)


			/** state (wait) transition processing **/
			FSM_TRANSIT_ONLY ((SELF_NOTIF), 3, state3_enter_exec, ;, wait, "SELF_NOTIF", "", "wait", "arp_table", "tr_56", "bt_slave_arp [wait -> arp_table : SELF_NOTIF / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"bt_slave_arp")
		}
	}




void
_op_bt_slave_arp_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
#if defined (OPD_ALLOW_ODB)
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = __LINE__+1;
#endif

	FIN_MT (_op_bt_slave_arp_diag ())

	if (1)
		{
		/* Temporary Variables */
		int					intrpt_type = OPC_INT_UNDEF;
		int					intrpt_strm = OPC_INT_UNDEF;
		char				str0 [512], str1 [512];
		Packet*				pkptr;
		Ici*				bt_iciptr;
		Ici*				iciptr;
		int					status;
		double				phys_layer_addr;
		List*				proc_record_handle_list_ptr;
		List*				ip_record_handle_list_ptr;
		int					record_handle_list_size;
		Objid				own_node_objid;
		OmsT_Pr_Handle		process_record_handle;
		IpT_Info*			ip_info_ptr;
		
		int					outstrm = OPC_INT_UNDEF;
		int					instrm = OPC_INT_UNDEF;
		Boolean				ip_addrs_found;
		int					ip_iface_table_size;
		IpT_Interface_Info* ip_iface_elem_ptr;
		int					i;
		Objid				stream_objid;
		int					stream_status;
		IpT_Address			ip_address;
		IpT_Address			next_addr;
		char				next_addr_str [IPC_ADDR_STR_LEN];
		Boolean				broadcast_addr;
		Objid				mac_if_objid = OPC_OBJID_INVALID;
		Boolean				unconnected_node = OPC_FALSE;
		
		int 				cache_index;
		Boolean				entry_index_found;
		Boolean				is_arp_packet = OPC_FALSE;
		IpT_Arp_Entry*		arp_entry_ptr;
		IpT_Arp_Entry*		debug_entry_ptr;
		ArpT_Entry_Status	entry_status;
		char				arp_packet_format [128];
		int					src_hw_addr;
		int					dest_hw_addr;
		IpT_Address			src_protocol_addr;
		IpT_Address			dest_protocol_addr;
		int					op_code;
		char				addr_str [IPC_ADDR_STR_LEN];
		
		/*	Temoporary variables to denote the message generation	*/
		/*	bufferes for printing diagnostic/trace information.		*/
		char				msg_string [512];
		char				msg_string1 [512];
		
		double slave_addr;
		double my_piconet;
		Objid node_id;
		int my_address;
		Objid mac_id;
		/* End of Temporary Variables */

		/* Diagnostic Block */

		BINIT
		{
		/*	Print out the address of the interface on which	*/
		/*	this ARP module is attached.					*/
		printf ("\n\n    Information on ARP module for: \n");
		printf ("  =================================\n");
		
		/*	Print the name of the surrounding node.			*/
		op_ima_obj_attr_get (op_topo_parent (my_id), "name", str0);
		op_ima_obj_attr_get (op_topo_parent (op_topo_parent (my_id)), "name", str1);
		printf ("\n                 Node Name:   %s\n", str0);
		printf ("               Subnet Name:   %s\n", str1);
		}

		/* End of Diagnostic Block */

		}

	FOUT
#endif /* OPD_ALLOW_ODB */
	}




void
_op_bt_slave_arp_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_bt_slave_arp_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (pr_state_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_bt_slave_arp_svar function. */
#undef my_id
#undef my_node_id
#undef proc_model_name
#undef own_prohandle
#undef own_process_record_handle
#undef mac_iciptr
#undef global_ip_table_handle
#undef local_intf_ptr
#undef instrm_from_ip_rte
#undef outstrm_to_ip_rte
#undef instrm_from_mac
#undef outstrm_to_mac
#undef pid_string
#undef my_pro_id

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_bt_slave_arp_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_bt_slave_arp_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (bt_slave_arp)",
		sizeof (bt_slave_arp_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_bt_slave_arp_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	bt_slave_arp_state * ptr;
	FIN_MT (_op_bt_slave_arp_alloc (obtype))

	ptr = (bt_slave_arp_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "bt_slave_arp [INIT enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_bt_slave_arp_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	bt_slave_arp_state		*prs_ptr;

	FIN_MT (_op_bt_slave_arp_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (bt_slave_arp_state *)gen_ptr;

	if (strcmp ("my_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_id);
		FOUT
		}
	if (strcmp ("my_node_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_id);
		FOUT
		}
	if (strcmp ("proc_model_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->proc_model_name);
		FOUT
		}
	if (strcmp ("own_prohandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->own_prohandle);
		FOUT
		}
	if (strcmp ("own_process_record_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->own_process_record_handle);
		FOUT
		}
	if (strcmp ("mac_iciptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->mac_iciptr);
		FOUT
		}
	if (strcmp ("global_ip_table_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->global_ip_table_handle);
		FOUT
		}
	if (strcmp ("local_intf_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->local_intf_ptr);
		FOUT
		}
	if (strcmp ("instrm_from_ip_rte" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->instrm_from_ip_rte);
		FOUT
		}
	if (strcmp ("outstrm_to_ip_rte" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->outstrm_to_ip_rte);
		FOUT
		}
	if (strcmp ("instrm_from_mac" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->instrm_from_mac);
		FOUT
		}
	if (strcmp ("outstrm_to_mac" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->outstrm_to_mac);
		FOUT
		}
	if (strcmp ("pid_string" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->pid_string);
		FOUT
		}
	if (strcmp ("my_pro_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_pro_id);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

