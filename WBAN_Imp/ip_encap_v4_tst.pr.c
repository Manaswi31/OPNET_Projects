/* Process model C form file: ip_encap_v4_tst.pr.c */
/* Portions of this file copyright 2014 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from ip_encap_v4_tst.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char ip_encap_v4_tst_pr_c [] = "MIL_3_Tfile_Hdr_ 1800 30A modeler 7 56E1A2BF 56E1A2BF 1 volta chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 468d 2                                                                                                                                                                                                                                                                                                                                                                                                           ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

#include <ip_addr_v4.h>
#include <oms_pr.h>
#include <oms_tan.h>
#include <ip_dgram_sup.h>
#include <ip_higher_layer_proto_reg_sup.h>
#include <ip_notif_log_support.h>
#include <ip_rte_v4.h>
#include <rsvp.h>
#include <string.h>
#include <apptrack.h>

#define FROM_TRANSPORT		op_intrpt_strm () != instrm_from_network
#define FROM_NETWORK		op_intrpt_strm () == instrm_from_network

//MS:
#define IPC_INTF_INDEX_INVALID			-50

/* Typedefs */
typedef struct
	{
	int					protocol_type;
	int					outstream;
	int					instream;
	Boolean				inet_address_supported;
	}IpT_Encap_Interface;

/* Constants	*/
#define	IPC_ENCAP_REQ_ICI_VERSION4		4
#define	IPC_ENCAP_REQ_ICI_VERSION6		6

/* Globals.		*/
static Boolean ip_encap_ici_print_procs_set = OPC_FALSE;

/* Functions */
static int					ip_encap_proto_get (int strm_num, int num_iface, IpT_Encap_Interface** interface_table_handle);
static void					ip_encap_pk_destroy (Packet* pkptr);
static void					ip_encap_error (const char* msg);

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	IpT_Encap_Interface**	  		interface_table                                 ;
	int	                    		interface_table_size                            ;
	int	                    		instrm_from_network                             ;
	int	                    		outstrm_to_network                              ;
	Boolean	                		gateway                                         ;
	} ip_encap_v4_tst_state;

#define pr_state_ptr            		((ip_encap_v4_tst_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))
#define interface_table         		pr_state_ptr->interface_table
#define interface_table_size    		pr_state_ptr->interface_table_size
#define instrm_from_network     		pr_state_ptr->instrm_from_network
#define outstrm_to_network      		pr_state_ptr->outstrm_to_network
#define gateway                 		pr_state_ptr->gateway

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	ip_encap_v4_tst_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((ip_encap_v4_tst_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

static int
ip_encap_proto_get (int strm_num, int num_iface, IpT_Encap_Interface** interface_table_handle)
	{
	int			i;

	/** This function returns the protocol type corresponding to an input stream index. **/ 
	FIN (ip_encap_proto_get (strm_num, num_iface, interface_table_handle))

	for (i=0; i < num_iface; i++)
		{
		if (interface_table_handle[i]->instream == strm_num)
			{
			FRET (interface_table_handle[i]->protocol_type);
			}
		}

	/* If no match is found, return an error code. */
	FRET (IpC_Protocol_Unspec);
	}

static void
ip_encap_pk_destroy (Packet* pkptr)
	{
	Ici*						intf_iciptr;
	IpT_Rte_Ind_Ici_Fields*		intf_ici_struct_ptr;

	/** Destroys the IP datagram received from lower	**/
	/** layer and the associated ip_rte_ind_v4 ICI		**/
	FIN (ip_encap_pk_destory (pkptr));

	/* Get the ICI associated with the packet	*/
	intf_iciptr = op_pk_ici_get (pkptr);
	
	/* Destroy the packet						*/
	op_pk_destroy (pkptr);

	/* Destroy the ICI and its fields			*/
	if (intf_iciptr != OPC_NIL)
		{
		op_ici_attr_get (intf_iciptr, "rte_info_fields", &intf_ici_struct_ptr);
		ip_rte_ind_ici_fdstruct_destroy (intf_ici_struct_ptr);
		op_ici_destroy (intf_iciptr);
		}

	FOUT;
	}

static void
ip_encap_error (const char* msg)
	{
	/** Print an error message and exit the simulation. **/
	FIN (ip_encap_error (msg));

	op_sim_end ("Error from IP encapsulation process model (ip_encap_v4):",
				msg, OPC_NIL, OPC_NIL);
	
	FOUT;
	}


/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void ip_encap_v4_tst (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_ip_encap_v4_tst_init (int * init_block_ptr);
	void _op_ip_encap_v4_tst_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_ip_encap_v4_tst_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_ip_encap_v4_tst_alloc (VosT_Obtype, int);
	void _op_ip_encap_v4_tst_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
ip_encap_v4_tst (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (ip_encap_v4_tst ());

		{
		/* Temporary Variables */
		
		/* End of Temporary Variables */


		FSM_ENTER ("ip_encap_v4_tst")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (ENCAP) enter executives **/
			FSM_STATE_ENTER_FORCED (0, "ENCAP", state0_enter_exec, "ip_encap_v4_tst [ENCAP enter execs]")
				FSM_PROFILE_SECTION_IN ("ip_encap_v4_tst [ENCAP enter execs]", state0_enter_exec)
				{
				/* Declarations must always be present at the top of the block.	*/
				
				Packet*				ip_pkptr;
				Packet*				pkptr;
				
				Ici*				ul_iciptr;
				Ici*				ip_iciptr;
				
				int					isis_out_intf_index, out_intf_index;
				InetT_Address		org_addr = INETC_ADDRESS_INVALID;
				InetT_Address		dest_addr = INETC_ADDRESS_INVALID;
				char				dest_addr_str [INETC_ADDR_STR_LEN];
				int					type_of_service;
				int					ecn_status = 0;
				
				IpT_Address			ipv4_addr;
				
				
				OpT_Packet_Size		data_len;
				int					input_strm;
				int					conn_class;
				int					mcast_major_port;
				int					mcast_minor_port;
				int 				ttl;
				char				error_string [512];
				
				IpT_Dgram_Fields*	ip_dgram_fd_ptr;
				int					protocol_type;
				int 				vrf_index;
				
				int					version;
				InetT_Address*		addr_ptr;
				
				
				/* RSVP packets must be forwarded on interface specified	*/
				/* by RSVP. The routing information for RSVP packets is		*/
				/* carried in ip_encap_reg ICI and also in ip_rte_reg ICI.	*/
				RsvpT_Rte_Ici_Struct * 		pkt_route_info_ptr;
				
				OpT_Int64					vmac_addr = -1;
				
				/* Obtain the packet arriving from a higher protocol layer.	*/
				input_strm = op_intrpt_strm();
				pkptr = op_pk_get (input_strm);
				printf("IP encap packet from TCP to Network \n");
				
				op_pk_print(pkptr);
				if (pkptr == OPC_NIL)
					ip_encap_error ("Unable to get packet from transport layer.");
				
				/* Obtain the length of the encapsulated packet (in bytes)	*/
				/* (Note: up to 7 bits may be unmodeled for packets which 	*/
				/* do not contain an integral number of bytes.				*/ 
				data_len = op_pk_total_size_get (pkptr) / 8;
				
				/* Determine the protocol number corresponding to the input	*/
				/* stream index.											*/
				protocol_type = ip_encap_proto_get (input_strm, interface_table_size, interface_table);
				
				/* In case of an invalid protocol number, generate error.	*/
				if (protocol_type == IpC_Protocol_Unspec)
					{
					sprintf (error_string, "Simulation aborted; error in object (%d)", op_id_self ());
					op_sim_end (error_string, "ip_encap: protocol is invalid or unregistered", " ", " ");
					}
				
				/* Get a pointer to the acoompanying Ici.					*/
				ul_iciptr = op_intrpt_ici ();
				
				/* Obtain the destination address, source address and 		*/
				/* connection class from the accompanying ICI.		 		*/
				if (ul_iciptr == OPC_NIL)
					{
					ip_encap_error ("Unable to get ICI from transport layer.");
					}
				
				/* Get the version of the ici. Version 4 of the ici uses	*/
				/* the IpT_Address structure and hence can support only		*/
				/* IPv4 addresses. Version 6 uses the InetT_Address			*/
				/* structure and can support both IPv4 and IPv6 addresses.	*/
				if (op_ici_attr_get (ul_iciptr, "version", &version) == OPC_COMPCODE_FAILURE)
					{
					ip_encap_error ("Unable to get version from transport ICI.");
					}
				
				/* Obtain the source and destination addresses.				*/
				if (IPC_ENCAP_REQ_ICI_VERSION4 == version)
					{
					if (op_ici_attr_get (ul_iciptr, "dest_addr", &ipv4_addr) == OPC_COMPCODE_FAILURE)
						{
						ip_encap_error ("Unable to get destination address from transport ICI.");
						}
					/* Create a InetT_Address representation of the address.*/
					dest_addr= inet_address_from_ipv4_address_create (ipv4_addr);
				
					if (op_ici_attr_get (ul_iciptr, "src_addr", &ipv4_addr) == OPC_COMPCODE_FAILURE)
						{
						ip_encap_error ("Unable to get source address from transport ICI.");
						}
					/* Create a InetT_Address representation of the address.*/
					if (ip_address_equal (ipv4_addr, IPC_ADDR_INVALID))
						{
						org_addr = INETC_ADDRESS_INVALID;
						}
					else
						{
						org_addr= inet_address_from_ipv4_address_create (ipv4_addr);
						}
					
					/* Create an IPv4 packet       */
					ip_pkptr = ip_dgram_v4_create ();	
					}
				else
					{
					/* This is a version 6 Ici.								*/
					if (op_ici_attr_get (ul_iciptr, "dest_addr", &addr_ptr) == OPC_COMPCODE_FAILURE)
						{
						ip_encap_error ("Unable to get destination address from transport ICI.");
						}
				
					/* Store the address in a local variable.				*/
					/* Do not use inet_address_copy because dest_addr is a	*/
					/* temporary variable.									*/
					dest_addr = *addr_ptr;
					
					if (op_ici_attr_get (ul_iciptr, "src_addr", &addr_ptr) == OPC_COMPCODE_FAILURE)
						{
						ip_encap_error ("Unable to get source address from transport ICI.");
						}
				
					/* If addr_pointer is NIL, set the source address to an	*/
					/* invalid value. It will be appropriately set when the	*/
					/* packet is sent out.									*/
					if (OPC_NIL == addr_ptr)
						{
						org_addr = INETC_ADDRESS_INVALID;
						}
					else
						{
						/* Store the address in a local variable.			*/
						/* Do not use inet_address_copy because org_addr 	*/
						/* is a temporary variable.							*/
						org_addr= *addr_ptr;
						}
					
					/* Create an IP packet       */
					ip_pkptr = ip_dgram_create (dest_addr);	
					}
				
				/* Check the transport protocol's intent of setting the ECN codepoints.	*/
				if (op_ici_attr_get (ul_iciptr, "ECN", &ecn_status) == OPC_COMPCODE_FAILURE)
					{
					ip_encap_error ("Unable to get the ECN from transport ICI.");
					}
				
				/* The connection class setting is used mainly by layers below IP (e.g., ATM)	*/
				/* to determine how to treat higher layer traffic -- e.g., mapping on to VCs.	*/
				/* (routing protocols are tagged as a different connection class).				*/
				if (op_ici_attr_get (ul_iciptr, "connection_class", &conn_class) == OPC_COMPCODE_FAILURE)
					{
					ip_encap_error ("Unable to get connection class from transport ICI.");
					}
				
				/* 	Obtain type of service from the accompanying ICI. This value will be later stored in the field 			*/
				/*	structure of the outgoing packet.																		*/
				/*	If this is an ICI coming from OSPF, or IGRP, type of service is 0 by default (set in ip_encap_v4.ic.m). */
				if (op_ici_attr_get (ul_iciptr, "Type of Service", &type_of_service) == OPC_COMPCODE_FAILURE)
					{
					ip_encap_error ("Unable to get type of service from transport ICI.");
					}
				
				/* Retrieve the TTL value to be associated with the datagram.		*/
				if (op_ici_attr_get (ul_iciptr, "TTL", &ttl) == OPC_COMPCODE_FAILURE)
					{
					ip_encap_error ("Unable to get TTL value from transport ICI.");
					}
				
				
				/* If the destination address is multicast, then we need to retrieve	*/
				/* major and minor ports, which the higher layer specifies.		    	*/
				if (inet_address_is_multicast (dest_addr) &&  (protocol_type != IpC_Protocol_Rsvp))
					{
					if (op_ici_attr_get (ul_iciptr, "multicast_major_port", &mcast_major_port) == OPC_COMPCODE_FAILURE)
						{
						mcast_major_port = 0;
						ipnl_protwarn_mcast_no_major_port_specified (pkptr, dest_addr);
				
						/* inet_address_print (dest_addr_str, dest_addr); */
						/* sprintf (error_string, "Unable to retrieve multicast major port for multicast address (%s)", */
						/*	dest_addr_str);								*/
						/* ip_encap_error (error_string);				*/
						}
					
					if (op_ici_attr_get (ul_iciptr, "multicast_minor_port", &mcast_minor_port) == OPC_COMPCODE_FAILURE)
						{
						inet_address_print (dest_addr_str, dest_addr);
						sprintf (error_string, "Unable to retrieve multicast minor port for multicast address (%s)", 
							dest_addr_str);
						ip_encap_error (error_string);
						}
				
					/* Get the Source virtual mac address 				*/
					/* Retrieve the Virtual MAC Address value to be associated with the datagram.		*/
					if (op_ici_attr_get_int64 (ul_iciptr, "src_mac_addr", &vmac_addr) == OPC_COMPCODE_FAILURE)
						ip_encap_error ("Unable to get Virtual MAC Address value from transport ICI.");
					
					/* Prepare an ICI that is to be sent to ip_dispatch,indicating the major*/
					/* and minor ports on which to send the multicast packet.				*/
					ip_iciptr = op_ici_create ("ip_rte_req_v4");
					op_ici_attr_set (ip_iciptr, "multicast_major_port", mcast_major_port);
					op_ici_attr_set (ip_iciptr, "multicast_minor_port", mcast_minor_port);
					op_ici_attr_set_int64 (ip_iciptr, "src_mac_addr", vmac_addr);
					
					/* Install this ICI	*/
					op_ici_install (ip_iciptr);
					}
				else if (protocol_type == IpC_Protocol_Isis)
					{
					
					/* Get the output index from the incoming ICI						*/
					if (op_ici_attr_get (ul_iciptr, "out_intf_index", &isis_out_intf_index) == OPC_COMPCODE_FAILURE)
						{
						sprintf (error_string, "Unable to retrieve the ISIS packet's output index"); 
						ip_encap_error (error_string);
						}
					
					/* Prepare an ICI that is to be sent to ip_dispatch,indicating the 	*/
					/* output index in the major port									*/
					ip_iciptr = op_ici_create ("ip_rte_req_v4");
					op_ici_attr_set (ip_iciptr, "out_intf_index", isis_out_intf_index);
					
					/* Install this ICI													*/
					op_ici_install (ip_iciptr);
					
					/* The ISIS packets don't use the IP header, so reduce the IP 		*/
					/* header length from the packet bulk length						*/
					data_len -= IPC_DGRAM_HEADER_LEN_BYTES;
					}
				else if (protocol_type != IpC_Protocol_Rsvp)
					{
					/* If out_intf_index is set, install the ip_rte_req_v4 ici. */
					/* Get the output index from the incoming ICI				*/
					if ((op_ici_attr_get (ul_iciptr, "out_intf_index", &out_intf_index) == OPC_COMPCODE_SUCCESS) &&
						(out_intf_index != IPC_INTF_INDEX_INVALID))
						{
						/* out_intf_index is set in ICI, create ip_rte_req_v4 ICI */
						ip_iciptr = op_ici_create ("ip_rte_req_v4");
				
						op_ici_attr_set (ip_iciptr, "out_intf_index", out_intf_index);
						op_ici_install (ip_iciptr);
						}
					else
						{
						/* No request should be made to ip_dispatch, so explicitly de-install any outstanding ICIs. */
						op_ici_install (OPC_NIL);
						}
					}
				
				/* Some protocols may also indicate a VRF table to use (instead of the common rte table).	*/
				op_ici_attr_get_int32 (ul_iciptr, "vrf_index", &vrf_index);
				
				/* If this is an RSVP packet, also get Next hop Address and Interface index	*/
				if (protocol_type == IpC_Protocol_Rsvp)
					{
					if (op_ici_attr_get (ul_iciptr, "RSVP Packet Route Info", &pkt_route_info_ptr) == OPC_COMPCODE_FAILURE)
						{
						ip_encap_error ("Unable to get routing information from transport ICI.");
						}
				
					/* Prepare an ICI that is to be sent to ip_dispatch, indicating interface on 	*/
					/* which to send the RSVP packet so as IP does not do route query			*/
					ip_iciptr = op_ici_create ("ip_rte_req_v4");
				
					op_ici_attr_set (ip_iciptr, "RSVP Packet Route Info", pkt_route_info_ptr);
				
					op_ici_install (ip_iciptr);
				
					/* Destroy the ICI only for RSVP packets.	*/
					op_ici_destroy (ul_iciptr);
					}
				
				/* IP packet is created. Encapsulate the new arrival		*/
				/* within its data field. The data field has a modeled size	*/
				/* of zero in order to allow breaking of the packet into	*/
				/* pre-determined arbitrarily small sizes. The bulk size	*/
				/* attribute of the IP packet will instead be used to model	*/
				/* the size of the encapsulated data.						*/
				if (ip_pkptr == OPC_NIL)
					ip_encap_error ("Unable to create IP datagram.");
				
				if (op_pk_nfd_set (ip_pkptr, "data", pkptr) == OPC_COMPCODE_FAILURE)
					ip_encap_error ("Unable to set data in IP datagram.");
				
				/* Indicate the VRF index in a special field.	*/
				if (-1 != vrf_index)
					op_pk_fd_set_int32 (ip_pkptr, IPC_DGRAM_FD_INDEX_VRF_INDEX, vrf_index, 0 /* pseudo-field, no size */);
				
				/*	Create fields data structure that contains orig_len, 	*/
				/*	ident, frag_len, ttl, src_addr, dest_addr, frag, 		*/
				/*	connection class, src and dest internal addresses.		*/
				ip_dgram_fd_ptr = ip_dgram_fdstruct_create ();
				
				/*	Assign values to members of the field structure.	*/
				ip_dgram_fd_ptr->src_addr			= inet_address_copy (org_addr);
				ip_dgram_fd_ptr->dest_addr			= inet_address_copy (dest_addr);
				ip_dgram_fd_ptr->connection_class	= conn_class;
				ip_dgram_fd_ptr->orig_len			= data_len;
				ip_dgram_fd_ptr->frag_len			= data_len;
				ip_dgram_fd_ptr->ttl				= ttl;
				ip_dgram_fd_ptr->protocol			= protocol_type;
				ip_dgram_fd_ptr->tos 				= type_of_service;
				ip_dgram_fd_ptr->compression_method = IpC_No_Compression;
				
				/* Set the original size of the datagram appropriately.		*/
				if (InetC_Addr_Family_v6 == inet_address_family_get (&dest_addr))
					{
					ip_dgram_fd_ptr->original_size      = IPV6C_DGRAM_HEADER_LEN_BITS + op_pk_total_size_get (ip_pkptr);
					}
				else
					{
					ip_dgram_fd_ptr->original_size      = IPC_DGRAM_HEADER_LEN_BITS + op_pk_total_size_get (ip_pkptr);
					}
				
				/* Set the ECN fields in the IP datagram.	*/
				ip_dgram_fd_ptr->CE					= 0;
				ip_dgram_fd_ptr->ECT				= ecn_status;
				
				/* Indicate that the packet is not yet fragmented.	*/
				ip_dgram_fd_ptr->frag				= 0;
				
				/*	Set the fields structure inside the ip datagram.	*/
				ip_dgram_fields_set (ip_pkptr, ip_dgram_fd_ptr);
				
				apptrack_pk_add_protocol_info_ip (pkptr, ip_dgram_fd_ptr);
				
				/* Set the bulk size of the IP packet to model the space	*/
				/* occupied by the encapsulated data.						*/
				op_pk_bulk_size_set (ip_pkptr, data_len * 8); 
				
				/* Forward the packet to the IP layer.	*/
				op_pk_send (ip_pkptr, outstrm_to_network);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (ENCAP) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "ENCAP", "ip_encap_v4_tst [ENCAP exit execs]")


			/** state (ENCAP) transition processing **/
			FSM_TRANSIT_FORCE (3, state3_enter_exec, ;, "default", "", "ENCAP", "WAIT", " ", "ip_encap_v4_tst [ENCAP -> WAIT : default / ]")
				/*---------------------------------------------------------*/



			/** state (INIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (1, "INIT", "ip_encap_v4_tst [INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("ip_encap_v4_tst [INIT enter execs]", state1_enter_exec)
				{
				/* Declarations must always be present at the top of the block.	*/
				
				Objid					own_objid, own_node_objid;
				Prohandle				own_prohandle;
				char					proc_model_name [20];
				OmsT_Pr_Handle			process_record_handle;
				
				
				/** Register using OMS Process Registry.					**/
				
				/* Obtain the neccessary objids.							*/
				own_objid = op_id_self ();
				own_node_objid = op_topo_parent (own_objid);
				
				/* Obtain the ip_encap process's prohandle.					*/
				own_prohandle = op_pro_self ();
				
				/* Obtain the name of the process. It is the				*/
				/* "process model" attribute of the module.					*/
				op_ima_obj_attr_get_str (own_objid, "process model", 20, proc_model_name);
				
				/* Register the process in the model-wide registry.			*/
				process_record_handle = (OmsT_Pr_Handle) oms_pr_process_register (own_node_objid, own_objid, 
										own_prohandle, proc_model_name);
				
				/* Register the protocol attribute in the registry.			*/
				oms_pr_attr_set (process_record_handle, "protocol", OMSC_PR_STRING, "ip_encap", OPC_NIL);
				
				/* Set print proc for InetT_Address fields in Icis	*/
				if (ip_encap_ici_print_procs_set == OPC_FALSE)
					{
					op_ici_format_print_proc_set ("inet_encap_ind", "src_addr",  inet_address_ici_field_print);
					op_ici_format_print_proc_set ("inet_encap_ind", "dest_addr",  inet_address_ici_field_print);
					op_ici_format_print_proc_set ("inet_encap_ind", "interface_received", inet_address_ici_field_print);
					op_ici_format_print_proc_set ("inet_encap_req", "src_addr",  inet_address_ici_field_print);
					op_ici_format_print_proc_set ("inet_encap_req", "dest_addr", inet_address_ici_field_print);
					}
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"ip_encap_v4_tst")


			/** state (INIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "INIT", "ip_encap_v4_tst [INIT exit execs]")


			/** state (INIT) transition processing **/
			FSM_TRANSIT_FORCE (4, state4_enter_exec, ;, "default", "", "INIT", "STRM_DEMUX", "tr_26", "ip_encap_v4_tst [INIT -> STRM_DEMUX : default / ]")
				/*---------------------------------------------------------*/



			/** state (DECAP) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "DECAP", state2_enter_exec, "ip_encap_v4_tst [DECAP enter execs]")
				FSM_PROFILE_SECTION_IN ("ip_encap_v4_tst [DECAP enter execs]", state2_enter_exec)
				{
				/* Declarations must always be present at the top of the block.	*/
				
				Packet*				ip_pkptr;
				Packet*				pkptr;
				
				Ici*				ll_iciptr;
				Ici*				transp_iciptr;
				
				InetT_Address		arrived_intf_addr = INETC_ADDRESS_INVALID;
				int					minor_port_received;
				int 				major_port_received;
				InetT_Address		org_addr = INETC_ADDRESS_INVALID;
				InetT_Address		dest_addr = INETC_ADDRESS_INVALID;
				int					type_of_service;
				
				IpT_Address			ipv4_addr;
				double				iface_mtu;
				double				iface_load;
				double				iface_speed;
				double				iface_reliability;
				
				int					i;
				int					output_strm;
				int					intf_rcvd_index;
				Boolean				inet_address_supported;
				char				protocol_name[20];
				char				error_string [512];
				
				IpT_Dgram_Fields*	ip_dgram_fd_ptr;
				int					protocol_type;
				
				InetT_Address*		addr_ptr;
				
				/* IP datagrams maintain an ICI to record information	*/
				/* required for proper routing (e.g., slot on which the	*/
				/* datagram arrived, output interface on which it		*/
				/* should be forwarded, etc.) -- all that information	*/
				/* is stored in a single structure field of the			*/
				/* ip_rte_ind_v4 ICI.									*/
				IpT_Rte_Ind_Ici_Fields*		intf_ici_fdstruct_ptr;
				
				/* Obtain a packet arriving from the network layer		*/
				ip_pkptr = op_pk_get (instrm_from_network);
				
				printf("From Network Layer in IP_ENCAP \n");
				op_pk_print(ip_pkptr);
				
				if (ip_pkptr == OPC_NIL)
					ip_encap_error ("Unable to get packet from network layer.");
				
				/*	Get the fields structure from the packet.			*/
				op_pk_nfd_access (ip_pkptr, "fields", &ip_dgram_fd_ptr);
				
				/* Determine the source address of the data.			*/
				org_addr = inet_address_copy (ip_dgram_fd_ptr->src_addr);
				
				/* Store the destinaton address also.					*/
				dest_addr = inet_address_copy (ip_dgram_fd_ptr->dest_addr);
				
				/* Determine the type of service. This attribute needs to be passed to tcp 	*/
				/* layer (for tcp connectios),or to tpal (for udp connections).				*/
				type_of_service = ip_dgram_fd_ptr->tos; 
				
				/* Determine the protocol number.						*/
				protocol_type = ip_dgram_fd_ptr->protocol;
				
				/* Determine the output stream index corresponding to	*/
				/* the protocol.										*/
				output_strm = -1;
				for (i = 0; i < interface_table_size; i++)
					{
					if (interface_table [i]->protocol_type == protocol_type)
						{
						output_strm = interface_table [i]->outstream;
						inet_address_supported = interface_table [i]->inet_address_supported;
						break;
						}
					}
				
				if (output_strm == -1)
					{
					/* If the protocol is unknown, print a trace error	*/
					/* message.											*/
					if (op_prg_odb_ltrace_active ("ip_errs"))
						{
						op_pk_format (ip_pkptr, protocol_name);
						sprintf (error_string, "Packet of unknown protocol [%s] received by IP encap. Destroying packet",
							protocol_name);
						op_sim_message (error_string, OPC_NIL);
						}
				
					ip_encap_pk_destroy (ip_pkptr);
				
					inet_address_destroy (org_addr);
					}
				else
					{
					/* If this node is not a gateway, destroy any routing protocol packet	*/
					if ((gateway == OPC_FALSE) && ((protocol_type == IpC_Protocol_Ospf) || (protocol_type == IpC_Protocol_Igrp)
							|| (protocol_type == IpC_Protocol_Eigrp)))
						{
						/** We have received a routing protocol packet but, routing		**/
						/** modules are not enabled on this node. Destroy this packet	**/
						
						/* Print a trace message	*/
						if (op_prg_odb_ltrace_active ("ip_errs"))
							{
							sprintf (error_string, "Received a packet for the routing protocol %s but, routing modules",
								ip_dgram_option_name_find ((IpT_Option_Type)protocol_type));
							op_sim_message (error_string, "on this node are not enabled. Destroying the packet");
							}
				
						/* Destroy the packet	*/
						ip_encap_pk_destroy (ip_pkptr);
						}
					else
						{
						/* Decapsulate the contained transport level data.		*/
						if (op_pk_nfd_get (ip_pkptr, "data", &pkptr) == OPC_COMPCODE_FAILURE)
						ip_encap_error ("Unable to get data from IP datagram.");
				
						/* Obtain the ICI from IP indicating which interface	*/
						/* this packet arrived on.								*/
						ll_iciptr = op_pk_ici_get (ip_pkptr);
						printf("Interface on which packet arrived in IP_ENCAP \n");
						op_ici_print(ll_iciptr);
						op_ici_attr_get (ll_iciptr, "rte_info_fields", &intf_ici_fdstruct_ptr);
				
						/* Retrieve the address of the interface.				*/
						arrived_intf_addr = inet_address_copy (intf_ici_fdstruct_ptr->interface_received);
													
						/* Retrieve the major port information.					*/
						major_port_received = intf_ici_fdstruct_ptr->major_port_received;
				
						/* Retrieve the minor port information.					*/
						minor_port_received = intf_ici_fdstruct_ptr->minor_port_received;
				
						/* NOTE: Currently IGRP and EIGRP requires certain		*/
						/* interface information to be associated with the		*/
						/* packets that are forwarded to it from the IP layer.	*/
						/* If the protocol for which the packet is destined is	*/
						/* IGRP or EIGRP, then extract that information.		*/
						/* Otherwise, for simulation efficiency reasons, we do	*/
						/* not need it.											*/
						iface_mtu 		  = intf_ici_fdstruct_ptr->mtu;
						iface_load 		  = intf_ici_fdstruct_ptr->iface_load;
						iface_speed 	  = intf_ici_fdstruct_ptr->iface_speed;
						iface_reliability = intf_ici_fdstruct_ptr->iface_reliability;
						intf_rcvd_index   = intf_ici_fdstruct_ptr->intf_recvd_index;
				
						/* Destroy the lower layer ICI after use.	*/
						ip_rte_ind_ici_fdstruct_destroy (intf_ici_fdstruct_ptr);
						op_pk_ici_set (ip_pkptr, OPC_NIL);
						op_ici_destroy (ll_iciptr);
				
						/* Forward the data to the transport layer or a routing process	*/
						/* running over IP. Associate IP interface information (source	*/
						/* address and iface address on which IP datagram was received)	*/
				
						/* Depending on whether or not the higher layer supports*/
						/* InetT_Address structures, use the version 4/6 of the	*/
						/* ici.													*/
						/* Create an Ici for communication with the higher layer.		*/
						if (inet_address_supported)
							{
							/* InetT_Address is supported. Use version 6 Ici.	*/
							transp_iciptr = op_ici_create ("inet_encap_ind");
							
							printf("Ici being forward to transport layer from IP_ENCAP after receiving \n");
								op_ici_print(transp_iciptr);
							if (transp_iciptr == OPC_NIL)
								ip_encap_error ("Unable to create ICI for communication with transport layer.");
				
							/* Allocate memory to hold the Source address field	*/
							/* in the ici.										*/
							addr_ptr = inet_address_mem_alloc ();
				
							/* Store the source address in this location. Do not*/
							/* use inet_address_copy since org_addr is a		*/
							/* temporary variable.								*/
							*addr_ptr = org_addr;
							if (op_ici_attr_set (transp_iciptr, "src_addr", addr_ptr) == OPC_COMPCODE_FAILURE)
								ip_encap_error ("Unable to set source address in transport layer ICI.");
				
							/* Allocate memory to hold the Destination address 	*/
							/* field in the ici.								*/
							addr_ptr = inet_address_mem_alloc ();
				
							/* Store the source address in this location. Do not*/
							/* use inet_address_copy since dest_addr is a		*/
							/* temporary variable.								*/
							*addr_ptr = dest_addr;
							if (op_ici_attr_set (transp_iciptr, "dest_addr", addr_ptr) == OPC_COMPCODE_FAILURE)
								ip_encap_error ("Unable to set source address in transport layer ICI.");
				
							/* Allocate memory to hold the Interface received	*/
							/* field in the ici.								*/
							addr_ptr = inet_address_mem_alloc ();
				
							/* Store the interface received in this location. Do*/
							/* not use inet_address_copy since org_addr is a	*/
							/* temporary variable.								*/
							*addr_ptr = arrived_intf_addr;
							if (op_ici_attr_set (transp_iciptr, "interface_received", addr_ptr) == OPC_COMPCODE_FAILURE)
								ip_encap_error ("Unable to set interface received address in transport layer ICI.");
							}
						else
							{
							/* InetT_Address is not supported. Use version 4 Ici.*/
							transp_iciptr = op_ici_create ("ip_encap_ind_v4");
							if (transp_iciptr == OPC_NIL)
								ip_encap_error ("Unable to create ICI for communication with transport layer.");
				
							ipv4_addr = inet_ipv4_address_get (org_addr);
							if (op_ici_attr_set (transp_iciptr, "src_addr", ipv4_addr) == OPC_COMPCODE_FAILURE)
								ip_encap_error ("Unable to set source address in transport layer ICI.");
				
							ipv4_addr = inet_ipv4_address_get (arrived_intf_addr);
							if (op_ici_attr_set (transp_iciptr, "interface_received", ipv4_addr) == OPC_COMPCODE_FAILURE)
								ip_encap_error ("Unable to set interface received address in transport layer ICI.");
								
							ipv4_addr = inet_ipv4_address_get (ip_dgram_fd_ptr->dest_addr);
							if (op_ici_attr_set (transp_iciptr, "dest_addr", ipv4_addr) == OPC_COMPCODE_FAILURE)
								ip_encap_error ("Unable to set destination address in transport layer ICI.");
							}
				
						/* Set the rest of the fields also in the ici.			*/
						if (op_ici_attr_set (transp_iciptr, "major_port_received", major_port_received) == OPC_COMPCODE_FAILURE)
							ip_encap_error ("Unable to set major port received in transport layer ICI.");
				
						if (op_ici_attr_set (transp_iciptr, "minor_port_received", minor_port_received) == OPC_COMPCODE_FAILURE)
							ip_encap_error ("Unable to set minor port received in transport layer ICI.");
				
						if (op_ici_attr_set (transp_iciptr, "Type of Service", type_of_service) == OPC_COMPCODE_FAILURE)
							ip_encap_error ("Unable to set type of service in transport layer ICI.");
				
						if (op_ici_attr_set (transp_iciptr, "congestion_experienced", ip_dgram_fd_ptr->CE) == OPC_COMPCODE_FAILURE)
							ip_encap_error ("Unable to set congestion experienced fields in transport layer ICI.");
				
						/* If IP has indicated that this packet was received on a particular VRF, then	*/
						/* pass that information along to the higher layer. Some higher layers (OSPF 	*/
						/* sham links etc.) need to know this.											*/
						if (op_pk_fd_is_set (ip_pkptr, IPC_DGRAM_FD_INDEX_VRF_INDEX))
							{
							int		vrf_index;
							op_pk_fd_get_int32 (ip_pkptr, IPC_DGRAM_FD_INDEX_VRF_INDEX, &vrf_index);
							op_ici_attr_set_int32 (transp_iciptr, "vrf_index", vrf_index);
							}
				
						/* Again, if the packet is for the IGRP or EIGRP dynamic		*/
						/* routing protocols, then associate some more interface		*/
						/* information. Currently, only IGRP and EIGRP use this to		*/
						/* compute route metrics.										*/
						if ((protocol_type == IpC_Protocol_Igrp) || (protocol_type == IpC_Protocol_Eigrp))
							{
							op_ici_attr_set (transp_iciptr, "iface_mtu",         iface_mtu);
							op_ici_attr_set (transp_iciptr, "iface_load",        iface_load);
							op_ici_attr_set (transp_iciptr, "iface_speed",       iface_speed);
							op_ici_attr_set (transp_iciptr, "iface_reliability", iface_reliability);
							}
						
						/* Set the interface received index: */
						op_ici_attr_set(transp_iciptr, "incoming_intf_index", intf_rcvd_index);
				
						apptrack_pk_add_protocol_info_ip (pkptr, ip_dgram_fd_ptr);
				
				    	/* Discard the IP packet.	*/
						op_pk_destroy (ip_pkptr);
				
						/* Install the ICI and send the packet to the	*/
						/* higher layer.								*/
						op_ici_install (transp_iciptr);
						op_pk_send (pkptr, output_strm);
						}
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (DECAP) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "DECAP", "ip_encap_v4_tst [DECAP exit execs]")


			/** state (DECAP) transition processing **/
			FSM_TRANSIT_FORCE (3, state3_enter_exec, ;, "default", "", "DECAP", "WAIT", " ", "ip_encap_v4_tst [DECAP -> WAIT : default / ]")
				/*---------------------------------------------------------*/



			/** state (WAIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED (3, "WAIT", state3_enter_exec, "ip_encap_v4_tst [WAIT enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (7,"ip_encap_v4_tst")


			/** state (WAIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (3, "WAIT", "ip_encap_v4_tst [WAIT exit execs]")


			/** state (WAIT) transition processing **/
			FSM_PROFILE_SECTION_IN ("ip_encap_v4_tst [WAIT trans conditions]", state3_trans_conds)
			FSM_INIT_COND (FROM_TRANSPORT)
			FSM_TEST_COND (FROM_NETWORK)
			FSM_TEST_LOGIC ("WAIT")
			FSM_PROFILE_SECTION_OUT (state3_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 0, state0_enter_exec, ;, "FROM_TRANSPORT", "", "WAIT", "ENCAP", " ", "ip_encap_v4_tst [WAIT -> ENCAP : FROM_TRANSPORT / ]")
				FSM_CASE_TRANSIT (1, 2, state2_enter_exec, ;, "FROM_NETWORK", "", "WAIT", "DECAP", " ", "ip_encap_v4_tst [WAIT -> DECAP : FROM_NETWORK / ]")
				}
				/*---------------------------------------------------------*/



			/** state (STRM_DEMUX) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "STRM_DEMUX", state4_enter_exec, "ip_encap_v4_tst [STRM_DEMUX enter execs]")
				FSM_PROFILE_SECTION_IN ("ip_encap_v4_tst [STRM_DEMUX enter execs]", state4_enter_exec)
				{
				/* Declarations must always be present at the top of the block.	*/
				
				Objid 				own_objid, own_node_objid, neighbor_mod_objid;
				List				proc_record_handle_list;
				int					record_handle_list_size, i;
				OmsT_Pr_Handle		process_record_handle;
				char				protocol_name [64];
				int					input_strm, output_strm;
				Boolean				inet_address_supported;
				char				gateway_str [128];
				
				/** This state is used to find out which modules are		**/
				/** directly connected to ip_encap. The stream indices are	**/
				/** stored together with the protocol attributes for		**/
				/** demultiplexing different higher-layer protocols.		**/
				
				/* Find the object IDs for use in process discovery.		*/
				own_objid = op_id_self ();
				own_node_objid = op_topo_parent (own_objid);
				
				op_prg_list_init (&proc_record_handle_list);
				
				/* Search for neighbors using the process registry.  All 	*/
				/* neighbors must be registered.							*/
				oms_pr_process_discover (own_objid, &proc_record_handle_list, "node objid", OMSC_PR_OBJID, own_node_objid, OPC_NIL);
				
				record_handle_list_size = op_prg_list_size (&proc_record_handle_list);
				
				if (record_handle_list_size == 0)
					{
					/* An error should be created if no processes are		*/
					/* connected to ip_encap.								*/
					op_sim_end ("Error: no modules connected to ip_encap", "", "", "");
					}
				else
					{
					/** For all the directly connected networks, find the 	**/
					/** protocol, as well the input and output stream 		**/
					/** indices.											**/
					
					/* Create the interface information structure.			*/
					interface_table = (IpT_Encap_Interface **) op_prg_mem_alloc (record_handle_list_size * 
						sizeof (IpT_Encap_Interface *));
					
					/* If the ip_encap module is not directly connected to	*/
					/* the ip module, the stream indices for the 			*/
					/* intermediate must be 0.  If ip is a neighbor, the 	*/
					/* correct stream indices will be used.					*/
					instrm_from_network = 0;
					outstrm_to_network = 0;
					
					/* Maintain a count of the number of records in the		*/
					/* interface table.										*/
					interface_table_size = 0;
				
					/* Loop through the discovered processes, adding the	*/
					/* interface records to the list.						*/
					for (i = 0; i < record_handle_list_size; ++i)
						{
						process_record_handle = (OmsT_Pr_Handle) op_prg_list_remove (&proc_record_handle_list, OPC_LISTPOS_HEAD);
					
						/* Obtain the module object id of the neighboring	*/
						/* module, and the value of the protocol attribute. */
				        oms_pr_attr_get (process_record_handle, "module objid", OMSC_PR_OBJID, &neighbor_mod_objid);
				
						/* There is a possibility that the record returned	*/
						/* by process registry may correspond to processes	*/
						/* registered without the "protocol" attribute (an	*/
						/* example is the case when child process(es) of	*/
						/* the OSPF protocol register -- these records do 	*/
						/* _not_ register any "protocol" attribute.)		*/
				        if (oms_pr_attr_get (process_record_handle, "protocol", OMSC_PR_STRING, protocol_name) == OPC_COMPCODE_SUCCESS)
							{
							/* Determine the input and output stream indices.	*/
							oms_tan_neighbor_streams_find (own_objid, neighbor_mod_objid, &input_strm, &output_strm);
				
							if (strcmp (protocol_name, "ip") == 0)
								{
								/* This is the ip module in this node,  It does	*/
								/* not need to be added to the interface table,	*/
								/* but it's stream indices should be stored.	*/
								instrm_from_network = input_strm;
								outstrm_to_network = output_strm;
								
								/* Check if IP process model has registered "gateway node"	*/
								/* attribute in its process registry						*/
								gateway = (oms_pr_attr_get (process_record_handle, "gateway node", OMSC_PR_STRING, gateway_str, OPC_NIL)
									== OPC_COMPCODE_SUCCESS) ? OPC_TRUE : OPC_FALSE;					
								}
							else
								{
								/* Store the upper layer module information in	*/
								/* an interface table. 							*/
								/* Allocate memory for the interface element.	*/
								interface_table [interface_table_size] = (IpT_Encap_Interface *) op_prg_mem_alloc (sizeof (IpT_Encap_Interface));
				
								/* Store the protocol number and the			*/
								/* corresponding stream indices into the		*/
								/* interface table.								*/
								interface_table [interface_table_size]->protocol_type = ip_higher_layer_proto_id_find
									(protocol_name, &inet_address_supported);
								interface_table [interface_table_size]->outstream = output_strm;
								interface_table [interface_table_size]->instream = input_strm;
								interface_table [interface_table_size]->inet_address_supported = inet_address_supported;
								
								/* Maintain a count of the number of records in	*/
								/* the interface table.							*/
								interface_table_size++;
								}
							}
						}
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (STRM_DEMUX) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "STRM_DEMUX", "ip_encap_v4_tst [STRM_DEMUX exit execs]")


			/** state (STRM_DEMUX) transition processing **/
			FSM_PROFILE_SECTION_IN ("ip_encap_v4_tst [STRM_DEMUX trans conditions]", state4_trans_conds)
			FSM_INIT_COND (FROM_NETWORK)
			FSM_TEST_COND (FROM_TRANSPORT)
			FSM_TEST_LOGIC ("STRM_DEMUX")
			FSM_PROFILE_SECTION_OUT (state4_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "FROM_NETWORK", "", "STRM_DEMUX", "DECAP", "tr_27", "ip_encap_v4_tst [STRM_DEMUX -> DECAP : FROM_NETWORK / ]")
				FSM_CASE_TRANSIT (1, 0, state0_enter_exec, ;, "FROM_TRANSPORT", "", "STRM_DEMUX", "ENCAP", "tr_28", "ip_encap_v4_tst [STRM_DEMUX -> ENCAP : FROM_TRANSPORT / ]")
				}
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (1,"ip_encap_v4_tst")
		}
	}




void
_op_ip_encap_v4_tst_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
#if defined (OPD_ALLOW_ODB)
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = __LINE__+1;
#endif

	FIN_MT (_op_ip_encap_v4_tst_diag ())

	if (1)
		{
		/* Temporary Variables */
		
		/* End of Temporary Variables */

		/* Diagnostic Block */

		BINIT
		{
		
		}

		/* End of Diagnostic Block */

		}

	FOUT
#endif /* OPD_ALLOW_ODB */
	}




void
_op_ip_encap_v4_tst_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_ip_encap_v4_tst_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (pr_state_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_ip_encap_v4_tst_svar function. */
#undef interface_table
#undef interface_table_size
#undef instrm_from_network
#undef outstrm_to_network
#undef gateway

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_ip_encap_v4_tst_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_ip_encap_v4_tst_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (ip_encap_v4_tst)",
		sizeof (ip_encap_v4_tst_state));
	*init_block_ptr = 2;

	FRET (obtype)
	}

VosT_Address
_op_ip_encap_v4_tst_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	ip_encap_v4_tst_state * ptr;
	FIN_MT (_op_ip_encap_v4_tst_alloc (obtype))

	ptr = (ip_encap_v4_tst_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "ip_encap_v4_tst [INIT enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_ip_encap_v4_tst_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	ip_encap_v4_tst_state		*prs_ptr;

	FIN_MT (_op_ip_encap_v4_tst_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (ip_encap_v4_tst_state *)gen_ptr;

	if (strcmp ("interface_table" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->interface_table);
		FOUT
		}
	if (strcmp ("interface_table_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->interface_table_size);
		FOUT
		}
	if (strcmp ("instrm_from_network" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->instrm_from_network);
		FOUT
		}
	if (strcmp ("outstrm_to_network" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->outstrm_to_network);
		FOUT
		}
	if (strcmp ("gateway" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->gateway);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

