/* Process model C form file: wban_tcp_client_trail.pr.c */
/* Portions of this file copyright 2014 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from wban_tcp_client_trail.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char wban_tcp_client_trail_pr_c [] = "MIL_3_Tfile_Hdr_ 1800 30A modeler 7 56E5B55C 56E5B55C 1 volta chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 468d 2                                                                                                                                                                                                                                                                                                                                                                                                           ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

#include "ip_addr_v4.h"
#include "tcp_api_v3.h"
#include <stdio.h>
#include <bgp.h>
#include <tcp_v3.h>
#include <string.h>
//#include "1508_lab3_real_payload_support.h"

/*	Define constants used in the process model.			*/
#define	TCP_LAB_GEN_CONN_OPEN		100
#define	TCP_LAB_GEN_CONN_CLOSE		200
#define TCP_LAB_GEN_PK_CREATE		300
#define TCP_STRM_IN 				1
#define TCP_STRM_OUT 				0

/*	State transition macro definitions.					*/
#define	TCP_CONN_OPEN			((op_intrpt_type () == OPC_INTRPT_SELF) && \
							 (op_intrpt_code () == TCP_LAB_GEN_CONN_OPEN))

#define CONN_ESTABLISHED	((intrpt_type == OPC_INTRPT_REMOTE) &&	\
							 (status_ind == TCPC_IND_ESTAB))

#define PKT_SEND			((intrpt_type == OPC_INTRPT_SELF) && \
							 (intrpt_code == TCP_LAB_GEN_PK_CREATE))

#define	PKT_RECEIVE			((op_intrpt_type () == OPC_INTRPT_STRM) &&\
								(op_intrpt_code () == TCP_STRM_OUT))

#define	CONN_RELEASE		((op_intrpt_type () == OPC_INTRPT_SELF) && \
							 (op_intrpt_code () == TCP_LAB_GEN_CONN_CLOSE))

#define PKT_RCV_ZGB 		((op_intrpt_type () == OPC_INTRPT_STRM) && \
								(op_intrpt_code () == TCP_STRM_IN))

/* TCP event codes */
//#define CONN_OPEN 					0
#define CONN_ESTAB					1
#define SEND						2
#define RECEIVE						3
#define RCV_ZGB						4
#define RELEASE						5


void						client_active_transport_conn_open (void* PRG_ARG_UNUSED (state_ptr), int PRG_ARG_UNUSED (code));
static void 				bgp_neighbor_processes_create ();
static void 				tcp_lab_app_send_actual_packet ();

//const char *server_addr[] = {"192.0.0.21", "192.0.0.29", "192.0.0.37","192.0.0.29", "192.0.0.37","192.0.0.29", "192.0.0.37","192.0.0.29", "192.0.0.37","192.0.0.29", "192.0.0.37"};
//const char *server_addr[] = {"192.0.0.18", "192.0.0.18", "192.0.0.18","192.0.0.29", "192.0.0.33","192.0.0.29", "192.0.0.33","192.0.0.29", "192.0.0.33","192.0.0.29", "192.0.0.33"};
//const char *server_addr[] = {"192.0.0.25", "192.0.0.25", "192.0.0.25","192.0.0.29.", "192.0.0.33","192.0.0.29", "192.0.0.33","192.0.0.29", "192.0.0.33","192.0.0.29", "192.0.0.33"};
//const char *server_addr[] = { "192.0.0.2", "192.0.0.2","192.0.0.2", "192.0.0.17","192.0.0.17", "192.0.0.17","192.0.0.17", "192.0.0.17","192.0.0.2", "192.0.0.17"};
//const char *server_addr[] = {"192.16.5.97","192.0.0.21"};
//const char *server_addr[] = {"192.0.0.17", "192.0.0.17", "192.0.0.17","192.0.0.25", "192.0.0.29","192.0.0.25", "192.0.0.29","192.0.0.25", "192.0.0.29","192.0.0.25", "192.0.0.29"};
//const char *server_addr[] = {"192.0.0.17", "192.0.0.17", "192.0.0.17","192.0.0.30", "192.0.0.34","192.0.0.30", "192.0.0.34","192.0.0.30", "192.0.0.34","192.0.0.30", "192.0.0.34"};

//const char *srvr_addr[] = {"192.0.0.22", "192.0.0.34", "192.0.0.37"};
//const char *srvr_addr[] = {"192.0.0.18", "192.0.0.29", "192.0.0.33"};
//const char *srvr_addr[] = {"192.0.0.25", "192.0.0.29", "192.0.0.33"};
//const char *srvr_addr[] = {"192.0.0.17", "192.0.0.25", "192.0.0.29"};
const char *srvr_addr[] = {"192.0.0.17", "192.0.0.30", "192.0.0.34"};


static int  bgp_connection_info_from_rem_addr_get (char* remote_address);
static void ip_addr_family_params_objid_get (Objid parent_objid);

typedef struct{
	char rem_ip_addr[25];
	int rem_port;
	int loc_port;
}ip_addr_arr;



/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		my_id                                           ;
	TcpT_Port	              		local_port                                      ;
	TcpT_Port	              		remote_port                                     ;
	InetT_Address	          		remote_inet_ip_addr                             ;
	ApiT_Tcp_App_Handle	    		tcp_app_handle                                  ;
	int	                    		connect_id                                      ;
	InetT_Address	          		inet_address                                    ;
	TcpT_Conn_Open_Options	 		conn_options                                    ;
	InetT_Address	          		local_inet_ip_addr                              ;
	Ici*	                   		command_ici_ptr                                 ;
	Ici*	                   		tcp_open_ind_ici_ptr                            ;
	FILE*	                  		pFile                                           ;
	int	                    		stream_count                                    ;
	int	                    		child_count                                     ;
	Prohandle*	             		child_proc                                      ;
	int	                    		event                                           ;
	List*	                  		bgp_connections_list_ptr                        ;
	char	                   		bgp_error_str[256]                              ;
	TcpT_Event*	            		ev_ptr                                          ;
	int	                    		next_avail_peer_id                              ;
	int	                    		num_pkts                                        ;
	Objid	                  		parent_id                                       ;
	double	                 		start_time                                      ;
	Packet *	               		pkptr                                           ;
	InetT_Address	          		rem_addr                                        ;
	InetT_Address	          		loc_addr                                        ;
	Objid	                  		ip_params_attr_id                               ;
	ip_addr_arr	            		ip_addr[3]                                      ;
	int	                    		count                                           ;
	char	                   		ip_addr_str[25]                                 ;
	int	                    		local_key                                       ;
	} wban_tcp_client_trail_state;

#define pr_state_ptr            		((wban_tcp_client_trail_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))
#define my_id                   		pr_state_ptr->my_id
#define local_port              		pr_state_ptr->local_port
#define remote_port             		pr_state_ptr->remote_port
#define remote_inet_ip_addr     		pr_state_ptr->remote_inet_ip_addr
#define tcp_app_handle          		pr_state_ptr->tcp_app_handle
#define connect_id              		pr_state_ptr->connect_id
#define inet_address            		pr_state_ptr->inet_address
#define conn_options            		pr_state_ptr->conn_options
#define local_inet_ip_addr      		pr_state_ptr->local_inet_ip_addr
#define command_ici_ptr         		pr_state_ptr->command_ici_ptr
#define tcp_open_ind_ici_ptr    		pr_state_ptr->tcp_open_ind_ici_ptr
#define pFile                   		pr_state_ptr->pFile
#define stream_count            		pr_state_ptr->stream_count
#define child_count             		pr_state_ptr->child_count
#define child_proc              		pr_state_ptr->child_proc
#define event                   		pr_state_ptr->event
#define bgp_connections_list_ptr		pr_state_ptr->bgp_connections_list_ptr
#define bgp_error_str           		pr_state_ptr->bgp_error_str
#define ev_ptr                  		pr_state_ptr->ev_ptr
#define next_avail_peer_id      		pr_state_ptr->next_avail_peer_id
#define num_pkts                		pr_state_ptr->num_pkts
#define parent_id               		pr_state_ptr->parent_id
#define start_time              		pr_state_ptr->start_time
#define pkptr                   		pr_state_ptr->pkptr
#define rem_addr                		pr_state_ptr->rem_addr
#define loc_addr                		pr_state_ptr->loc_addr
#define ip_params_attr_id       		pr_state_ptr->ip_params_attr_id
#define ip_addr                 		pr_state_ptr->ip_addr
#define count                   		pr_state_ptr->count
#define ip_addr_str             		pr_state_ptr->ip_addr_str
#define local_key               		pr_state_ptr->local_key

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wban_tcp_client_trail_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wban_tcp_client_trail_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

void
client_active_transport_conn_open (void* PRG_ARG_UNUSED (state_ptr), int PRG_ARG_UNUSED (code))
	{
	
	char temp_addr_str[25];
	/** This function will open a passive tcp connection to listen to 	**/
	/** port  	waiting for other neighbors to initiate a tcp open.	**/
	
	FIN (client_active_transport_conn_open (state_ptr, code))
		
	/* This interrupt indicates that an OPEN command should	*/ 
	/* be issued to the TCP Layer to open a connection. 	*/
		
	/* Populate the given options structure with the 		*/
	/* default ones.										*/
//	tcp_conn_open_default_options_set (&conn_options);
	
//	tcp_conn_open_options_local_port_set (&conn_options, TCPC_BGP_RESERVED_PORT);
	
	tcp_conn_open_default_options_set (&conn_options);
	tcp_conn_open_options_local_port_set (&conn_options, local_port);
//	tcp_conn_open_options_local_port_set(&conn_options, local_port);//TCPC_BGP_RESERVED_PORT);
	
	/* No need to use copy of address. A copy will be   	*/
	/* created by tcp_connection_open_with_options ().		*/
    tcp_conn_open_options_local_addr_set (&conn_options, local_inet_ip_addr); 
		

	/* Open a TCP connection between the client and the 	*/
	/* server. The struct conn_options also contains the	*/
	/* pointers to the callback functions for serialization */
	/* and deserialization.									*/
	connect_id = tcp_connection_open_with_options (&tcp_app_handle, remote_inet_ip_addr, 
		remote_port, TCPC_COMMAND_OPEN_ACTIVE, &conn_options);
		
	/*	Generate trace messsage								*/
	if (op_prg_odb_ltrace_active ("tcp"))
		{
		op_prg_odb_print_major ("client: TCP Active Open", OPC_NIL);
		}
		
	inet_address_print(temp_addr_str, remote_inet_ip_addr);
	printf("Opened active connection for remote_inet_ip_addr : %s remote port : %d connect id : %d\n", temp_addr_str, remote_port, connect_id);

	FOUT;
	}

static BgpT_Conn_Info* 
bgp_connection_info_from_conn_id_get (int tcp_conn_id)
	{
	BgpT_Conn_Info*	ith_bgp_conn_info_ptr;
	int				num_bgp_connections;
	int				count_i;

	/** This fucnction will parse through the entire list of available 	**/
	/** connections and returns a reference to the neighbor process		**/
	/** whose TCP connection ID matches the given tcp_conn_id.			**/
	FIN (bgp_connection_info_from_conn_id_get (tcp_conn_id))

	/* Obtain the number of the connections present. 					*/
	num_bgp_connections = op_prg_list_size (bgp_connections_list_ptr);

	/* Scan through the list of available neighbor processes.			*/
	for (count_i = 0; count_i < num_bgp_connections; count_i++)
		{
		ith_bgp_conn_info_ptr = (BgpT_Conn_Info*) op_prg_list_access (bgp_connections_list_ptr, count_i);

		/* Having obtained the connection information, check to see if 	*/
		/* the tcp_conn_id of this connection matches the given conn_id */
		if (ith_bgp_conn_info_ptr->tcp_connection_id == tcp_conn_id)
			{
			/* We found a match. Return the	connection information. 	*/
			FRET (ith_bgp_conn_info_ptr);
			}

		/* Continue to search the entire list till a matching process	*/
		/* can be obtained.												*/
		}

	/* A corresponding BGP connection could not be found. Return NULL 	*/
	FRET (OPC_NIL);
	}

static void
bgp_fatal_error (const char* msg_str)
    {
    /** An error is termed fatal if the simulation simply   **/
    /** cannot progress after encountering the error. Most  **/
    /** of the fatal errors occur when it is unable to      **/
    /** allocate memory.                                    **/
    FIN (bgp_fatal_error (char* msg_str))
 
    op_sim_end (bgp_error_str, msg_str, 
		"Please refer to the simulation log for details", 
		OPC_NIL);
 
    FOUT;
    }

static BgpT_Conn_Info*
bgp_ptc_mem_create (InetT_Address remote_addr, ApiT_Tcp_App_Handle tcp_intf_hndl)
	{
	BgpT_Conn_Info*					bgp_conn_info_ptr;
	char*							dest_addr_str;

	/** This function creates a parent child shared memory block and 	**/
	/** fills in the given details and returns a reference.  			**/
	FIN (bgp_ptc_mem_create (remote_addr, tcp_passive_process_hndl));
		
	/* Allocate memory for the new parent child memory block.			*/
	bgp_conn_info_ptr = (BgpT_Conn_Info*) op_prg_mem_alloc (sizeof (BgpT_Conn_Info));
	

	/* Set the value of the remote address and the TCP interface handle */
	/* passed in as arguments.											*/
	//bgp_conn_info_ptr->neighbor_ip_address 	= inet_address_copy (remote_addr);

	bgp_conn_info_ptr->neighbor_ip_address 	= inet_address_copy (remote_addr);
	bgp_conn_info_ptr->update_source_addr  = inet_address_copy (INETC_ADDRESS_INVALID);	


	/* Intialize all other memebers of this data structure.				*/
	
	bgp_conn_info_ptr->tcp_connection_id 	= TCPC_CONN_ID_UNSPEC;
	bgp_conn_info_ptr->tcp_intf_handle		= tcp_intf_hndl;
	
	bgp_conn_info_ptr->peer_id = ++next_avail_peer_id;

	bgp_conn_info_ptr->flags = 0;
	printf("created memory bgp conn info\n");

	FRET (bgp_conn_info_ptr);
	}



static void
bgp_neighbor_processes_create ()
	{
	BgpT_Conn_Info		*bgp_conn_info_ptr;
	int					neighbor_count;
	int					count_i;
	char				 description_str [256];
	InetT_Address		remote_address;
    char			   	update_source_str [256];
	InetT_Address		update_source_addr;



	/** This function reads the entries of the BGP Neighbor	information	**/
	/** compound attribute and spawns a BGP connection process for each **/
	/** of its configured neighbours.									**/
	FIN (bgp_neighbor_processes_create (TcpT_Event* ev_ptr));


	neighbor_count = 2;
	
	/* Scan through the entries and spawn a connection process for each */
	/* of these entries.												*/ 
	for (count_i = 0; count_i < neighbor_count; count_i++)
		{
				
		/****************************************************************/
		/* ADDRESS 														*/					
		/****************************************************************/
		
//		strcpy(ip_addr_str, server_addr[count_i]);
		printf("IP address dtr : %s \n", ip_addr_str);
		/* Create an IP address in the internal representation format.	*/
		remote_address = inet_address_create (ip_addr_str, InetC_Addr_Family_Unknown);
			
		
		/* Allocate memory for the information that will be shared 	*/
		/* between this process (bgp) and the child (bgp_conn).  	*/
		bgp_conn_info_ptr = bgp_ptc_mem_create (remote_address,  tcp_app_handle);

		
//		ev_ptr->event = CONN_OPEN;
//			printf("OPEN ID indicator : %d\n", ev_ptr->event);
			bgp_conn_info_ptr->bgp_connection_prohandle = op_pro_create ("wban_tcp_server_trail", bgp_conn_info_ptr);
			op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, OPC_NIL);
		
	
	printf("Child process invoke success \n");
		
		/* The conn_info data structure will be inserted into the	*/
		/* list connection information of all the BGP connections 	*/
		/* maintained by this bgp process. Any time a message comes */
		/* in from the lower layer this information will be used to	*/
		/* find out the connection process to which the message is	*/
		/* intended and will be delivered.							*/
		op_prg_list_insert (bgp_connections_list_ptr, bgp_conn_info_ptr, OPC_LISTPOS_HEAD);

		} /* End all neighbors on this node	*/

	FOUT;
	}

/******************************************************************/
/* Search the connection id based on remote address from the list */
/******************************************************************/
static int
bgp_connection_info_from_rem_addr_get (char* remote_address)
	{
	BgpT_Conn_Info*	ith_bgp_conn_info_ptr;
	int				num_bgp_connections;
	int				count_i;
	char			dest_addr_str[25];

	/** This fucnction will parse through the entire list of available 	**/
	/** connections and returns a reference to the neighbor process		**/
	/** whose TCP connection ID matches the given tcp_conn_id.			**/
	FIN (bgp_connection_info_from_rem_addr_get (remote_address))

	/* Obtain the number of the connections present. 					*/
	num_bgp_connections = op_prg_list_size (bgp_connections_list_ptr);
	
	printf("Number of bgp connections : %d\n", num_bgp_connections);

	/* Scan through the list of available neighbor processes.			*/
	for (count_i = 0; count_i < num_bgp_connections; count_i++)
		{
		ith_bgp_conn_info_ptr = (BgpT_Conn_Info*) op_prg_list_access (bgp_connections_list_ptr, count_i);
		
		printf("TCP conn id : %d\n", ith_bgp_conn_info_ptr->tcp_connection_id);
		
		inet_address_print(dest_addr_str, ith_bgp_conn_info_ptr->neighbor_ip_address);
		printf("Dest addr str in Conn id list: %s\n", dest_addr_str);

		/* Having obtained the connection information, check to see if 	*/
		/* the tcp_conn_id of this connection matches the given conn_id */
		if (strcmp(dest_addr_str,remote_address) == 0)
			{
			/* We found a match. Return the	connection information. 	*/
			FRET (ith_bgp_conn_info_ptr->tcp_connection_id);
			}

		/* Continue to search the entire list till a matching process	*/
		/* can be obtained.												*/
		}

	/* A corresponding BGP connection could not be found. Return NULL 	*/
	FRET (OPC_NIL);
	}

static void
ip_addr_family_params_objid_get (Objid parent_objid)
	{
	
	int rem_port, loc_port;
	Objid		af_params_cattr_id,af_params_row_id;
	int			num_addr_families, row_index;
	char		rem_ip_addr [64];
	
	FIN (bgp_addr_family_params_objid_get ());

	op_ima_obj_attr_get_objid (parent_objid, "Interface Information", &af_params_cattr_id);
	num_addr_families = op_topo_child_count (af_params_cattr_id, OPC_OBJTYPE_GENERIC);

	for (row_index = 0; row_index < num_addr_families; row_index++)
		{
		af_params_row_id = op_topo_child (af_params_cattr_id, OPC_OBJTYPE_GENERIC, row_index);
		
		op_ima_obj_attr_get_str (af_params_row_id, "Remote IP address", 64, ip_addr[row_index].rem_ip_addr);
		op_ima_obj_attr_get_int32 (af_params_row_id, "Rem Port", &ip_addr[row_index].rem_port);
		op_ima_obj_attr_get_int32 (af_params_row_id, "Loc Port", &ip_addr[row_index].loc_port);
		printf("REmote IP Address : %s ---- Remort Port : %d ---- Local Port : %d\n", ip_addr[row_index].rem_ip_addr, ip_addr[row_index].rem_port, ip_addr[row_index].loc_port);  
		
		}

FOUT;
	}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void wban_tcp_client_trail (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_wban_tcp_client_trail_init (int * init_block_ptr);
	void _op_wban_tcp_client_trail_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_wban_tcp_client_trail_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_wban_tcp_client_trail_alloc (VosT_Obtype, int);
	void _op_wban_tcp_client_trail_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
wban_tcp_client_trail (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wban_tcp_client_trail ());

		{
		/* Temporary Variables */
		//Packet*			pkptr;
		int				intrpt_type;
		int				intrpt_code;
		int				tcp_conn_id;
		int 			conn_id;
		OpT_uInt32		incoming_payload;
		char 			msg0[256];
		/* Holds the return value from searching the list of  bgp connections.	*/
		BgpT_Conn_Info* 	bgp_conn_info_ptr;
		Ici*				transport_ici_ptr;
		Ici* 				zigbee_ici_ptr;
		
		InetT_Address		remote_addr, *remote_addr_ptr;
		static Pmohandle	ev_pmh;
		//char				ip_addr_str[25];
		int 				status_ind;
		Ici*				status_iciptr;
		char				remote_addr_str[25];
		int 				nodeID;
		double 				pay_load;
		char* 				dest_address_str;
		char 				server_addr_str[25];
		//volatile int count = 0;
		/* End of Temporary Variables */


		FSM_ENTER ("wban_tcp_client_trail")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (INIT) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (0, "INIT", "wban_tcp_client_trail [INIT enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [INIT enter execs]", state0_enter_exec)
				{
				/*	Obtain the object ID of this process' surrounding module.	*/
				my_id = op_id_self ();
				
				count = 0;
				local_key = 0;
				
				/* obtain object ID of the parent object (node) */
				parent_id = op_topo_parent (my_id);
				
				
				/* Set appropriately the local and the  remote port.			*/
				//local_port = 1024;
				//remote_port = 1026;
				
				
				//op_ima_obj_attr_get (my_id, "Application", &ip_params_attr_id);
				//ip_params_attr_id = op_topo_child (ip_params_attr_id, OPC_OBJTYPE_GENERIC, 0);
				
				
				ip_addr_family_params_objid_get (parent_id);
				
				
				/* Create the inet IP address 									*/
				
				/* Read the parameters of Remote Address,Remote Port */	
							
				op_ima_obj_attr_get (parent_id, "Remote IP Address", ip_addr_str);
				//op_ima_obj_attr_get (parent_id, "Remote Port", &remote_port);
				op_ima_obj_attr_get (parent_id, "Application Start Time", &start_time);
				
				//printf("start time :%f  Remote port : %d \n", start_time, ip_addr_str, remote_port);
				
				
				/*	Schedule the start of operation.							*/
				op_intrpt_schedule_self (op_sim_time ()+start_time, TCP_LAB_GEN_CONN_OPEN);
				
				local_inet_ip_addr = inet_address_from_ipv4_address_create (ip_address_create (ip_addr_str));
				printf("Counter : %d\n", count);
				/* Create the IP address										*/
				remote_inet_ip_addr = inet_address_from_ipv4_address_create (ip_address_create (ip_addr[count].rem_ip_addr)); 
				remote_port = ip_addr[count].rem_port;
				local_port = ip_addr[count].loc_port;
				printf("My IP address : %s *** REmote IP Address : %s **** Remort Port : %d **** Local Port : %d\n", ip_addr_str, ip_addr[count].rem_ip_addr, ip_addr[count].rem_port, ip_addr[count].loc_port);  
				
				count++;
				
				//inet_address_print(ip_addr_str, remote_inet_ip_addr);
				//printf("AT start remote IP address : %s\n", ip_addr_str);
				
				loc_addr = inet_address_copy(local_inet_ip_addr);//inet_address_from_ipv4_address_create(ip_address_create(ip_addr_str));
				
				
				
				/* This application must register itself with the TCP API.  The	*/
				/* API handle will be used on all subsequent calls to the API.	*/
				tcp_app_handle = tcp_app_register (my_id);
				
				
				ev_pmh = op_prg_pmo_define ("wban_tcp_client_trail_child event", sizeof (TcpT_Event), 16);
				
				
				/*	Without memory to hold the event, this model will be disabled.	*/
				ev_ptr = (TcpT_Event *) op_prg_pmo_alloc (ev_pmh);
				
				
				//ev_ptr = (TcpT_Event *) op_prg_mem_alloc(sizeof(TcpT_Event));
				
				next_avail_peer_id = 0;
				
				/* Open the output file in which we will add the contents of 	*/
				/* received application packets.								*/
				//pFile = fopen ("C:\\op_models\\1508_lab3_server_output.txt", "w"); 
				
				/*if (!pFile)
					{
					op_sim_end ("Output file could not be opened.", "", "", "");
					} */
				
				/* Count input streams */
				//stream_count = op_topo_assoc_count (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STRM);
				//stream_count = 10;
				//printf("Stream count : %d\n", stream_count);
				
				/* Allocate array for child process handles */
				//child_proc = (Prohandle *) op_prg_mem_alloc (stream_count * sizeof (Prohandle));
				
				/* Create child process(es) */
				//for (int i = 0; i < stream_count; i++)
				//	{
					/* #1A */
				//	child_proc[i] = op_pro_create("wban_tcp_server_trail", OPC_NIL);
					/* #2A */
				//	}
				//op_intrpt_schedule_self(op_sim_time(), TCP_LAB_GEN_CONN_OPEN);
				
				/* Create the list for BGP peer process maintained from this node. 	*/
					/* This list is referred to whenever a packet reaches the dispatch. */
					bgp_connections_list_ptr = op_prg_list_create ();
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"wban_tcp_client_trail")


			/** state (INIT) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "INIT", "wban_tcp_client_trail [INIT exit execs]")


			/** state (INIT) transition processing **/
			FSM_TRANSIT_ONLY ((TCP_CONN_OPEN), 1, state1_enter_exec, ;, INIT, "TCP_CONN_OPEN", "", "INIT", "CREATE_CONN", "tr_121", "wban_tcp_client_trail [INIT -> CREATE_CONN : TCP_CONN_OPEN / ]")
				/*---------------------------------------------------------*/



			/** state (CREATE_CONN) enter executives **/
			FSM_STATE_ENTER_FORCED (1, "CREATE_CONN", state1_enter_exec, "wban_tcp_client_trail [CREATE_CONN enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [CREATE_CONN enter execs]", state1_enter_exec)
				{
				/* Open a active TCP connection that would be listening on the port 	*/
																
				client_active_transport_conn_open (OPC_NIL, OPC_NIL);
				
				//ev_ptr->event = CONN_OPEN;
				
				
				//bgp_neighbor_processes_create();
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** state (CREATE_CONN) exit executives **/
			FSM_STATE_EXIT_FORCED (1, "CREATE_CONN", "wban_tcp_client_trail [CREATE_CONN exit execs]")


			/** state (CREATE_CONN) transition processing **/
			FSM_TRANSIT_FORCE (5, state5_enter_exec, ;, "default", "", "CREATE_CONN", "idle", "tr_122", "wban_tcp_client_trail [CREATE_CONN -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (RECEIVE) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "RECEIVE", state2_enter_exec, "wban_tcp_client_trail [RECEIVE enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [RECEIVE enter execs]", state2_enter_exec)
				{
				if (PKT_RECEIVE)
					{
					
					
				printf("---PACKET SERVER RECEIVE PARENT--- \n");
				/* ev_ptr is 2 for Receive) */
				//op_pro_invoke(child_proc[i], event);
					
					/* Block specific variables.											*/
				BgpT_Tcp_Conn_Status	tcp_conn_status;
				
				
				/* Obtain the ICI accompanying the interrupt.							*/
				transport_ici_ptr = op_intrpt_ici ();
				
				if (transport_ici_ptr == OPC_NIL)
					{
					op_sim_end ("Unable to obtain ICI associated with the interrupt",
								OPC_NIL, OPC_NIL, OPC_NIL);
					}
				
				/* Get the connection ID from the received ICI.							*/
				op_ici_attr_get (transport_ici_ptr, "conn_id", &tcp_conn_id);
				op_ici_attr_get (transport_ici_ptr, "status",  &tcp_conn_status);
				
				/* Get the bgp connection details with the transport connection ID.		*/
				bgp_conn_info_ptr = (BgpT_Conn_Info*) bgp_connection_info_from_conn_id_get (tcp_conn_id);
				
				if (bgp_conn_info_ptr == OPC_NIL)
					{
					/* If a link or node goes down, we might continue to get TCP		*/
					/* Until TCP is properly fixed, just ignore them.					*/
					/*bgp_fatal_error ("In Open Confirm. Unable to map the tcp conn id to a bgp conn process");*/
					}
				else
				    {
					/* Invoke the connection.*/
					ev_ptr->event = RECEIVE;
					op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, ev_ptr);
					}
					
				/* Also destroy the ICI from the TCP layer.							*/
				//op_ici_destroy (transport_ici_ptr);
					}
				
				
				
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (RECEIVE) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "RECEIVE", "wban_tcp_client_trail [RECEIVE exit execs]")


			/** state (RECEIVE) transition processing **/
			FSM_TRANSIT_FORCE (5, state5_enter_exec, ;, "default", "", "RECEIVE", "idle", "tr_71", "wban_tcp_client_trail [RECEIVE -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (RELEASE) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "RELEASE", state3_enter_exec, "wban_tcp_client_trail [RELEASE enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [RELEASE enter execs]", state3_enter_exec)
				{
				if (CONN_RELEASE)
					{
					printf("------CONNECTION RELEASE CLIENT---- \n");
				/* Block specific variables.											*/
				BgpT_Tcp_Conn_Status	tcp_conn_status;
				
				/* Obtain the ICI accompanying the interrupt.							*/
				transport_ici_ptr = op_intrpt_ici ();
				
				if (transport_ici_ptr == OPC_NIL)
					{
					op_sim_end ("Unable to obtain ICI associated with the interrupt",
								OPC_NIL, OPC_NIL, OPC_NIL);
					}
				
				/* Get the connection ID from the received ICI.							*/
				op_ici_attr_get (transport_ici_ptr, "conn_id", &tcp_conn_id);
				op_ici_attr_get (transport_ici_ptr, "status",  &tcp_conn_status);
				
				/* Get the bgp connection details with the transport connection ID.		*/
				bgp_conn_info_ptr = (BgpT_Conn_Info*) bgp_connection_info_from_conn_id_get (tcp_conn_id);
				
				if (bgp_conn_info_ptr == OPC_NIL)
					{
					/* If a link or node goes down, we might continue to get TCP		*/
					/* Until TCP is properly fixed, just ignore them.					*/
					/*bgp_fatal_error ("In Open Confirm. Unable to map the tcp conn id to a bgp conn process");*/
					}
				else
				    {
					/* Invoke the connection.*/
					ev_ptr->event = RELEASE;
					op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, ev_ptr);
					}
					
				/* Also destroy the ICI from the TCP layer.							*/
				op_ici_destroy (transport_ici_ptr);
					}
				//op_pro_invoke(child_proc[0], event);
				/* ev_ptr is 3 for Release) */
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (RELEASE) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "RELEASE", "wban_tcp_client_trail [RELEASE exit execs]")


			/** state (RELEASE) transition processing **/
			FSM_TRANSIT_FORCE (5, state5_enter_exec, ;, "default", "", "RELEASE", "idle", "tr_67", "wban_tcp_client_trail [RELEASE -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (SEND) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "SEND", state4_enter_exec, "wban_tcp_client_trail [SEND enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [SEND enter execs]", state4_enter_exec)
				{
				if (PKT_RECEIVE)
					{
					
				printf("---PACKET SERVER RECEIVE PARENT--- \n");
				/* ev_ptr is 2 for Receive) */
				//op_pro_invoke(child_proc[i], event);
					
					/* Block specific variables.											*/
				BgpT_Tcp_Conn_Status	tcp_conn_status;
				
				
				/* Obtain the ICI accompanying the interrupt.							*/
				transport_ici_ptr = op_intrpt_ici ();
				
				if (transport_ici_ptr == OPC_NIL)
					{
					op_sim_end ("Unable to obtain ICI associated with the interrupt",
								OPC_NIL, OPC_NIL, OPC_NIL);
					}
				
				/* Get the connection ID from the received ICI.							*/
				op_ici_attr_get (transport_ici_ptr, "conn_id", &tcp_conn_id);
				op_ici_attr_get (transport_ici_ptr, "status",  &tcp_conn_status);
				
				/* Get the bgp connection details with the transport connection ID.		*/
				bgp_conn_info_ptr = (BgpT_Conn_Info*) bgp_connection_info_from_conn_id_get (tcp_conn_id);
				
				if (bgp_conn_info_ptr == OPC_NIL)
					{
					/* If a link or node goes down, we might continue to get TCP		*/
					/* Until TCP is properly fixed, just ignore them.					*/
					/*bgp_fatal_error ("In Open Confirm. Unable to map the tcp conn id to a bgp conn process");*/
					}
				else
				    {
					/* Invoke the connection.*/
					ev_ptr->event = SEND;
					op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, ev_ptr);
					}
					
				/* Also destroy the ICI from the TCP layer.							*/
				//op_ici_destroy (transport_ici_ptr);
					}
				
				
				
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (SEND) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "SEND", "wban_tcp_client_trail [SEND exit execs]")


			/** state (SEND) transition processing **/
			FSM_TRANSIT_FORCE (5, state5_enter_exec, ;, "default", "", "SEND", "idle", "tr_102", "wban_tcp_client_trail [SEND -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (5, "idle", state5_enter_exec, "wban_tcp_client_trail [idle enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [idle enter execs]", state5_enter_exec)
				{
				printf("Waiting in idle \n");
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (11,"wban_tcp_client_trail")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (5, "idle", "wban_tcp_client_trail [idle exit execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [idle exit execs]", state5_exit_exec)
				{
				/*	Determine the Interrupt Type and Interrupt Code.	*/
				/*	This is used to determine state transitions and		*/
				/*	process model logic.								*/
				printf("Exiting idle \n");
				intrpt_type = op_intrpt_type ();
				intrpt_code = op_intrpt_code ();
				
				if(intrpt_type == OPC_INTRPT_REMOTE)
					{
				status_iciptr = op_intrpt_ici ();
				op_ici_attr_get(status_iciptr, "conn_id", &tcp_conn_id);
				op_ici_attr_get (status_iciptr, "status", &status_ind);
				printf("conn id : %d \n", tcp_conn_id);
				//conn_id = tcp_conn_id;
				printf("Connection call from server to client \n");
				op_ici_print(status_iciptr);
					/*	Generate trace messsage							*/
					if (status_ind == TCPC_IND_ESTAB && op_prg_odb_ltrace_active ("tcp"))
						{
						op_prg_odb_print_major ("Received ESTAB indication in OPEN state, proceeding to DATA state.", OPC_NIL);
						}
					
				}
				}
				FSM_PROFILE_SECTION_OUT (state5_exit_exec)


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [idle trans conditions]", state5_trans_conds)
			FSM_INIT_COND (PKT_RECEIVE)
			FSM_TEST_COND (CONN_RELEASE)
			FSM_TEST_COND (PKT_SEND)
			FSM_TEST_COND (CONN_ESTABLISHED)
			FSM_TEST_COND (PKT_RCV_ZGB)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state5_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "PKT_RECEIVE", "", "idle", "RECEIVE", "tr_70", "wban_tcp_client_trail [idle -> RECEIVE : PKT_RECEIVE / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "CONN_RELEASE", "", "idle", "RELEASE", "tr_30", "wban_tcp_client_trail [idle -> RELEASE : CONN_RELEASE / ]")
				FSM_CASE_TRANSIT (2, 4, state4_enter_exec, ;, "PKT_SEND", "", "idle", "SEND", "tr_101", "wban_tcp_client_trail [idle -> SEND : PKT_SEND / ]")
				FSM_CASE_TRANSIT (3, 6, state6_enter_exec, ;, "CONN_ESTABLISHED", "", "idle", "ESTAB", "tr_104", "wban_tcp_client_trail [idle -> ESTAB : CONN_ESTABLISHED / ]")
				FSM_CASE_TRANSIT (4, 7, state7_enter_exec, ;, "PKT_RCV_ZGB", "", "idle", "RCV_ZGB", "tr_72", "wban_tcp_client_trail [idle -> RCV_ZGB : PKT_RCV_ZGB / ]")
				FSM_CASE_TRANSIT (5, 5, state5_enter_exec, ;, "default", "", "idle", "idle", "tr_124", "wban_tcp_client_trail [idle -> idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (ESTAB) enter executives **/
			FSM_STATE_ENTER_FORCED (6, "ESTAB", state6_enter_exec, "wban_tcp_client_trail [ESTAB enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [ESTAB enter execs]", state6_enter_exec)
				{
				/** Handles an indication from the TCP layer about a peer that is	**/
				/** attempting to establish connection with this BGP process. On	**/
				/** receipt of an OPEN Indication from a peer BGP process the local	**/
				/** system has to verify if it should accept the request or deny it	**/
				
				printf("connection established client interrupt ...calling child \n");
				
				/* The connection established signal from the TCP Layer */
				/* is in the form of a REMOTE interrupt with an 		*/
				/* associated ICI. The status field of the ICI 			*/
				/* indicates the call status.							*/
				/* Determine the Interrupt Type and Interrupt Code.		*/
				/* This is used to determine state transitions and		*/
				/* process model logic.									*/
				
				
					remote_addr = inet_address_copy (remote_inet_ip_addr);
					
					/* Scan through the connections list and find out if there exists a	*/
					/* connection that has the given remote addr as its neighbor addr.	*/
					//bgp_conn_info_ptr = bgp_connection_info_from_conn_id_get (tcp_conn_id);
					bgp_conn_info_ptr = bgp_connection_info_from_conn_id_get (tcp_conn_id);
					printf("Client connect id: %d\n", tcp_conn_id);
					
					if (bgp_conn_info_ptr == OPC_NIL)
				    	{
						/* Open up a new connection with this connection ID.        */
							bgp_conn_info_ptr = bgp_ptc_mem_create (remote_addr, tcp_app_handle);
						
							
							/* Fill in the connection ID as we have this information.	*/
							bgp_conn_info_ptr->tcp_connection_id = tcp_conn_id;
						
							/* Set the flag to indicate that this connection was 		*/
							/* initiated by the neighbor.								*/
							//bgp_conn_info_ptr->locally_initiated = OPC_FALSE;
						
							/* Create and invoke the new connection.                   	*/
							ev_ptr->event = CONN_ESTAB;
							printf("OPEN ID indicator client: %d\n", ev_ptr->event);
							bgp_conn_info_ptr->bgp_connection_prohandle = op_pro_create ("wban_tcp_client_trail_child", bgp_conn_info_ptr);
							op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, ev_ptr);
							
							printf("Indicated CONN_ESTAB to child : %d\n", ev_ptr->event );
						
							/* Insert the new connection into the list.                	*/
							op_prg_list_insert (bgp_connections_list_ptr, bgp_conn_info_ptr, OPC_LISTPOS_TAIL);
							
							printf("My IP address : %s *** REmote IP Address : %s **** Remort Port : %d **** Local Port : %d\n", ip_addr_str, ip_addr[count].rem_ip_addr, ip_addr[count].rem_port, ip_addr[count].loc_port);  
						
							//strcpy(ip_addr_str, server_addr[count++]);
							//printf("Counter : %d\n", count++);
							strcpy(remote_addr_str,ip_addr[count].rem_ip_addr);
							printf("IP address  in series at client str : %s \n", remote_addr_str);
							/* Create the IP address										*/
				//			remote_inet_ip_addr = inet_address_from_ipv4_address_create (ip_address_create (remote_addr));
							remote_inet_ip_addr =  inet_address_from_ipv4_address_create(ip_address_create (remote_addr_str));
							
							remote_port = ip_addr[count].rem_port;
							local_port = ip_addr[count].loc_port;
							
							count++;
						
						/* Create an IP address in the internal representation format.	*/
						//remote_inet_ip_addr = inet_address_create (ip_addr_str, InetC_Addr_Family_Unknown);
							
							
							
							/* Schedule an procedure interrupt for the next active 	*/
							/* transport connection.									*/
							op_intrpt_schedule_call (op_sim_time (), 0, client_active_transport_conn_open, OPC_NIL);
							
							/* Indicate that the call can be accepted by TCP.			*/
							//op_ici_attr_set (tcp_open_ind_ici_ptr, "accept status", TCPC_IND_CONNXN_ACCEPT);
							}
						else
							{
							/* Remote source not present in our neighbor list. This	*/
							/* is not allowed. Reject the connection.				*/
							
								/* Create and invoke the new connection.                   	*/
							
							printf("Pointer is not NIL \n");
							//ev_ptr->event = OPEN_IND;
							//printf("OPEN ID indicator : %d\n", OPEN_IND);
				
							//op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, ev_ptr);
							
							//printf("Indicated OPEN_IND to child : %d\n", bgp_conn_info_ptr->tcp_connection_id);
							//op_ici_attr_set (tcp_open_ind_ici_ptr, "accept status", TCPC_IND_CONNXN_REJECT);
							
							/* Print out a log message indicating that such 		*/
							/* connections are not supported in real world and in	*/
							/* OPNET.												*/
							//bgp_unmatched_connection_request_received_warn (bgp_my_node_objid, remote_addr);
							}
						
							
				    	
				}
				FSM_PROFILE_SECTION_OUT (state6_enter_exec)

			/** state (ESTAB) exit executives **/
			FSM_STATE_EXIT_FORCED (6, "ESTAB", "wban_tcp_client_trail [ESTAB exit execs]")


			/** state (ESTAB) transition processing **/
			FSM_TRANSIT_FORCE (5, state5_enter_exec, ;, "default", "", "ESTAB", "idle", "tr_103", "wban_tcp_client_trail [ESTAB -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (RCV_ZGB) enter executives **/
			FSM_STATE_ENTER_FORCED (7, "RCV_ZGB", state7_enter_exec, "wban_tcp_client_trail [RCV_ZGB enter execs]")
				FSM_PROFILE_SECTION_IN ("wban_tcp_client_trail [RCV_ZGB enter execs]", state7_enter_exec)
				{
				if (PKT_RCV_ZGB)
				{
					
				printf("---PACKET SERVER RECEIVE PARENT ZIGBEE--- \n");
				/* ev_ptr is 2 for Receive) */
				//op_pro_invoke(child_proc[i], event);
					
					/* Block specific variables.											*/
				BgpT_Tcp_Conn_Status	tcp_conn_status;
				
				
				/* Obtain the ICI accompanying the interrupt.							*/
				zigbee_ici_ptr = op_intrpt_ici ();
				
				if (zigbee_ici_ptr == OPC_NIL)
					{
					op_sim_end ("Unable to obtain ICI associated with the interrupt",
								OPC_NIL, OPC_NIL, OPC_NIL);
					}
				
				/* Get the connection ID from the received ICI.							*/
				op_ici_attr_get (zigbee_ici_ptr, "Dest Address", &dest_address_str);
				//op_ici_attr_get (transport_ici_ptr, "status",  &tcp_conn_status);
				
				
				//  op_ici_attr_set (transport_ici_ptr, "status", TCPC_EV_SEND);
				
				/* Obtain the ICI accompanying the interrupt.							*/
				//transport_ici_ptr = op_intrpt_ici ();
				
				//if (transport_ici_ptr == OPC_NIL)
				//	{
				//	op_sim_end ("Unable to obtain ICI associated with the interrupt",
				//				OPC_NIL, OPC_NIL, OPC_NIL);
				//	}
				
				/* Get the connection ID from the received ICI.							*/
				//op_ici_attr_get (transport_ici_ptr, "conn_id", &tcp_conn_id);
				//op_ici_attr_get (transport_ici_ptr, "status",  &tcp_conn_status);
				
				pkptr = op_pk_get(op_intrpt_strm());	
					//op_pk_nfd_get_int32 (pkptr,"nodeID", &nodeID);
					//op_pk_nfd_get_dbl (pkptr, "payload", &pay_load);
					//op_pk_nfd_get (pkptr, "Dest Address", &dest_address_str); 
				
				//printf("***********Payload at client trail ------------:dest address : %f %s\n", pay_load, dest_address_str);
				
				/*Get the connection id based on remote address by searching the list */
				
				if(strcmp(dest_address_str, "BROADCAST") == 0)
				{
				
					/*Get all the server addresses and invoke the child process for all of them */
					/* Get the bgp connection details with the transport connection ID.		*/
				
					for(int i = 0 ; i < 3; i++)
						{
				
							strcpy(server_addr_str, ip_addr[i].rem_ip_addr);
							printf("Server address string in PKT_RCV_ZIGBEE : %s\n", server_addr_str);
							
							tcp_conn_id =  bgp_connection_info_from_rem_addr_get (server_addr_str);
				
							//if(conn_id == tcp_conn_id)
							//	{
							printf("TCP Connection id : %d\n", tcp_conn_id);
				
							/* Get the bgp connection details with the transport connection ID.		*/
							bgp_conn_info_ptr = (BgpT_Conn_Info*) bgp_connection_info_from_conn_id_get (tcp_conn_id);
				
							if (bgp_conn_info_ptr == OPC_NIL)
								{
								/* If a link or node goes down, we might continue to get TCP		*/
								/* Until TCP is properly fixed, just ignore them.					*/
								/*bgp_fatal_error ("In Open Confirm. Unable to map the tcp conn id to a bgp conn process");*/
								}
							else
								{
								/* Invoke the connection.*/
					
								ev_ptr->event = RCV_ZGB;
								ev_ptr->pk_ptr = op_pk_copy(pkptr);
								transport_ici_ptr = op_ici_create("tcp_command_v3");
					
					
								rem_addr = inet_address_from_ipv4_address_create(ip_address_create(server_addr_str));//inet_address_copy(remote_inet_ip_addr);// ;
					
				
									//if(strcmp(server_addr_str,  ip_addr[i].rem_ip_addr) == 0)
									//	{
					
											//tcp_conn_id = 1;
								if(strcmp(server_addr_str, "192.0.0.17") == 0){
											op_ici_attr_set (transport_ici_ptr, "conn_id", 1); 
											op_ici_attr_set (transport_ici_ptr, "local_key", 0);
																		//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[i].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[i].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
											}
								   else if (strcmp(server_addr_str, "192.0.0.30") == 0){
									   op_ici_attr_set (transport_ici_ptr, "conn_id", 2); 
									   op_ici_attr_set (transport_ici_ptr, "local_key", 1);
									   							//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[i].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[i].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
									   }
								 else if (strcmp(server_addr_str, "192.0.0.34") == 0){
									   op_ici_attr_set (transport_ici_ptr, "conn_id", 3); 
									   op_ici_attr_set (transport_ici_ptr, "local_key", 2);
									   							//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[i].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[i].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
									   }
								else{
									op_ici_attr_set (transport_ici_ptr, "conn_id", 0); 
									op_ici_attr_set (transport_ici_ptr, "local_key", local_key);
																//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[i].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[i].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
									}
				
											
					
											op_ici_print(transport_ici_ptr);
											printf("Loc addr : %s \t\t rem addr : %s\n remote port %d \t\t local port : %d\n local_key : %d", ip_addr_str, server_addr_str, ip_addr[i].rem_port, ip_addr[i].loc_port, local_key);
				
											tcp_app_handle.tcp_ici_ptr = transport_ici_ptr;
											op_ici_install(tcp_app_handle.tcp_ici_ptr);
											
											//op_ici_install(transport_ici_ptr);
								
											//printf("Updated tcp conn id : %d\n", conn_id);
											
											tcp_data_send (tcp_app_handle, ev_ptr->pk_ptr);
				
											printf("ICI print to underlying modules \n");
											
											//op_ici_print(tcp_app_handle.tcp_ici_ptr);
											op_pk_print(ev_ptr->pk_ptr);
											//op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id);
											
											//tcp_app_handle.tcp_ici_ptr = transport_ici_ptr;
											
											tcp_receive_command_send (tcp_app_handle, 1);
								
											op_ici_install(OPC_NIL);
							//	local_key++;
											//tcp_conn_id++;
											//op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, ev_ptr);
					
									//		}
								}
							//tcp_app_handle_destroy(&tcp_app_handle);
							}
				}
				
				//}
				else
				{
				
					/* Get the bgp connection details with the transport connection ID.		*/
					tcp_conn_id =  bgp_connection_info_from_rem_addr_get (dest_address_str);
				
				
					printf("TCP Connection id : %d\n", tcp_conn_id);
					int Index;
				
					/* Get the bgp connection details with the transport connection ID.		*/
					bgp_conn_info_ptr = (BgpT_Conn_Info*) bgp_connection_info_from_conn_id_get (tcp_conn_id);
				
					//transport_ici_ptr = op_ici_create("tcp_status_ind");
					
					//op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id); 
				
					//op_ici_attr_get (transport_ici_ptr, "conn_id", tcp_conn_id); 
				
					printf("Updated TCP Connection id from interrupt : %d\n", tcp_conn_id);
				
					//op_ici_install(transport_ici_ptr);
				
					if (bgp_conn_info_ptr == OPC_NIL)
					{
						/* If a link or node goes down, we might continue to get TCP		*/
						/* Until TCP is properly fixed, just ignore them.					*/
						/*bgp_fatal_error ("In Open Confirm. Unable to map the tcp conn id to a bgp conn process");*/
					}
					else
				    {
						
								ev_ptr->event = RCV_ZGB;
								ev_ptr->pk_ptr = op_pk_copy(pkptr);
								transport_ici_ptr = op_ici_create("tcp_command_v3");
					
					
								rem_addr = inet_address_from_ipv4_address_create(ip_address_create(dest_address_str));//inet_address_copy(remote_inet_ip_addr);// ;
								
												if(strcmp(dest_address_str, "192.0.0.17") == 0){
											op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id); 
											op_ici_attr_set (transport_ici_ptr, "local_key", 0);
																		//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
											Index = 0;
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[Index].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[Index].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
											}
								   else if (strcmp(dest_address_str, "192.0.0.30") == 0){
									   op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id); 
									  op_ici_attr_set (transport_ici_ptr, "local_key", 1);
									   							//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
									   Index = 1;
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[Index].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[Index].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
									   }
								 else if (strcmp(dest_address_str, "192.0.0.34") == 0){
									   op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id);
									   Index = 2;
									  op_ici_attr_set (transport_ici_ptr, "local_key", 2);
									   							//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[Index].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[Index].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
									   }
								else{
									op_ici_attr_set (transport_ici_ptr, "conn_id", 0); 
									//op_ici_attr_set (transport_ici_ptr, "local_key", local_key);
									//Index = 0;
																//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
										//	op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[i].loc_port);
										//	op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
										//	op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[i].rem_port);
											//op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
									}
				
											
					
											op_ici_print(transport_ici_ptr);
											printf("Loc addr : %s \t\t rem addr : %s\n remote port %d \t\t local port : %d\n local_key : %d", ip_addr_str, server_addr_str, ip_addr[Index].rem_port, ip_addr[Index].loc_port, local_key);
				
											tcp_app_handle.tcp_ici_ptr = transport_ici_ptr;
											op_ici_install(tcp_app_handle.tcp_ici_ptr);
											
											//op_ici_install(transport_ici_ptr);
								
											//printf("Updated tcp conn id : %d\n", conn_id);
											
											tcp_data_send (tcp_app_handle, ev_ptr->pk_ptr);
				
											printf("ICI print to underlying modules \n");
											
											//op_ici_print(tcp_app_handle.tcp_ici_ptr);
											op_pk_print(ev_ptr->pk_ptr);
											//op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id);
											
											//tcp_app_handle.tcp_ici_ptr = transport_ici_ptr;
											
											tcp_receive_command_send (tcp_app_handle, 1);
								
											op_ici_install(OPC_NIL);		
								
						
								
								
								
								
								
								
								//if(strcmp(server_addr_str,  ip_addr[i].rem_ip_addr) == 0)
									//	{
					
											//tcp_conn_id = 1;
								
								
										/*	op_ici_attr_set (transport_ici_ptr, "conn_id", 0); 
											//op_ici_attr_set (transport_ici_ptr, "local_key", local_key);
																//op_ici_attr_set (transport_ici_ptr, "conn_id", 1);
											op_ici_attr_set (transport_ici_ptr, "local_port", ip_addr[i].loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
											op_ici_attr_set (transport_ici_ptr, "rem_port", ip_addr[i].rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
								
								
								
											op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id); 
				//							op_ici_attr_set (transport_ici_ptr, "local_port", loc_port);
											op_ici_attr_set (transport_ici_ptr, "rem_addr", inet_address_copy_dynamic (&rem_addr));
				//							op_ici_attr_set (transport_ici_ptr, "rem_port", rem_port);
											op_ici_attr_set (transport_ici_ptr, "local_addr", inet_address_copy_dynamic (&loc_addr));
					
											op_ici_print(transport_ici_ptr);
				//							printf("Loc addr : %s \t\t rem addr : %s\n remote port %d \t\t local port : %d\n", ip_addr_str, server_addr_str, ip_addr[i].rem_port, ip_addr[i].loc_port);
				
											tcp_app_handle.tcp_ici_ptr = transport_ici_ptr;
											//op_ici_install(tcp_app_handle.tcp_ici_ptr);
											
											//printf("Updated tcp conn id : %d\n", conn_id);
											
											tcp_data_send (tcp_app_handle, ev_ptr->pk_ptr);
				
											printf("ICI print to underlying modules \n");
											
											//op_ici_print(tcp_app_handle.tcp_ici_ptr);
											op_pk_print(ev_ptr->pk_ptr);
											//op_ici_attr_set (transport_ici_ptr, "conn_id", tcp_conn_id);
											
											tcp_app_handle.tcp_ici_ptr = transport_ici_ptr;
											
											tcp_receive_command_send (tcp_app_handle, 1);
											//op_pro_invoke (bgp_conn_info_ptr->bgp_connection_prohandle, ev_ptr); */
					
									//		}
				
					}
				}
					
				/* Also destroy the ICI from the TCP layer.							*/
				//op_ici_destroy (transport_ici_ptr);
				
				}
				
				
				
				}
				FSM_PROFILE_SECTION_OUT (state7_enter_exec)

			/** state (RCV_ZGB) exit executives **/
			FSM_STATE_EXIT_FORCED (7, "RCV_ZGB", "wban_tcp_client_trail [RCV_ZGB exit execs]")


			/** state (RCV_ZGB) transition processing **/
			FSM_TRANSIT_FORCE (5, state5_enter_exec, ;, "default", "", "RCV_ZGB", "idle", "tr_73", "wban_tcp_client_trail [RCV_ZGB -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"wban_tcp_client_trail")
		}
	}




void
_op_wban_tcp_client_trail_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_wban_tcp_client_trail_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_wban_tcp_client_trail_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (pr_state_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_wban_tcp_client_trail_svar function. */
#undef my_id
#undef local_port
#undef remote_port
#undef remote_inet_ip_addr
#undef tcp_app_handle
#undef connect_id
#undef inet_address
#undef conn_options
#undef local_inet_ip_addr
#undef command_ici_ptr
#undef tcp_open_ind_ici_ptr
#undef pFile
#undef stream_count
#undef child_count
#undef child_proc
#undef event
#undef bgp_connections_list_ptr
#undef bgp_error_str
#undef ev_ptr
#undef next_avail_peer_id
#undef num_pkts
#undef parent_id
#undef start_time
#undef pkptr
#undef rem_addr
#undef loc_addr
#undef ip_params_attr_id
#undef ip_addr
#undef count
#undef ip_addr_str
#undef local_key

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_wban_tcp_client_trail_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_wban_tcp_client_trail_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (wban_tcp_client_trail)",
		sizeof (wban_tcp_client_trail_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_wban_tcp_client_trail_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wban_tcp_client_trail_state * ptr;
	FIN_MT (_op_wban_tcp_client_trail_alloc (obtype))

	ptr = (wban_tcp_client_trail_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "wban_tcp_client_trail [INIT enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_wban_tcp_client_trail_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wban_tcp_client_trail_state		*prs_ptr;

	FIN_MT (_op_wban_tcp_client_trail_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wban_tcp_client_trail_state *)gen_ptr;

	if (strcmp ("my_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_id);
		FOUT
		}
	if (strcmp ("local_port" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->local_port);
		FOUT
		}
	if (strcmp ("remote_port" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->remote_port);
		FOUT
		}
	if (strcmp ("remote_inet_ip_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->remote_inet_ip_addr);
		FOUT
		}
	if (strcmp ("tcp_app_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->tcp_app_handle);
		FOUT
		}
	if (strcmp ("connect_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->connect_id);
		FOUT
		}
	if (strcmp ("inet_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->inet_address);
		FOUT
		}
	if (strcmp ("conn_options" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->conn_options);
		FOUT
		}
	if (strcmp ("local_inet_ip_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->local_inet_ip_addr);
		FOUT
		}
	if (strcmp ("command_ici_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->command_ici_ptr);
		FOUT
		}
	if (strcmp ("tcp_open_ind_ici_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->tcp_open_ind_ici_ptr);
		FOUT
		}
	if (strcmp ("pFile" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pFile);
		FOUT
		}
	if (strcmp ("stream_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->stream_count);
		FOUT
		}
	if (strcmp ("child_count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->child_count);
		FOUT
		}
	if (strcmp ("child_proc" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->child_proc);
		FOUT
		}
	if (strcmp ("event" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->event);
		FOUT
		}
	if (strcmp ("bgp_connections_list_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bgp_connections_list_ptr);
		FOUT
		}
	if (strcmp ("bgp_error_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->bgp_error_str);
		FOUT
		}
	if (strcmp ("ev_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ev_ptr);
		FOUT
		}
	if (strcmp ("next_avail_peer_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->next_avail_peer_id);
		FOUT
		}
	if (strcmp ("num_pkts" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->num_pkts);
		FOUT
		}
	if (strcmp ("parent_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->parent_id);
		FOUT
		}
	if (strcmp ("start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->start_time);
		FOUT
		}
	if (strcmp ("pkptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkptr);
		FOUT
		}
	if (strcmp ("rem_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rem_addr);
		FOUT
		}
	if (strcmp ("loc_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->loc_addr);
		FOUT
		}
	if (strcmp ("ip_params_attr_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ip_params_attr_id);
		FOUT
		}
	if (strcmp ("ip_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ip_addr);
		FOUT
		}
	if (strcmp ("count" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->count);
		FOUT
		}
	if (strcmp ("ip_addr_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->ip_addr_str);
		FOUT
		}
	if (strcmp ("local_key" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->local_key);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

