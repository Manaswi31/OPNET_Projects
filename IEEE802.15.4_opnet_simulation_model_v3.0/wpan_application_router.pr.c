/* Process model C form file: wpan_application_router.pr.c */
/* Portions of this file copyright 2013 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from wpan_application_router.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char wpan_application_router_pr_c [] = "MIL_3_Tfile_Hdr_ 175A 30A op_runsim_opt 7 54C6C04D 54C6C04D 1 e202f01 chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 3282 5                                                                                                                                                                                                                                                                                                                                                                                                   ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/* Include files					*/
/* Distribution Modeling sub-package*/

#include <oms_string_support.h>
#include <oms_dist_support.h>


#include <wpan_math1.h>
#include <wpan_struct1.h>
#include <wpan_params1.h>

/* Node configuration constants		*/


/* Special attribute values			*/

/* Interrupt code values			*/
#define	SC_SEND_BE	0
#define	SC_SEND_RT	1


/* Input and output streams		*/
#define	STRM_FROM_APPL_TO_NWK	0
#define	STRM_FROM_NWK_TO_APPL	0


/* State machine conditions 		*/
#define IAM_PAN_COORDINATOR 	(device_mode == PAN_COORDINATOR)
#define IAM_ROUTER 				(device_mode == ROUTER)
#define IAM_END_DEVICE 			(device_mode == END_DEVICE)

#define	SEND_BE			((intrpt_type == OPC_INTRPT_SELF) && (intrpt_code == SC_SEND_BE) && (dest_mac_address != my_address))
#define	SEND_RT			((intrpt_type == OPC_INTRPT_SELF) && (intrpt_code == SC_SEND_RT) && (dest_mac_address != my_address))
#define RECEIVE_PCK		(intrpt_type == OPC_INTRPT_STRM && intrpt_strm == STRM_FROM_NWK_TO_APPL)


/* Function prototypes.				*/
static void wpan_appl_init (void); 
static void wpan_print_parameters (void);
static void wpan_be_packet_generate (void);
static void wpan_rt_packet_generate (void);
static void wpan_receive_pck_from_nwk (void);
static int wpan_sequence_number(void); 
static void wpan_process_payload(void);
static int wpan_random_payload(void);

/* Global variables */
//int app_sent_msdu_bits = 0;
//int app_sent_msdu_nbr = 0;

//int payLoad[6] = {0};
int Index = 0;


int OUT_OF_NORMAL_DATA_BP = 1;
int OUT_OF_NORMAL_DATA_HR = 1;
int OUT_OF_NORMAL_DATA_SPO2= 1;
int OUT_OF_NORMAL_DATA_Temp = 1;
int OUT_OF_NORMAL_DATA_BS = 1;


typedef struct{

char nodeName[20];
int payLoad;

}fuzzyArray;

fuzzyArray fuzzyGroup[6];
fuzzyArray *fuzzyptr = fuzzyGroup; 





/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		self_id                                         ;
	Objid	                  		parent_id                                       ;
	int	                    		device_mode                                     ;
	char	                   		device_name[20]                                 ;
	int	                    		my_address                                      ;
	Boolean	                		enable_log                                      ;
	int	                    		intrpt_type                                     ;
	int	                    		intrpt_strm                                     ;
	int	                    		intrpt_code                                     ;
	OmsT_Dist_Handle	       		be_packet_interarrival_dist_ptr                 ;
	OmsT_Dist_Handle	       		be_packet_size_dist_ptr                         ;
	char	                   		be_packet_interarrival_dist_str[128]            ;
	char	                   		be_packet_size_dist_str[128]                    ;
	double	                 		be_start_time                                   ;
	double	                 		be_stop_time                                    ;
	Boolean	                		be_ack                                          ;
	OmsT_Dist_Handle	       		rt_packet_interarrival_dist_ptr                 ;
	OmsT_Dist_Handle	       		rt_packet_size_dist_ptr                         ;
	char	                   		rt_packet_interarrival_dist_str[128]            ;
	char	                   		rt_packet_size_dist_str[128]                    ;
	double	                 		rt_start_time                                   ;
	double	                 		rt_stop_time                                    ;
	Boolean	                		rt_ack                                          ;
	int	                    		dest_mac_address                                ;
	Stathandle	             		bits_rcvd_MSDU_be_stathandle                    ;
	Stathandle	             		bits_rcvd_MSDU_rt_stathandle                    ;
	Stathandle	             		bitssec_rcvd_MSDU_be_stathandle                 ;
	Stathandle	             		bits_rcvd_NSDU_be_stathandle                    ;
	Stathandle	             		bits_rcvd_NSDU_rt_stathandle                    ;
	Stathandle	             		bitssec_rcvd_NSDU_be_stathandle                 ;
	Stathandle	             		pkts_rcvd_be_stathandle                         ;
	Stathandle	             		pkts_rcvd_rt_stathandle                         ;
	Stathandle	             		pktssec_rcvd_be_stathandle                      ;
	Stathandle	             		pktssec_rcvd_rt_stathandle                      ;
	Stathandle	             		bits_sent_MSDU_be_stathandle                    ;
	Stathandle	             		bits_sent_MSDU_rt_stathandle                    ;
	Stathandle	             		bits_sent_NSDU_be_stathandle                    ;
	Stathandle	             		bits_sent_NSDU_rt_stathandle                    ;
	Stathandle	             		pkts_sent_be_stathandle                         ;
	Stathandle	             		pkts_sent_rt_stathandle                         ;
	Stathandle	             		ete_delay_be_stathandle                         ;
	Stathandle	             		ete_delay_rt_stathandle                         ;
	Stathandle	             		bits_rcvd_MSDU_be_gstathandle                   ;
	Stathandle	             		bits_rcvd_MSDU_rt_gstathandle                   ;
	Stathandle	             		bitssec_rcvd_gstathandle                        ;
	Stathandle	             		pkts_rcvd_be_gstathandle                        ;
	Stathandle	             		pkts_rcvd_rt_gstathandle                        ;
	Stathandle	             		pktssec_rcvd_gstathandle                        ;
	Stathandle	             		ete_delay_be_gstathandle                        ;
	Stathandle	             		ete_delay_rt_gstathandle                        ;
	Stathandle	             		bits_sent_MSDU_be_gstathandle                   ;
	Stathandle	             		bits_sent_MSDU_rt_gstathandle                   ;
	Stathandle	             		pkts_sent_be_gstathandle                        ;
	Stathandle	             		pkts_sent_rt_gstathandle                        ;
	int	                    		rt_generated_frames                             ;
	int	                    		be_generated_frames                             ;
	int	                    		pay_load                                        ;
	int	                    		sizeArray                                       ;
	} wpan_application_router_state;

#define self_id                 		op_sv_ptr->self_id
#define parent_id               		op_sv_ptr->parent_id
#define device_mode             		op_sv_ptr->device_mode
#define device_name             		op_sv_ptr->device_name
#define my_address              		op_sv_ptr->my_address
#define enable_log              		op_sv_ptr->enable_log
#define intrpt_type             		op_sv_ptr->intrpt_type
#define intrpt_strm             		op_sv_ptr->intrpt_strm
#define intrpt_code             		op_sv_ptr->intrpt_code
#define be_packet_interarrival_dist_ptr		op_sv_ptr->be_packet_interarrival_dist_ptr
#define be_packet_size_dist_ptr 		op_sv_ptr->be_packet_size_dist_ptr
#define be_packet_interarrival_dist_str		op_sv_ptr->be_packet_interarrival_dist_str
#define be_packet_size_dist_str 		op_sv_ptr->be_packet_size_dist_str
#define be_start_time           		op_sv_ptr->be_start_time
#define be_stop_time            		op_sv_ptr->be_stop_time
#define be_ack                  		op_sv_ptr->be_ack
#define rt_packet_interarrival_dist_ptr		op_sv_ptr->rt_packet_interarrival_dist_ptr
#define rt_packet_size_dist_ptr 		op_sv_ptr->rt_packet_size_dist_ptr
#define rt_packet_interarrival_dist_str		op_sv_ptr->rt_packet_interarrival_dist_str
#define rt_packet_size_dist_str 		op_sv_ptr->rt_packet_size_dist_str
#define rt_start_time           		op_sv_ptr->rt_start_time
#define rt_stop_time            		op_sv_ptr->rt_stop_time
#define rt_ack                  		op_sv_ptr->rt_ack
#define dest_mac_address        		op_sv_ptr->dest_mac_address
#define bits_rcvd_MSDU_be_stathandle		op_sv_ptr->bits_rcvd_MSDU_be_stathandle
#define bits_rcvd_MSDU_rt_stathandle		op_sv_ptr->bits_rcvd_MSDU_rt_stathandle
#define bitssec_rcvd_MSDU_be_stathandle		op_sv_ptr->bitssec_rcvd_MSDU_be_stathandle
#define bits_rcvd_NSDU_be_stathandle		op_sv_ptr->bits_rcvd_NSDU_be_stathandle
#define bits_rcvd_NSDU_rt_stathandle		op_sv_ptr->bits_rcvd_NSDU_rt_stathandle
#define bitssec_rcvd_NSDU_be_stathandle		op_sv_ptr->bitssec_rcvd_NSDU_be_stathandle
#define pkts_rcvd_be_stathandle 		op_sv_ptr->pkts_rcvd_be_stathandle
#define pkts_rcvd_rt_stathandle 		op_sv_ptr->pkts_rcvd_rt_stathandle
#define pktssec_rcvd_be_stathandle		op_sv_ptr->pktssec_rcvd_be_stathandle
#define pktssec_rcvd_rt_stathandle		op_sv_ptr->pktssec_rcvd_rt_stathandle
#define bits_sent_MSDU_be_stathandle		op_sv_ptr->bits_sent_MSDU_be_stathandle
#define bits_sent_MSDU_rt_stathandle		op_sv_ptr->bits_sent_MSDU_rt_stathandle
#define bits_sent_NSDU_be_stathandle		op_sv_ptr->bits_sent_NSDU_be_stathandle
#define bits_sent_NSDU_rt_stathandle		op_sv_ptr->bits_sent_NSDU_rt_stathandle
#define pkts_sent_be_stathandle 		op_sv_ptr->pkts_sent_be_stathandle
#define pkts_sent_rt_stathandle 		op_sv_ptr->pkts_sent_rt_stathandle
#define ete_delay_be_stathandle 		op_sv_ptr->ete_delay_be_stathandle
#define ete_delay_rt_stathandle 		op_sv_ptr->ete_delay_rt_stathandle
#define bits_rcvd_MSDU_be_gstathandle		op_sv_ptr->bits_rcvd_MSDU_be_gstathandle
#define bits_rcvd_MSDU_rt_gstathandle		op_sv_ptr->bits_rcvd_MSDU_rt_gstathandle
#define bitssec_rcvd_gstathandle		op_sv_ptr->bitssec_rcvd_gstathandle
#define pkts_rcvd_be_gstathandle		op_sv_ptr->pkts_rcvd_be_gstathandle
#define pkts_rcvd_rt_gstathandle		op_sv_ptr->pkts_rcvd_rt_gstathandle
#define pktssec_rcvd_gstathandle		op_sv_ptr->pktssec_rcvd_gstathandle
#define ete_delay_be_gstathandle		op_sv_ptr->ete_delay_be_gstathandle
#define ete_delay_rt_gstathandle		op_sv_ptr->ete_delay_rt_gstathandle
#define bits_sent_MSDU_be_gstathandle		op_sv_ptr->bits_sent_MSDU_be_gstathandle
#define bits_sent_MSDU_rt_gstathandle		op_sv_ptr->bits_sent_MSDU_rt_gstathandle
#define pkts_sent_be_gstathandle		op_sv_ptr->pkts_sent_be_gstathandle
#define pkts_sent_rt_gstathandle		op_sv_ptr->pkts_sent_rt_gstathandle
#define rt_generated_frames     		op_sv_ptr->rt_generated_frames
#define be_generated_frames     		op_sv_ptr->be_generated_frames
#define pay_load                		op_sv_ptr->pay_load
#define sizeArray               		op_sv_ptr->sizeArray

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wpan_application_router_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wpan_application_router_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/********************************************************************************* 
				IEEE 802.15.4/ZigBee OPNET Simulation Model
**********************************************************************************

Author: Petr Jurcik <petr@isep.ipp.pt> <jurcikp@control.felk.cvut.cz>
Author: Anis Koubaa <aska@isep.ipp.pt>

Organization:
	IPP-HURRAY Research Group
	CISTER/ISEP
	Polytechnic Institute of Porto, Portugal

Organization:
	Department of Control Engineering
	Faculty of Electrical Engineering
	Czech Technical University in Prague, Czech Republic
 
Copyright (c) 2007 - 2009 

This file is part of IEEE 802.15.4/ZigBee OPNET Simulation Model for OPNET Modeler. IEEE 802.15.4/ZigBee OPNET Simulation Model can be used, copied and modified under the next licenses:
 
 - GPL - GNU General Public License
 
Code can be modified and re-distributed under any combination of the above listed licenses. If a contributor does not agree with some of the licenses, he/she can delete appropriate line. If you delete all lines, you are not allowed to distribute source code and/or binaries utilizing code.


**********************************************************************************
                           GNU General Public License  

IEEE 802.15.4/ZigBee OPNET Simulation Model is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later version.
 
IEEE 802.15.4/ZigBee OPNET Simulation Model is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with IEEE 802.15.4/ZigBee OPNET Simulation Model; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 

*********************************************************************************/

/*--------------------------------------------------------------------------------
 * Function:	wpan_appl_init
 *
 * Description:	- initialize the process
 *				- read the values of attributes
 *              - schedule a self interrupts 
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_appl_init() {

	Objid traffic_id;
	Objid traffic_comp_id;	

	
	/* Stack tracing enrty point */
	FIN(wpan_appl_init);
	
	
	/* obtain self object ID of the surrounding processor or queue */
	self_id = op_id_self ();

	/* obtain object ID of the parent object (node) */
	parent_id = op_topo_parent (self_id);
	
	/* get the value to check if this node is PAN coordinator, Router, or End node */
	op_ima_obj_attr_get_int32 (parent_id, "Device Mode", &device_mode);
	
	/* get the name of the node */
	op_ima_obj_attr_get (parent_id, "name", device_name);
	
	op_ima_obj_attr_get (parent_id, "Enable Logging", &enable_log);
	
	/* get the MAC address of the node */
	op_ima_obj_attr_get (parent_id, "MAC Address", &my_address);
	
		/* get the MAC address of the node */
	//op_ima_obj_attr_get (parent_id, "pay load", &pay_load);
	
	
	/* Read the parameters of best-effort traffic */	
	op_ima_obj_attr_get (self_id, "Best-effort", &traffic_id);
	traffic_comp_id = op_topo_child (traffic_id, OPC_OBJTYPE_GENERIC, 0);
			
	op_ima_obj_attr_get_str (traffic_comp_id, "Packet Interarrival Time",128,	be_packet_interarrival_dist_str);
	
	op_ima_obj_attr_get_str (traffic_comp_id, "Packet Size", 128,             	be_packet_size_dist_str);
	op_ima_obj_attr_get (traffic_comp_id, "Start Time",							&be_start_time);
	op_ima_obj_attr_get (traffic_comp_id, "Stop Time",             				&be_stop_time);	
	op_ima_obj_attr_get (traffic_comp_id, "Acknowledgment",            			&be_ack);	
	
	/* Read the parameters of real-time traffic */	
	op_ima_obj_attr_get (self_id, "Real-time", &traffic_id);
	traffic_comp_id = op_topo_child (traffic_id, OPC_OBJTYPE_GENERIC, 0);
	
	op_ima_obj_attr_get_str (traffic_comp_id, "Packet Interarrival Time",128,	rt_packet_interarrival_dist_str);
	op_ima_obj_attr_get_str (traffic_comp_id, "Packet Size", 128,             	rt_packet_size_dist_str);
	op_ima_obj_attr_get (traffic_comp_id, "Start Time",							&rt_start_time);
	op_ima_obj_attr_get (traffic_comp_id, "Stop Time",             				&rt_stop_time);	
	op_ima_obj_attr_get (traffic_comp_id, "Acknowledgment",            			&rt_ack);
	
	/* get destination MAC address */
	op_ima_obj_attr_get (self_id, "Destination MAC Address", &dest_mac_address);	
	
	
	if (dest_mac_address == my_address) {
		be_start_time = START_DISABLED;
		rt_start_time = START_DISABLED;
	}
	
	/* if the destination MAC address is broadcast do not send acknowledged packets */
	if ((dest_mac_address == BROADCAST_ADDRESS) && (be_start_time != START_DISABLED) && (be_ack == OPC_TRUE)) {
		be_start_time = START_DISABLED;
		if (enable_log) {
			printf (" [%s (#%d)] The best-effort acknowledged data cannot be generated, since the Destination MAC Adddress is set to BROADCAST. \n", device_name, my_address);
		}
	}
	
	/* if the destination MAC address is broadcast do not send acknowledged packets */
	if ((dest_mac_address == BROADCAST_ADDRESS) && (rt_start_time != START_DISABLED) && (rt_ack == OPC_TRUE)) {
		rt_start_time = START_DISABLED;
		if (enable_log) {
			printf (" [%s (#%d)] The real-time acknowledged data cannot be generated, since the Destination MAC Adddress is set to BROADCAST. \n", device_name, my_address);
		}
	}
	
	rt_generated_frames = 0;
	be_generated_frames = 0;
	
	/* Load the PDFs that will be used in computing the Packet Interarrival Times and Packet Sizes. */

	be_packet_interarrival_dist_ptr = oms_dist_load_from_string (be_packet_interarrival_dist_str);
	be_packet_size_dist_ptr       = oms_dist_load_from_string (be_packet_size_dist_str);
	
	/* Load the PDFs that will be used in computing the Packet Interarrival Times and Packet Sizes. */
	rt_packet_interarrival_dist_ptr = oms_dist_load_from_string (rt_packet_interarrival_dist_str);
	rt_packet_size_dist_ptr       = oms_dist_load_from_string (rt_packet_size_dist_str);
	
	
	/* Make sure we have valid start and stop times, i.e. start time is before stop time.	*/
	if ((be_stop_time <= be_start_time) && (be_stop_time != END_OF_SIMULATION)) {
		/* stop time is before start time. Disable the source.	*/
		be_start_time = START_DISABLED;

		/* Display an appropriate warning.								*/
		op_prg_odb_print_major ("Warning from a Application model:", 
								"Although the best-effort generator is not disabled (start time is set to a finite value), stop time is before start time.",
								"Disabling the best-effort generator.", OPC_NIL);
	}
	
		/* Make sure we have valid start and stop times, i.e. start time is before stop time.	*/
	if ((rt_stop_time <= rt_start_time) && (rt_stop_time != END_OF_SIMULATION)) {
		/* stop time is before start time. Disable the source.	*/
		rt_start_time = START_DISABLED;

		/* Display an appropriate warning.								*/
		op_prg_odb_print_major ("Warning from a Application model:", 
								"Although the real-time generator is not disabled (start time is set to a finite value), stop time is before start time.",
								"Disabling the real-time generator.", OPC_NIL);
	} 
	
	/* Schedule a self interrupt.	*/
	if (be_start_time != START_DISABLED)
		op_intrpt_schedule_self (be_start_time, SC_SEND_BE);	
		
	if (rt_start_time != START_DISABLED)
		op_intrpt_schedule_self (rt_start_time, SC_SEND_RT);
	
	
	/* register the LOCAL statistics */
	bits_rcvd_MSDU_be_stathandle 	= op_stat_reg ("Application.Traffic Received - best-effort MSDU (bit)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bitssec_rcvd_MSDU_be_stathandle = op_stat_reg ("Application.Traffic Received - best-effort MSDU (bit/sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bits_rcvd_NSDU_be_stathandle 	= op_stat_reg ("Application.Traffic Received - best-effort NSDU (bit)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bitssec_rcvd_NSDU_be_stathandle = op_stat_reg ("Application.Traffic Received - best-effort NSDU (bit/sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);	
	pkts_rcvd_be_stathandle 		= op_stat_reg ("Application.Traffic Received - best-effort (packet)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	pktssec_rcvd_be_stathandle 		= op_stat_reg ("Application.Traffic Received - best-effort (packet/sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	bits_rcvd_MSDU_rt_stathandle 	= op_stat_reg ("Application.Traffic Received - real-time MSDU (bit)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bits_rcvd_NSDU_rt_stathandle 	= op_stat_reg ("Application.Traffic Received - real-time NSDU (bit)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	pkts_rcvd_rt_stathandle 		= op_stat_reg ("Application.Traffic Received - real-time (packet)",			OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	pktssec_rcvd_rt_stathandle 		= op_stat_reg ("Application.Traffic Received - real-time (packet/sec)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	ete_delay_be_stathandle			= op_stat_reg ("Application.End-to-End Delay - best-effort (sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	ete_delay_rt_stathandle			= op_stat_reg ("Application.End-to-End Delay - real-time (sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	bits_sent_MSDU_be_stathandle	= op_stat_reg ("Application.Traffic Sent - best-effort MSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bits_sent_MSDU_rt_stathandle	= op_stat_reg ("Application.Traffic Sent - real-time MSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bits_sent_NSDU_be_stathandle	= op_stat_reg ("Application.Traffic Sent - best-effort NSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	bits_sent_NSDU_rt_stathandle	= op_stat_reg ("Application.Traffic Sent - real-time NSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);	
	pkts_sent_be_stathandle			= op_stat_reg ("Application.Traffic Sent - best-effort (packet)",	OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	pkts_sent_rt_stathandle			= op_stat_reg ("Application.Traffic Sent - real-time (packet)",		OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	/* register the GLOBAL statistics */
	bits_rcvd_MSDU_be_gstathandle 	= op_stat_reg ("Application.Traffic Received - best-effort MSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	pkts_rcvd_be_gstathandle 		= op_stat_reg ("Application.Traffic Received - best-effort (packet)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	
	bits_rcvd_MSDU_rt_gstathandle 	= op_stat_reg ("Application.Traffic Received - real-time MSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	pkts_rcvd_rt_gstathandle 		= op_stat_reg ("Application.Traffic Received - real-time (packet)",		OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	
	bitssec_rcvd_gstathandle 		= op_stat_reg ("Application.Traffic Received (bit/sec)",			OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	pktssec_rcvd_gstathandle 		= op_stat_reg ("Application.Traffic Received (packet/sec)",			OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	
	ete_delay_be_gstathandle		= op_stat_reg ("Application.End-to-End Delay - best-effort (sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	ete_delay_rt_gstathandle		= op_stat_reg ("Application.End-to-End Delay - real-time (sec)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	
	bits_sent_MSDU_be_gstathandle	= op_stat_reg ("Application.Traffic Sent - best-effort MSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	bits_sent_MSDU_rt_gstathandle	= op_stat_reg ("Application.Traffic Sent - real-time MSDU (bit)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	pkts_sent_be_gstathandle		= op_stat_reg ("Application.Traffic Sent - best-effort (packet)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	pkts_sent_rt_gstathandle		= op_stat_reg ("Application.Traffic Sent - real-time (packet)",		OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
	
	if ((be_start_time != START_DISABLED) || (rt_start_time != START_DISABLED))
		wpan_print_parameters();
	
	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	 wpan_print_parameters
 *
 * Description:	print the parameters 
 *				
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_print_parameters() {

	/* Stack tracing enrty point */	
	FIN(wpan_print_parameters);

	if (enable_log) {
		printf ("|------------------------- APPLICATION TRAFFIC -------------------------------|\n", device_name, my_address);
		printf (" Node %s (#%d) \n", device_name, my_address);
		printf (" Best-effort traffic parameters:\n");
		printf ("\t Packet Interarival PDF : %s\n", be_packet_interarrival_dist_str);
		printf ("\t Packet Size PDF        : %s\n", be_packet_size_dist_str);
		
		if (be_start_time == -1) {
			printf ("\t Start time             : disabled \n");
		}
		else {
			printf ("\t Start time             : %f\n", be_start_time);
		}
		
		if (be_stop_time == -1) {
			printf ("\t Stop time              : end of simulation \n");
		}
		else {
			printf ("\t Stop time              : %f\n", be_stop_time);
		}
	}
		
		printf ("\t Acknowledgment	 	: %d\n", be_ack);
		
		printf (" real-time traffic parameters:\n");
		printf ("\t Packet Interarival PDF : %s\n", rt_packet_interarrival_dist_str);
		printf ("\t Packet Size PDF        : %s\n", rt_packet_size_dist_str);
		
		if (rt_start_time == -1) {
			printf ("\t Start time             : disabled \n");
		}
		else {
			printf ("\t Start time             : %f\n", rt_start_time);
		}
		
		if (rt_stop_time == -1) {
			printf ("\t Stop time              : end of simulation \n");
		}
		else {
			printf ("\t Stop time              : %f\n", rt_stop_time);
		}
		
		printf ("\t Acknowledgment	 	: %d\n", rt_ack);
		
		if (dest_mac_address == 0xFFFF) {
			printf (" Destination MAC Address : BROADCAST \n");
		}
		else {
			printf (" Destination MAC Address : #%d (%X hex)\n", dest_mac_address, dest_mac_address);
		}
		printf ("|-----------------------------------------------------------------------------|\n\n");
		
		
	
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_be_packet_generate
 *
 * Description:	Creates a best-effort packet (MSDU) based on the packet generation		 
 *				 specifications and sends it to the network layer.
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_be_packet_generate() {
	
	Ici* iciptr;
	Packet* packet_MSDU_ptr;
	Packet* packet_NSDU_ptr;
	int	nsdu_size; /* size in bits */
	int msdu_size;
	int header_size;
	int sequence_number;
	double next_intarr_time;	/*  interarrival time of next packet */
	double abs_next_intarr_time; /* absolute interarrival time of next packet */
	int nsdu_size_print;	


	/* Stack tracing enrty point */
	FIN (wpan_be_packet_generate);
	
	iciptr = op_ici_create ("wpan_packet_ici_format");
	op_ici_attr_set (iciptr, "ACK", be_ack);
	op_ici_attr_set (iciptr, "Traffic Type", BEST_EFFORT_TRAFFIC);
	
	/* create a MAC payload (MSDU) */
	packet_MSDU_ptr = op_pk_create_fmt ("wpan_frame_NPDU_format");
	
	sequence_number = wpan_sequence_number();
	
	/* set the fields of the beacon frame */
	op_pk_nfd_set (packet_MSDU_ptr, "Frame Type", NWK_DATA_FRAME_TYPE);
	op_pk_nfd_set (packet_MSDU_ptr, "Protocol Version", 2);
	op_pk_nfd_set (packet_MSDU_ptr, "Discover Route", SUPPRESS_ROUTE_DISCOVERY);
	op_pk_nfd_set (packet_MSDU_ptr, "Multicast Flag", 0); // unicast or broatcast	
	op_pk_nfd_set (packet_MSDU_ptr, "Security", 0);		// no NWK security
	op_pk_nfd_set (packet_MSDU_ptr, "Source Route", 0);	// source route subframe is not present	
	op_pk_nfd_set (packet_MSDU_ptr, "Destination IEEE Address", 0);
	op_pk_nfd_set (packet_MSDU_ptr, "Source IEEE Address", 0);	
	op_pk_nfd_set (packet_MSDU_ptr, "Destination Address", dest_mac_address);
	op_pk_nfd_set (packet_MSDU_ptr, "Source Address", my_address);	
	op_pk_nfd_set (packet_MSDU_ptr, "Radius", RADIUS);
	op_pk_nfd_set (packet_MSDU_ptr, "Sequence Number", sequence_number);
	
		
	/* Generate a NSDU size outcome	*/
	nsdu_size = (int) ceil (oms_dist_outcome (be_packet_size_dist_ptr));
	
	/* Size of the NWk header */ 
	header_size = (int) op_pk_total_size_get(packet_MSDU_ptr);
	
	
	/* 0 <= nsdu_size <= (aMaxMACSafePayloadSize_Octet*8-header_size) */
	if (nsdu_size > (aMaxMACSafePayloadSize_Octet*8-header_size))
		nsdu_size = (aMaxMACSafePayloadSize_Octet*8-header_size);	/* The size of generated NSDU is bigger than the maximum - the size is set to the maximum. */
		
	if (nsdu_size < 0)
		nsdu_size = 0;
	
	/* unformatted payload	*/
	packet_NSDU_ptr = op_pk_create_fmt ("wpan_payload");
	
	
		/* To count the number of packets in payLoad array */
	
	for(Index = 0; Index < 6 ; Index ++)
	{ 
		//fuzzyptr->nodeName = (char *)op_prg_mem_alloc(sizeof(char));
		printf("PayLoad values in set call : %d %s\n", fuzzyptr->payLoad, fuzzyptr->nodeName);
		fuzzyptr++;
	
	} 

	fuzzyptr = fuzzyGroup;
	op_pk_nfd_set(packet_NSDU_ptr,"payloadPacket",fuzzyptr,op_prg_mem_copy_create,op_prg_mem_free,6*sizeof(fuzzyArray));
	

	op_pk_nfd_set_pkt(packet_MSDU_ptr, "NSDU", packet_NSDU_ptr);
	
	
	
	/* send the MSDU via the stream to the network layer.	*/
	/* send ICI to network layer together with packet. */
	op_ici_install (iciptr);
	if(OUT_OF_NORMAL_DATA_BP | OUT_OF_NORMAL_DATA_HR | OUT_OF_NORMAL_DATA_SPO2| OUT_OF_NORMAL_DATA_Temp | OUT_OF_NORMAL_DATA_BS)
		op_pk_send (packet_MSDU_ptr, STRM_FROM_APPL_TO_NWK);
	op_ici_install (OPC_NIL);
	
	/* schedule next packet generation */
	
	if (prg_string_order_case_insensitive(device_name,"Blood Pressure") == 0){
		next_intarr_time = floor(op_dist_uniform (10));
		wpan_process_payload();
		}
	
	
	else if (prg_string_order_case_insensitive(device_name,"Heart Rate") == 0){
		next_intarr_time = floor(op_dist_uniform (5));
		wpan_process_payload();
		}
		
			
	else if (prg_string_order_case_insensitive(device_name, "SPO2") == 0){
		next_intarr_time= floor(op_dist_uniform (15));
		wpan_process_payload();
		}
		
	
	else if (prg_string_order_case_insensitive(device_name, "Temperature") == 0){
		next_intarr_time = floor(op_dist_uniform (50));
		wpan_process_payload();
		}
		
	else if (prg_string_order_case_insensitive(device_name, "Blood Sugar") == 0){
		next_intarr_time = floor(op_dist_uniform (35));
		wpan_process_payload();
		}
	


	//next_intarr_time = oms_dist_outcome (be_packet_interarrival_dist_ptr);
	//printf("Distribution : %s\n", be_packet_interarrival_dist_ptr);
		
		printf("next arrival time : %f device : %s\n", next_intarr_time, device_name);
	
	/* Make sure that interarrival time is not negative. In that case it will be set to 0. */
	if (next_intarr_time <0)
		next_intarr_time = 0.0;

	abs_next_intarr_time = op_sim_time () + next_intarr_time;
	
	if (enable_log) {
		printf (" [%s (#%d)] t=%f -> (APL) Best-effort packet's payload (MSDU size = %d bits, SEQ = %d) was generated and sent to Network layer \n", device_name, my_address, op_sim_time(), (int) op_pk_total_size_get(packet_MSDU_ptr), sequence_number);
	}
	
	if ((abs_next_intarr_time <= be_stop_time) || (be_stop_time == END_OF_SIMULATION)) {
		op_intrpt_schedule_self (abs_next_intarr_time, SC_SEND_BE);
		
		if (enable_log)
			printf ("\t (APL) Next best-effort packet's payload (MSDU) will be generated at %f sec.\n\n", abs_next_intarr_time);
	} else {
		if (enable_log)
			printf ("\t (APL) STOP best-effort packet's payload (MSDU) generation.\n\n", abs_next_intarr_time);
	}
	
	msdu_size = (int) op_pk_total_size_get (packet_MSDU_ptr);
	nsdu_size_print = (int) op_pk_total_size_get (packet_NSDU_ptr);
	
	
		
	/* Update the packet generation statistics.			*/
	op_stat_write (bits_sent_MSDU_be_stathandle, msdu_size);
	op_stat_write (bits_sent_NSDU_be_stathandle, nsdu_size);
	op_stat_write (pkts_sent_be_stathandle, 1.0);
	op_stat_write (bits_sent_MSDU_be_gstathandle, msdu_size);
	op_stat_write (pkts_sent_be_gstathandle, 1.0);
	
	be_generated_frames++;
		
	
	//app_sent_msdu_bits = app_sent_msdu_bits + (msdu_size/1000.0);	
	//app_sent_msdu_nbr = app_sent_msdu_nbr + 1;

		
	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_rt_packet_generate
 *
 * Description:	Creates a real-time packet (MSDU) based on the packet generation		
 *				 specifications and sends it to the network layer.
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_rt_packet_generate() {

	Ici* iciptr;
	Packet* packet_MSDU_ptr;
	Packet* packet_NSDU_ptr;
	int	nsdu_size; /* size in bits */
	int msdu_size;
	int header_size;
	int sequence_number;
	double next_intarr_time;	/*  interarrival time of next packet */
	double abs_next_intarr_time; /* absolute interarrival time of next packet */

	/* Stack tracing enrty point */
	FIN (wpan_rt_packet_generate);
	
	iciptr = op_ici_create ("wpan_packet_ici_format");
	op_ici_attr_set (iciptr, "ACK", rt_ack);
	op_ici_attr_set (iciptr, "Traffic Type", REAL_TIME_TRAFFIC);
	
	/* create a MAC payload (MSDU) */
	packet_MSDU_ptr = op_pk_create_fmt ("wpan_frame_NPDU_format");
	
	sequence_number = wpan_sequence_number();
	
	/* set the fields of the beacon frame */
	op_pk_nfd_set (packet_MSDU_ptr, "Frame Type", NWK_DATA_FRAME_TYPE);
	op_pk_nfd_set (packet_MSDU_ptr, "Protocol Version", 2);
	op_pk_nfd_set (packet_MSDU_ptr, "Discover Route", SUPPRESS_ROUTE_DISCOVERY);
	op_pk_nfd_set (packet_MSDU_ptr, "Multicast Flag", 0); // unicast or broatcast	
	op_pk_nfd_set (packet_MSDU_ptr, "Security", 0);		// no NWK security
	op_pk_nfd_set (packet_MSDU_ptr, "Source Route", 0);	// source route subframe is not present	
	op_pk_nfd_set (packet_MSDU_ptr, "Destination IEEE Address", 0);
	op_pk_nfd_set (packet_MSDU_ptr, "Source IEEE Address", 0);	
	op_pk_nfd_set (packet_MSDU_ptr, "Destination Address", dest_mac_address);
	op_pk_nfd_set (packet_MSDU_ptr, "Source Address", my_address);	
	op_pk_nfd_set (packet_MSDU_ptr, "Radius", RADIUS);
	op_pk_nfd_set (packet_MSDU_ptr, "Sequence Number", sequence_number);
	
	/* Generate a NSDU size outcome	*/
	nsdu_size = (int) ceil (oms_dist_outcome (rt_packet_size_dist_ptr));
	
	/* Size of the NWk header */ 
	header_size = (int) op_pk_total_size_get(packet_MSDU_ptr);
	
	
	/* 0 <= nsdu_size <= (aMaxMACSafePayloadSize_Octet*8-header_size) */
	if (nsdu_size > (aMaxMACSafePayloadSize_Octet*8-header_size))
		nsdu_size = (aMaxMACSafePayloadSize_Octet*8-header_size);	/* The size of generated NSDU is bigger than the maximum - the size is set to the maximum. */
		
	if (nsdu_size < 0)
		nsdu_size = 0;
	
	/* unformatted payload	*/
	packet_NSDU_ptr = op_pk_create_fmt ("wpan_payload");
	
	
		/* To count the number of packets in payLoad array */
	
	for(Index = 0; Index < 6 ; Index ++)
	{ 
		//fuzzyptr->nodeName = (char *)op_prg_mem_alloc(sizeof(char));
		printf("PayLoad values in set call : %d %s\n", fuzzyptr->payLoad, fuzzyptr->nodeName);
		fuzzyptr++;
	
	} 

	fuzzyptr = fuzzyGroup;
	op_pk_nfd_set(packet_NSDU_ptr,"payloadPacket",fuzzyptr,op_prg_mem_copy_create,op_prg_mem_free,6*sizeof(fuzzyArray));
	

	op_pk_nfd_set_pkt(packet_MSDU_ptr, "NSDU", packet_NSDU_ptr);
	
	
	
	/* send the MSDU via the stream to the network layer.	*/
	/* send ICI to network layer together with packet. */
	op_ici_install (iciptr);
	if(OUT_OF_NORMAL_DATA_BP | OUT_OF_NORMAL_DATA_HR | OUT_OF_NORMAL_DATA_SPO2| OUT_OF_NORMAL_DATA_Temp | OUT_OF_NORMAL_DATA_BS){
	printf("Packet sent to co-ordinator");
	
		op_pk_send (packet_MSDU_ptr, STRM_FROM_APPL_TO_NWK);
	
	}
	op_ici_install (OPC_NIL);
	
	/* schedule next packet generation */
	
	if (prg_string_order_case_insensitive(device_name,"Blood Pressure") == 0){
		next_intarr_time = floor(op_dist_uniform (10));
		wpan_process_payload();
		}
	
	
	else if (prg_string_order_case_insensitive(device_name,"Heart Rate") == 0){
		next_intarr_time = floor(op_dist_uniform (5));
		wpan_process_payload();
		}
		
			
	else if (prg_string_order_case_insensitive(device_name, "SPO2") == 0){
		next_intarr_time= floor(op_dist_uniform (15));
		wpan_process_payload();
		}
		
	
	else if (prg_string_order_case_insensitive(device_name, "Temperature") == 0){
		next_intarr_time = floor(op_dist_uniform (50));
		wpan_process_payload();
		}
		
	else if (prg_string_order_case_insensitive(device_name, "Blood Sugar") == 0){
		next_intarr_time = floor(op_dist_uniform (35));
		wpan_process_payload();
		}
	


	//next_intarr_time = oms_dist_outcome (be_packet_interarrival_dist_ptr);
	//printf("Distribution : %s\n", be_packet_interarrival_dist_ptr);
		
		printf("next arrival time : %f device : %s\n", next_intarr_time, device_name);
	
	
	/* unformatted payload	*/
//	packet_NSDU_ptr = op_pk_create (nsdu_size);
	
	
	
	if (enable_log) {
		printf (" [%s (#%d)] t=%f -> (APL) Real-time packet's payload (MSDU size = %d bits, SEQ = %d) was generated and sent to Network layer.\n", device_name, my_address, op_sim_time(), (int) op_pk_total_size_get(packet_MSDU_ptr), sequence_number);
	}
	
	/* schedule next packet generation */
	next_intarr_time = oms_dist_outcome (rt_packet_interarrival_dist_ptr);

	/* Make sure that interarrival time is not negative. In that case it will be set to 0. */
	if (next_intarr_time <0)
		next_intarr_time = 0.0;

	abs_next_intarr_time = op_sim_time () + next_intarr_time;
	
	if ((abs_next_intarr_time <= rt_stop_time) || (rt_stop_time == END_OF_SIMULATION)) {
		op_intrpt_schedule_self (abs_next_intarr_time, SC_SEND_RT);
		
		if (enable_log)
			printf ("\t (APL) Next real-time packet's payload (MSDU) will be generated at %f sec.\n\n", abs_next_intarr_time);
	} else {
		if (enable_log)
			printf ("\t (APL) STOP real-time packet's payload (MSDU) generation.\n\n", abs_next_intarr_time);
	}
	

	msdu_size = (int) op_pk_total_size_get (packet_MSDU_ptr);
	
	/* Update the packet generation statistics.			*/
	op_stat_write (bits_sent_MSDU_rt_stathandle, msdu_size);
	op_stat_write (bits_sent_NSDU_rt_stathandle, nsdu_size);
	op_stat_write (pkts_sent_rt_stathandle, 1.0);
	op_stat_write (bits_sent_MSDU_rt_gstathandle, msdu_size);	
	op_stat_write (pkts_sent_rt_gstathandle, 1.0);
	
	rt_generated_frames++;
	
	//app_sent_msdu_bits = app_sent_msdu_bits + (msdu_size/1000.0);	
	//app_sent_msdu_nbr = app_sent_msdu_nbr + 1;
	
	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_receive_pck_from_nwk
 *
 * Description:	Receive a packet's payload (MSDU) from NWK layer and update statistics.
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_receive_pck_from_nwk() {
	
	Ici* iciptr;
	Packet* packet_MSDU_ptr;
	Packet* packet_NSDU_ptr; /* payload */
	double packet_MSDU_size;
	double packet_NSDU_size; 
	double e2e_delay; 
	int source_nwk_address;
	int sequence_number;
	int traffic_type;

	/* Stack tracing enrty point */
	FIN(wpan_receive_packet);	
	
	/* get the ICI information */
	iciptr = op_intrpt_ici ();
	
	op_ici_attr_get (iciptr, "Traffic Type", &traffic_type);
	
	/* Get packet from the input stream  */
	packet_MSDU_ptr = op_pk_get (intrpt_strm);
	
	op_pk_nfd_get (packet_MSDU_ptr, "Source Address", &source_nwk_address);
	op_pk_nfd_get (packet_MSDU_ptr, "Sequence Number", &sequence_number);
	op_pk_nfd_get_pkt (packet_MSDU_ptr, "NSDU", &packet_NSDU_ptr);
	
	
	/* Caclulate metrics to be updated	*/
	packet_MSDU_size = (double) op_pk_total_size_get (packet_MSDU_ptr);
	packet_NSDU_size = (double) op_pk_total_size_get (packet_NSDU_ptr);
	e2e_delay = op_sim_time () - op_pk_creation_time_get (packet_MSDU_ptr);
	
	if (enable_log) {
		printf (" [%s (#%d)] t=%f -> (APL) Received packet's payload (MSDU) from Network layer. I am the destination. \n", device_name, my_address, op_sim_time());
		printf ("\t\t Source NWK Address  :	#%d \n", source_nwk_address);
		printf ("\t\t NWK Sequence Number :	%d \n", sequence_number);	
		printf ("\t\t End-to-end delay    : %f sec \n", e2e_delay);
		if (traffic_type == REAL_TIME_TRAFFIC) {
			printf ("\t\t Traffic type    : REAL_TIME_TRAFFIC \n\n");
		} else {
			printf ("\t\t Traffic type    : BEST_EFFORT_TRAFFIC \n\n");
		}		
	} 
	
	/* update the statistics */	
	if (traffic_type == REAL_TIME_TRAFFIC) {
		op_stat_write (ete_delay_rt_stathandle, 		e2e_delay);
		
		op_stat_write (bits_rcvd_MSDU_rt_stathandle, 	packet_MSDU_size);
		op_stat_write (bits_rcvd_NSDU_rt_stathandle, 	packet_NSDU_size);
		
		op_stat_write (pkts_rcvd_rt_stathandle, 		1.0);

		op_stat_write (pktssec_rcvd_rt_stathandle, 		1.0);
		op_stat_write (pktssec_rcvd_rt_stathandle, 		0.0);
		
		op_stat_write (ete_delay_rt_gstathandle, 		e2e_delay);
		
		op_stat_write (bits_rcvd_MSDU_rt_gstathandle, 	packet_MSDU_size);
		op_stat_write (pkts_rcvd_rt_gstathandle, 		1.0);
		
	
	} else { /* BEST_EFFORT_TRAFFIC */
		op_stat_write (ete_delay_be_stathandle, 		e2e_delay);
		
		op_stat_write (bits_rcvd_MSDU_be_stathandle, 	packet_MSDU_size);
		op_stat_write (bits_rcvd_NSDU_be_stathandle, 	packet_NSDU_size);
		
		op_stat_write (bitssec_rcvd_MSDU_be_stathandle, packet_MSDU_size);
		op_stat_write (bitssec_rcvd_MSDU_be_stathandle, 0.0);
		
		op_stat_write (bitssec_rcvd_NSDU_be_stathandle, packet_NSDU_size);
		op_stat_write (bitssec_rcvd_NSDU_be_stathandle, 0.0);
		
		op_stat_write (pkts_rcvd_be_stathandle, 		1.0);

		op_stat_write (pktssec_rcvd_be_stathandle, 		1.0);
		op_stat_write (pktssec_rcvd_be_stathandle, 		0.0);
		
		op_stat_write (ete_delay_be_gstathandle, 		e2e_delay);
		
		op_stat_write (bits_rcvd_MSDU_be_gstathandle, 	packet_MSDU_size);
		op_stat_write (pkts_rcvd_be_gstathandle, 		1.0);
	}
	
	op_stat_write (bitssec_rcvd_gstathandle, 	packet_MSDU_size);
	op_stat_write (bitssec_rcvd_gstathandle, 	0.0);
	op_stat_write (pktssec_rcvd_gstathandle, 	1.0);
	op_stat_write (pktssec_rcvd_gstathandle, 	0.0);
	
	/* Destroy the received packet */
	op_pk_destroy (packet_MSDU_ptr);
	
	op_ici_destroy (iciptr);

	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	wpan_sequence_number()
 *
 * Description:	Generate a random sequence number. 
 *
 * Output: random number  
 *--------------------------------------------------------------------------------*/

static int wpan_sequence_number() {
	
	int seq_num;
	int max_seq;
	
	/* Stack tracing enrty point */

	FIN(wpan_sequence_number);
	
	max_seq = 255;
		
	seq_num = floor (op_dist_uniform (max_seq));
	
	/* Stack tracing exit point */
	FRET(seq_num);
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_process_payload()
 *
 * Description:	Process a random payload for the nodes. 
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_process_payload()
{

FIN(wpan_process_payload);

	/* Initialise the fuzzy array structure that reads the node name and payload values */
	
	sizeArray = 6;
	fuzzyptr = (fuzzyArray*)op_prg_mem_alloc(6*sizeof(fuzzyArray*));
//	fuzzyArray *fuzzyptr = fuzzyGroup;
	
	
//	fuzzyGroup[Index].nodeName = (char *)op_prg_mem_alloc(sizeof(char));
	strcpy(fuzzyGroup[Index].nodeName,device_name);
	
			
	fuzzyGroup[Index].payLoad = wpan_random_payload();
//	printf("PayLoad in get call : %d \n", fuzzyGroup[Index].payLoad);
	Index++;

FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	wpan_random_payload()
 *
 * Description:	Generate a random payload for the nodes. 
 *
 * No parameters
 *--------------------------------------------------------------------------------*/
static int wpan_random_payload()
{

FIN(wpan_random_payload);


	if (prg_string_order_case_insensitive(device_name,"Blood Pressure") == 0){
		pay_load = floor(op_dist_uniform (250));
		
		if(pay_load >= 100 && pay_load <= 185) 
			OUT_OF_NORMAL_DATA_BP = 0;
		}
	
	else if (prg_string_order_case_insensitive(device_name,"Heart Rate") == 0){
		pay_load = floor(op_dist_uniform (70));
		
		if(pay_load >= 60 && pay_load <= 95) 
			OUT_OF_NORMAL_DATA_HR = 0;
		}
	
	else if (prg_string_order_case_insensitive(device_name, "SPO2") == 0){
		pay_load= floor(op_dist_uniform (100));
		
		if(pay_load >= 95 && pay_load <= 150) 
			OUT_OF_NORMAL_DATA_SPO2 = 0;
		}
	
	else if (prg_string_order_case_insensitive(device_name, "Temperature") == 0){
		pay_load = floor(op_dist_uniform (50));
		
		if(pay_load >= 36 && pay_load <= 38) 
			OUT_OF_NORMAL_DATA_Temp = 0;
		}
	
	else if (prg_string_order_case_insensitive(device_name, "Blood Sugar") == 0){
		pay_load = floor(op_dist_uniform (500));
		
		if(pay_load >= 72 && pay_load <= 106) 
			OUT_OF_NORMAL_DATA_BS = 0;
		}
	
	printf("Pay Load : %d \n", pay_load);
	

FRET(pay_load);
}



/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void wpan_application_router (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_wpan_application_router_init (int * init_block_ptr);
	void _op_wpan_application_router_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_wpan_application_router_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_wpan_application_router_alloc (VosT_Obtype, int);
	void _op_wpan_application_router_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
wpan_application_router (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wpan_application_router ());

		{


		FSM_ENTER ("wpan_application_router")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "init", "wpan_application_router [init enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_application_router [init enter execs]", state0_enter_exec)
				{
				/* Initialization */
				wpan_appl_init ();
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "init", "wpan_application_router [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "init", "idle", "tr_1", "wpan_application_router [init -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "idle", state1_enter_exec, "wpan_application_router [idle enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"wpan_application_router")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "idle", "wpan_application_router [idle exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_application_router [idle exit execs]", state1_exit_exec)
				{
				intrpt_type = op_intrpt_type ();
				
				/*
				if (intrpt_type == OPC_INTRPT_STRM)
					intrpt_strm = op_intrpt_strm ();
				else
					intrpt_code = op_intrpt_code ();
				*/
				
				switch (intrpt_type) {
					case OPC_INTRPT_STRM:
					{
						intrpt_strm = op_intrpt_strm ();
						break;
					};
					
					case OPC_INTRPT_SELF:
					{
						intrpt_code = op_intrpt_code ();
						break;
					};
					
					case OPC_INTRPT_ENDSIM:
					{
						printf ("|------------------------ APPLICATION STATISTICS -----------------------------|\n");
						printf (" Node %s (#%d) \n", device_name, my_address);
						printf ("  Number of GENERATED real-time data frames = %d  \n", rt_generated_frames);
						printf ("  Number of GENERATED best-effort data frames = %d  \n\n", be_generated_frames);
						printf ("|-----------------------------------------------------------------------------|\n\n");
						
						/* scalar statistics */
						op_stat_scalar_write ("Real-time data frames GENERATED", rt_generated_frames);
						op_stat_scalar_write ("Best-effort data frames GENERATED", be_generated_frames);
						
						break;
					};
					
					default :
					{
					};	
				}
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_application_router [idle trans conditions]", state1_trans_conds)
			FSM_INIT_COND (SEND_BE)
			FSM_TEST_COND (SEND_RT)
			FSM_TEST_COND (RECEIVE_PCK)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "SEND_BE", "", "idle", "send BE", "send best-effort packet", "wpan_application_router [idle -> send BE : SEND_BE / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "SEND_RT", "", "idle", "send RT", "send real-time packet", "wpan_application_router [idle -> send RT : SEND_RT / ]")
				FSM_CASE_TRANSIT (2, 4, state4_enter_exec, ;, "RECEIVE_PCK", "", "idle", "receive pck", "receive packet from NWK", "wpan_application_router [idle -> receive pck : RECEIVE_PCK / ]")
				FSM_CASE_TRANSIT (3, 1, state1_enter_exec, ;, "default", "", "idle", "idle", "tr_13", "wpan_application_router [idle -> idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (send BE) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "send BE", state2_enter_exec, "wpan_application_router [send BE enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_application_router [send BE enter execs]", state2_enter_exec)
				{
				wpan_be_packet_generate();
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (send BE) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "send BE", "wpan_application_router [send BE exit execs]")


			/** state (send BE) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "send BE", "idle", "tr_6", "wpan_application_router [send BE -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (send RT) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "send RT", state3_enter_exec, "wpan_application_router [send RT enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_application_router [send RT enter execs]", state3_enter_exec)
				{
				wpan_rt_packet_generate();
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (send RT) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "send RT", "wpan_application_router [send RT exit execs]")


			/** state (send RT) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "send RT", "idle", "tr_8", "wpan_application_router [send RT -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (receive pck) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "receive pck", state4_enter_exec, "wpan_application_router [receive pck enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_application_router [receive pck enter execs]", state4_enter_exec)
				{
				wpan_receive_pck_from_nwk();
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (receive pck) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "receive pck", "wpan_application_router [receive pck exit execs]")


			/** state (receive pck) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "receive pck", "idle", "tr_10", "wpan_application_router [receive pck -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"wpan_application_router")
		}
	}




void
_op_wpan_application_router_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_wpan_application_router_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_wpan_application_router_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_wpan_application_router_svar function. */
#undef self_id
#undef parent_id
#undef device_mode
#undef device_name
#undef my_address
#undef enable_log
#undef intrpt_type
#undef intrpt_strm
#undef intrpt_code
#undef be_packet_interarrival_dist_ptr
#undef be_packet_size_dist_ptr
#undef be_packet_interarrival_dist_str
#undef be_packet_size_dist_str
#undef be_start_time
#undef be_stop_time
#undef be_ack
#undef rt_packet_interarrival_dist_ptr
#undef rt_packet_size_dist_ptr
#undef rt_packet_interarrival_dist_str
#undef rt_packet_size_dist_str
#undef rt_start_time
#undef rt_stop_time
#undef rt_ack
#undef dest_mac_address
#undef bits_rcvd_MSDU_be_stathandle
#undef bits_rcvd_MSDU_rt_stathandle
#undef bitssec_rcvd_MSDU_be_stathandle
#undef bits_rcvd_NSDU_be_stathandle
#undef bits_rcvd_NSDU_rt_stathandle
#undef bitssec_rcvd_NSDU_be_stathandle
#undef pkts_rcvd_be_stathandle
#undef pkts_rcvd_rt_stathandle
#undef pktssec_rcvd_be_stathandle
#undef pktssec_rcvd_rt_stathandle
#undef bits_sent_MSDU_be_stathandle
#undef bits_sent_MSDU_rt_stathandle
#undef bits_sent_NSDU_be_stathandle
#undef bits_sent_NSDU_rt_stathandle
#undef pkts_sent_be_stathandle
#undef pkts_sent_rt_stathandle
#undef ete_delay_be_stathandle
#undef ete_delay_rt_stathandle
#undef bits_rcvd_MSDU_be_gstathandle
#undef bits_rcvd_MSDU_rt_gstathandle
#undef bitssec_rcvd_gstathandle
#undef pkts_rcvd_be_gstathandle
#undef pkts_rcvd_rt_gstathandle
#undef pktssec_rcvd_gstathandle
#undef ete_delay_be_gstathandle
#undef ete_delay_rt_gstathandle
#undef bits_sent_MSDU_be_gstathandle
#undef bits_sent_MSDU_rt_gstathandle
#undef pkts_sent_be_gstathandle
#undef pkts_sent_rt_gstathandle
#undef rt_generated_frames
#undef be_generated_frames
#undef pay_load
#undef sizeArray

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_wpan_application_router_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_wpan_application_router_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (wpan_application_router)",
		sizeof (wpan_application_router_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_wpan_application_router_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wpan_application_router_state * ptr;
	FIN_MT (_op_wpan_application_router_alloc (obtype))

	ptr = (wpan_application_router_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "wpan_application_router [init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_wpan_application_router_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wpan_application_router_state		*prs_ptr;

	FIN_MT (_op_wpan_application_router_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wpan_application_router_state *)gen_ptr;

	if (strcmp ("self_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->self_id);
		FOUT
		}
	if (strcmp ("parent_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->parent_id);
		FOUT
		}
	if (strcmp ("device_mode" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->device_mode);
		FOUT
		}
	if (strcmp ("device_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->device_name);
		FOUT
		}
	if (strcmp ("my_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_address);
		FOUT
		}
	if (strcmp ("enable_log" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->enable_log);
		FOUT
		}
	if (strcmp ("intrpt_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_type);
		FOUT
		}
	if (strcmp ("intrpt_strm" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_strm);
		FOUT
		}
	if (strcmp ("intrpt_code" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_code);
		FOUT
		}
	if (strcmp ("be_packet_interarrival_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->be_packet_interarrival_dist_ptr);
		FOUT
		}
	if (strcmp ("be_packet_size_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->be_packet_size_dist_ptr);
		FOUT
		}
	if (strcmp ("be_packet_interarrival_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->be_packet_interarrival_dist_str);
		FOUT
		}
	if (strcmp ("be_packet_size_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->be_packet_size_dist_str);
		FOUT
		}
	if (strcmp ("be_start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->be_start_time);
		FOUT
		}
	if (strcmp ("be_stop_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->be_stop_time);
		FOUT
		}
	if (strcmp ("be_ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->be_ack);
		FOUT
		}
	if (strcmp ("rt_packet_interarrival_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rt_packet_interarrival_dist_ptr);
		FOUT
		}
	if (strcmp ("rt_packet_size_dist_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rt_packet_size_dist_ptr);
		FOUT
		}
	if (strcmp ("rt_packet_interarrival_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->rt_packet_interarrival_dist_str);
		FOUT
		}
	if (strcmp ("rt_packet_size_dist_str" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->rt_packet_size_dist_str);
		FOUT
		}
	if (strcmp ("rt_start_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rt_start_time);
		FOUT
		}
	if (strcmp ("rt_stop_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rt_stop_time);
		FOUT
		}
	if (strcmp ("rt_ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rt_ack);
		FOUT
		}
	if (strcmp ("dest_mac_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->dest_mac_address);
		FOUT
		}
	if (strcmp ("bits_rcvd_MSDU_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_rcvd_MSDU_be_stathandle);
		FOUT
		}
	if (strcmp ("bits_rcvd_MSDU_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_rcvd_MSDU_rt_stathandle);
		FOUT
		}
	if (strcmp ("bitssec_rcvd_MSDU_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bitssec_rcvd_MSDU_be_stathandle);
		FOUT
		}
	if (strcmp ("bits_rcvd_NSDU_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_rcvd_NSDU_be_stathandle);
		FOUT
		}
	if (strcmp ("bits_rcvd_NSDU_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_rcvd_NSDU_rt_stathandle);
		FOUT
		}
	if (strcmp ("bitssec_rcvd_NSDU_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bitssec_rcvd_NSDU_be_stathandle);
		FOUT
		}
	if (strcmp ("pkts_rcvd_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_rcvd_be_stathandle);
		FOUT
		}
	if (strcmp ("pkts_rcvd_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_rcvd_rt_stathandle);
		FOUT
		}
	if (strcmp ("pktssec_rcvd_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pktssec_rcvd_be_stathandle);
		FOUT
		}
	if (strcmp ("pktssec_rcvd_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pktssec_rcvd_rt_stathandle);
		FOUT
		}
	if (strcmp ("bits_sent_MSDU_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_MSDU_be_stathandle);
		FOUT
		}
	if (strcmp ("bits_sent_MSDU_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_MSDU_rt_stathandle);
		FOUT
		}
	if (strcmp ("bits_sent_NSDU_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_NSDU_be_stathandle);
		FOUT
		}
	if (strcmp ("bits_sent_NSDU_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_NSDU_rt_stathandle);
		FOUT
		}
	if (strcmp ("pkts_sent_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_sent_be_stathandle);
		FOUT
		}
	if (strcmp ("pkts_sent_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_sent_rt_stathandle);
		FOUT
		}
	if (strcmp ("ete_delay_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ete_delay_be_stathandle);
		FOUT
		}
	if (strcmp ("ete_delay_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ete_delay_rt_stathandle);
		FOUT
		}
	if (strcmp ("bits_rcvd_MSDU_be_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_rcvd_MSDU_be_gstathandle);
		FOUT
		}
	if (strcmp ("bits_rcvd_MSDU_rt_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_rcvd_MSDU_rt_gstathandle);
		FOUT
		}
	if (strcmp ("bitssec_rcvd_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bitssec_rcvd_gstathandle);
		FOUT
		}
	if (strcmp ("pkts_rcvd_be_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_rcvd_be_gstathandle);
		FOUT
		}
	if (strcmp ("pkts_rcvd_rt_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_rcvd_rt_gstathandle);
		FOUT
		}
	if (strcmp ("pktssec_rcvd_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pktssec_rcvd_gstathandle);
		FOUT
		}
	if (strcmp ("ete_delay_be_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ete_delay_be_gstathandle);
		FOUT
		}
	if (strcmp ("ete_delay_rt_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ete_delay_rt_gstathandle);
		FOUT
		}
	if (strcmp ("bits_sent_MSDU_be_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_MSDU_be_gstathandle);
		FOUT
		}
	if (strcmp ("bits_sent_MSDU_rt_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bits_sent_MSDU_rt_gstathandle);
		FOUT
		}
	if (strcmp ("pkts_sent_be_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_sent_be_gstathandle);
		FOUT
		}
	if (strcmp ("pkts_sent_rt_gstathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkts_sent_rt_gstathandle);
		FOUT
		}
	if (strcmp ("rt_generated_frames" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->rt_generated_frames);
		FOUT
		}
	if (strcmp ("be_generated_frames" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->be_generated_frames);
		FOUT
		}
	if (strcmp ("pay_load" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pay_load);
		FOUT
		}
	if (strcmp ("sizeArray" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sizeArray);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

