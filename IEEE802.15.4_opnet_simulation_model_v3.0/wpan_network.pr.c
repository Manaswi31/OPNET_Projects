/* Process model C form file: wpan_network.pr.c */
/* Portions of this file copyright 2014 by Riverbed Technology. All rights reserved. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from wpan_network.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char wpan_network_pr_c [] = "MIL_3_Tfile_Hdr_ 1800 30A modeler 7 566F1279 566F1279 1 volta chaganti 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 468d 2                                                                                                                                                                                                                                                                                                                                                                                                           ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/* Include files					*/
#include <wpan_math1.h>
#include <wpan_struct1.h>
#include <wpan_params1.h>
#include <math.h>


/* Node configuration constants		*/


/* Special attribute values			*/


/* Interrupt code values			*/


/* Input and output streams		*/
#define	STRM_FROM_APPL_TO_NWK	0
#define	STRM_FROM_NWK_TO_APPL	0
#define	STRM_FROM_MAC_TO_NWK	1
#define	STRM_FROM_NWK_TO_MAC	1


/* State machine conditions 		*/
#define IAM_PAN_COORDINATOR 	(device_mode == PAN_COORDINATOR)
#define IAM_ROUTER 				(device_mode == ROUTER)
#define IAM_END_DEVICE 			(device_mode == END_DEVICE)

#define RECEIVE_PCK_FROM_APPL	(intrpt_type == OPC_INTRPT_STRM && intrpt_strm == STRM_FROM_APPL_TO_NWK)
#define RECEIVE_PCK_FROM_MAC	(intrpt_type == OPC_INTRPT_STRM && intrpt_strm == STRM_FROM_MAC_TO_NWK)



/* Function prototypes.				*/
static void wpan_nwk_init (void);  
static void wpan_print_parameters (void);
static void wpan_receive_pck_from_appl (void);
static void wpan_receive_pck_from_mac (void);
static float wpan_cskip_function (int);
static int wpan_next_hop_get (int);
static void wpan_check_my_address (void); 


/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		self_id                                         ;
	Objid	                  		parent_id                                       ;
	int	                    		device_mode                                     ;
	char	                   		device_name[20]                                 ;
	int	                    		my_address                                      ;
	Boolean	                		enable_log                                      ;
	int	                    		intrpt_type                                     ;
	int	                    		intrpt_strm                                     ;
	int	                    		intrpt_code                                     ;
	int	                    		max_router                                      ;
	int	                    		max_children                                    ;
	int	                    		max_depth                                       ;
	int	                    		my_parent_address                               ;
	int	                    		device_depth                                    ;
	Stathandle	             		ete_delay_be_stathandle                         ;
	Stathandle	             		ete_delay_rt_stathandle                         ;
	} wpan_network_state;

#define pr_state_ptr            		((wpan_network_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr))
#define self_id                 		pr_state_ptr->self_id
#define parent_id               		pr_state_ptr->parent_id
#define device_mode             		pr_state_ptr->device_mode
#define device_name             		pr_state_ptr->device_name
#define my_address              		pr_state_ptr->my_address
#define enable_log              		pr_state_ptr->enable_log
#define intrpt_type             		pr_state_ptr->intrpt_type
#define intrpt_strm             		pr_state_ptr->intrpt_strm
#define intrpt_code             		pr_state_ptr->intrpt_code
#define max_router              		pr_state_ptr->max_router
#define max_children            		pr_state_ptr->max_children
#define max_depth               		pr_state_ptr->max_depth
#define my_parent_address       		pr_state_ptr->my_parent_address
#define device_depth            		pr_state_ptr->device_depth
#define ete_delay_be_stathandle 		pr_state_ptr->ete_delay_be_stathandle
#define ete_delay_rt_stathandle 		pr_state_ptr->ete_delay_rt_stathandle

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	wpan_network_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((wpan_network_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/********************************************************************************* 
				IEEE 802.15.4/ZigBee OPNET Simulation Model
**********************************************************************************

Author: Petr Jurcik <petr@isep.ipp.pt> <jurcikp@control.felk.cvut.cz>
Author: Anis Koubaa <aska@isep.ipp.pt>

Organization:
	IPP-HURRAY Research Group
	CISTER/ISEP
	Polytechnic Institute of Porto, Portugal

Organization:
	Department of Control Engineering
	Faculty of Electrical Engineering
	Czech Technical University in Prague, Czech Republic
 
Copyright (c) 2007 - 2009 

This file is part of IEEE 802.15.4/ZigBee OPNET Simulation Model for OPNET Modeler. IEEE 802.15.4/ZigBee OPNET Simulation Model can be used, copied and modified under the next licenses:
 
 - GPL - GNU General Public License
 
Code can be modified and re-distributed under any combination of the above listed licenses. If a contributor does not agree with some of the licenses, he/she can delete appropriate line. If you delete all lines, you are not allowed to distribute source code and/or binaries utilizing code.


**********************************************************************************
                           GNU General Public License  

IEEE 802.15.4/ZigBee OPNET Simulation Model is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later version.
 
IEEE 802.15.4/ZigBee OPNET Simulation Model is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with IEEE 802.15.4/ZigBee OPNET Simulation Model; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 

*********************************************************************************/

/*--------------------------------------------------------------------------------
 * Function:	wpan_nwk_init
 *
 * Description:	- initialize the process
 *				- read the values of attributes
 *              - schedule a self interrupts 
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_nwk_init () {

	
	/* Stack tracing enrty point */
	FIN(wpan_nwk_init);
	
	/* obtain self object ID of the surrounding processor or queue */
	self_id = op_id_self ();

	/* obtain object ID of the parent object (node) */
	parent_id = op_topo_parent (self_id);
	
	/* get value to check if this node is PAN coordinator, Router, or End node */
	op_ima_obj_attr_get_int32 (parent_id, "Device Mode", &device_mode);
	
	/* get name of the node */
	op_ima_obj_attr_get (parent_id, "name", device_name);
	
	op_ima_obj_attr_get (parent_id, "Enable Logging", &enable_log);
	
	/* get address of the node */
	op_ima_obj_attr_get (parent_id, "MAC Address", &my_address);
	
	/* get address of my parent */
	op_ima_obj_attr_get (parent_id, "Parent Address", &my_parent_address);
	
	/* get network parameters */
	op_ima_obj_attr_get (self_id, "Maximum Routers", &max_router);
	op_ima_obj_attr_get (self_id, "Maximum Children", &max_children);
	op_ima_obj_attr_get (self_id, "Maximum Depth", &max_depth);
	op_ima_obj_attr_get (self_id, "Device Depth", &device_depth);
	
	if (max_children < max_router)
		op_sim_end("Maximum children must be equal or greater than Maximum Routers","Check the Network Parameters.","","");
	
	if (device_depth > max_depth)
		op_sim_end("Device depth cannot be greater than Maximum Depth","Check the Network Parameters - Device Depth.","","");
	
	if (!IAM_PAN_COORDINATOR && (my_parent_address == NO_PARENT))
		op_sim_end("No parent assigned to a device.","Check the Network Parameters - Parent Address.","","");	
		
	
	/* register the LOCAL statistics */
	ete_delay_be_stathandle = op_stat_reg ("End-to-end delay - best-effort (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	ete_delay_rt_stathandle = op_stat_reg ("End-to-end delay - real-time (sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	//bits_rcvd_stathandle 		= op_stat_reg ("Application.Traffic Received (bits)",			OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	/* register the GLOBAL statistics */
	//bits_rcvd_gstathandle 		= op_stat_reg ("Application.Traffic Received (bits)",			OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);

	
	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	 wpan_print_parameters
 *
 * Description:	Print the parameters.
 *				
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_print_parameters () {

	/* Stack tracing enrty point */	
	FIN(wpan_print_parameters);

	if (enable_log) {		
		printf ("|--------------------------- NETWORK LAYER -----------------------------------|\n");
		printf (" [Node %s (#%d)] \n", device_name, my_address);
		printf (" Maximum child routers (Rm)  : %d \n", max_router);
		printf (" Maximum children nodes (Cm) : %d \n", max_children);
		printf (" Maximum depth (Lm)          : %d \n\n", max_depth);
		printf (" Current depth of the node   : %d \n", device_depth);	
		printf ("|-----------------------------------------------------------------------------|\n\n");
	}
	
	/* Stack tracing exit point */
	FOUT;
}


/*--------------------------------------------------------------------------------
 * Function:	 wpan_receive_pck_from_appl
 *
 * Description:	Received packet from Application Layer. Calculate next hop address and send it to
 *				to the MAC layer.
 *				
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_receive_pck_from_appl () {

	Ici* iciptr;
	Packet* packet_MSDU_ptr;	
	int dest_nwk_address;
	int next_hop_address;

	/* Stack tracing enrty point */	
	FIN(wpan_receive_pck_from_appl);
	
	/* get the ICI information */
	iciptr = op_intrpt_ici ();
	
	
	/* Get packet from the input stream  */
	packet_MSDU_ptr = op_pk_get (intrpt_strm);
	
	op_pk_nfd_get (packet_MSDU_ptr, "Destination Address", &dest_nwk_address);
	
	if (dest_nwk_address == my_address) {
		/* I am destination */
		op_pk_destroy (packet_MSDU_ptr); /* drop packet */
		op_ici_destroy (iciptr);		
	} else {
		next_hop_address = wpan_next_hop_get (dest_nwk_address);
		
		/* Update ICI */
		op_ici_attr_set (iciptr, "Next Hop Address", next_hop_address);
		
		/* resend MSDU via the stream to MAC layer.	*/
		/* send ICI to MAC layer together with packet. */
		op_ici_install (iciptr);
		op_pk_send (packet_MSDU_ptr, STRM_FROM_NWK_TO_MAC);
		printf("N/W Layer : Received packet from APPLICATION LAYER and sent to MAC layer \n");
		op_ici_install (OPC_NIL);		
		
		if (enable_log) {
			printf (" [%s (#%d)] t=%f -> (NWK) Packet's payload (MSDU) was received from APPL layer and was forwarded to MAC layer \n", device_name, my_address, op_sim_time());
			printf ("\t + Packet will be route to the node #%d (destination NWK Address is #%d) \n\n", next_hop_address, dest_nwk_address);
		}		
	}


	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	 wpan_receive_pck_from_mac
 *
 * Description:	Received packet's payload (MSDU) from MAC Layer. Route or resend MSDU to Application layer. 
 *				
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_receive_pck_from_mac () {

	Ici* iciptr;
	Packet* packet_MSDU_ptr;	
	int dest_nwk_address;
	int next_hop_address;
	double e2e_delay;
	int traffic_type;
	int pkt_MSDU_size;

	/* Stack tracing enrty point */	
	FIN(wpan_receive_pck_from_mac);
	
	/* get the ICI information */
	iciptr = op_intrpt_ici ();
	
	/* Get packet from the input stream  */
	packet_MSDU_ptr = op_pk_get (intrpt_strm);
	
	
	if (iciptr != OPC_NIL) {	
		op_pk_nfd_get (packet_MSDU_ptr, "Destination Address", &dest_nwk_address);
	
		if (dest_nwk_address == my_address) {
		
			op_ici_attr_get (iciptr, "Traffic Type", &traffic_type);
	
			e2e_delay = op_sim_time () - op_pk_stamp_time_get (packet_MSDU_ptr);
		
			if (enable_log) {
				printf (" [%s (#%d)] t=%f -> (NWK) Received packet - I am the destination. \n", device_name, my_address, op_sim_time());
				printf ("\t\t End-to-end delay (MAC)   : %f sec \n", e2e_delay);
				pkt_MSDU_size = (double) op_pk_total_size_get (packet_MSDU_ptr);
				
			}
			
			/* update the statistics */				
			if (traffic_type == REAL_TIME_TRAFFIC) {
				op_stat_write (ete_delay_rt_stathandle, e2e_delay);			
			} else {	/* BEST_EFFORT_TRAFFIC */
				op_stat_write (ete_delay_be_stathandle, e2e_delay);			
			}	
		
			/* I am destination - send packet's payload (MSDU) to Application layer */
			/* send ICI to MAC layer together with packet. */
			op_ici_install (iciptr);
			op_pk_send (packet_MSDU_ptr, STRM_FROM_NWK_TO_APPL); 
			op_ici_install (OPC_NIL);
		} else {
			/* I am not destination - route packet */	
			next_hop_address = wpan_next_hop_get (dest_nwk_address);
		
			/* Update ICI */
			op_ici_attr_set (iciptr, "Next Hop Address", next_hop_address);
		
			/* resend packet's payload (MSDU) via the stream back to MAC layer.	*/
			/* send ICI to MAC layer together with packet. */
			op_ici_install (iciptr);
			op_pk_send (packet_MSDU_ptr, STRM_FROM_NWK_TO_MAC);
			op_ici_install (OPC_NIL);	
		
			if (enable_log) {
				printf (" [%s (#%d)] t=%f -> (NWK) Packet's payload (MSDU) was received from MAC layer and has been forwarded back to MAC layer \n", device_name, my_address, op_sim_time());
				printf ("\t + Packet will be route to the node #%d (Destination NWK Address is #%d). \n\n", next_hop_address, dest_nwk_address);
				
			}
		}
	} else {
		op_sim_error(OPC_SIM_ERROR_WARNING, "(NWK) Packet error","Packet from MAC layer was received without ICI.");
	}
		

	/* Stack tracing exit point */
	FOUT;
}

/*--------------------------------------------------------------------------------
 * Function:	 wpan_cskip_function
 *
 * Description:	Calculate Cskip function depending on the device depth.
 *
 * Input: depth
 *
 * Return: cskip
 *--------------------------------------------------------------------------------*/

static float wpan_cskip_function (depth) {

	float cskip;
	
	/* Stack tracing enrty point */	
	FIN(wpan_cskip_function(int));
	
	if (max_router == 1) {
		cskip = 1 + max_children * (max_depth - depth - 1);
	} else {
		cskip = (1 + max_children - max_router - max_children * pow(max_router, max_depth - depth - 1))/(1 - max_router);
	}

	/* Stack tracing exit point */
	FRET(cskip);
}

/*--------------------------------------------------------------------------------
 * Function:	 wpan_next_hop_get
 *
 * Description:	Calculate Cskip function depending on the device depth.
 *	
 * Input: dest_nwk_address - destination network address
 *
 * Return: MAC address of next hop
 *--------------------------------------------------------------------------------*/

static int wpan_next_hop_get (dest_nwk_address) {

	int next_hop_address;
	int cskip;
	
	/* Stack tracing enrty point */	
	FIN(wpan_next_hop_get);
	
	cskip = wpan_cskip_function(device_depth);
	
	/* Check if the dest_address is my descent */
	if ((dest_nwk_address > my_address) && (dest_nwk_address < (my_address + wpan_cskip_function(device_depth-1))) && (!IAM_END_DEVICE)) 
		next_hop_address = my_address + 1 + floor((dest_nwk_address - (my_address + 1))/cskip)*cskip;
	
	else /* Destination is not my descent, send packet to my parent */
		next_hop_address = my_parent_address;


	/* Stack tracing exit point */
	FRET(next_hop_address);
}

/*--------------------------------------------------------------------------------
 * Function:	 wpan_check_my_address
 *
 * Description:	Check if the my MAC address is right - according to the ZigBee Tree 
 *				short adress assigment scheme.
 *
 * No parameters
 *--------------------------------------------------------------------------------*/

static void wpan_check_my_address () {

	float cskip;
	int number_of_end_node;

	
	/* Stack tracing enrty point */	
	FIN(wpan_check_my_address);
	
/*	if (IAM_PAN_COORDINATOR) {
		if (my_address != 0) {
			op_sim_end("In cluster-tree topology, PAN Coordinator address should be equal to 0","Check parameters.","","");	
		}
	} else if (IAM_ROUTER) {	
		/* test integer value */
	/*	if (fmod((my_address - my_parent_address - 1)/wpan_cskip_function (device_depth-1), 1) != 0) {
			printf (" [%s] Device MAC address (#%d) is wrong - it does not correspond to the parent router (#%d) and device depth (%d). \n", device_name, my_address, my_parent_address, device_depth);
			op_sim_end("In cluster-tree topology, some router's MAC address is wrong.","See simulation console output for details.","","");
		}
	} else {
		cskip = wpan_cskip_function (device_depth - 2);
		number_of_end_node = max_children - max_router;
	
		if ((my_address > (my_parent_address + cskip)) || (my_address < (my_parent_address + cskip - number_of_end_node))) {
			printf (" [%s] Device MAC address (#%d) is wrong - it does not correspond to parent router (#%d) and device depth (%d). \n", device_name, my_address, my_parent_address, device_depth);
			op_sim_end("In cluster-tree topology, some end-device's MAC address is wrong.","See simulation console output for details.","","");
		}	
	} */	

	/* Stack tracing exit point */
	FOUT;
}



/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void wpan_network (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_wpan_network_init (int * init_block_ptr);
	void _op_wpan_network_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_wpan_network_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_wpan_network_alloc (VosT_Obtype, int);
	void _op_wpan_network_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
wpan_network (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (wpan_network ());

		{


		FSM_ENTER ("wpan_network")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "init", "wpan_network [init enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_network [init enter execs]", state0_enter_exec)
				{
				/* Initialization */
				wpan_nwk_init ();
				wpan_print_parameters ();
				wpan_check_my_address ();
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "init", "wpan_network [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "init", "idle", "tr_11", "wpan_network [init -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "idle", state1_enter_exec, "wpan_network [idle enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"wpan_network")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "idle", "wpan_network [idle exit execs]")
				FSM_PROFILE_SECTION_IN ("wpan_network [idle exit execs]", state1_exit_exec)
				{
				intrpt_type = op_intrpt_type ();
				if (intrpt_type == OPC_INTRPT_STRM)
					intrpt_strm = op_intrpt_strm ();
				else
					intrpt_code = op_intrpt_code ();
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("wpan_network [idle trans conditions]", state1_trans_conds)
			FSM_INIT_COND (RECEIVE_PCK_FROM_APPL)
			FSM_TEST_COND (RECEIVE_PCK_FROM_MAC)
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "RECEIVE_PCK_FROM_APPL", "", "idle", "from APPL", "receive packet from APPL", "wpan_network [idle -> from APPL : RECEIVE_PCK_FROM_APPL / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "RECEIVE_PCK_FROM_MAC", "", "idle", "from MAC", "tr_14", "wpan_network [idle -> from MAC : RECEIVE_PCK_FROM_MAC / ]")
				}
				/*---------------------------------------------------------*/



			/** state (from APPL) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "from APPL", state2_enter_exec, "wpan_network [from APPL enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_network [from APPL enter execs]", state2_enter_exec)
				{
				wpan_receive_pck_from_appl ();
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (from APPL) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "from APPL", "wpan_network [from APPL exit execs]")


			/** state (from APPL) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "from APPL", "idle", "tr_13", "wpan_network [from APPL -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (from MAC) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "from MAC", state3_enter_exec, "wpan_network [from MAC enter execs]")
				FSM_PROFILE_SECTION_IN ("wpan_network [from MAC enter execs]", state3_enter_exec)
				{
				wpan_receive_pck_from_mac ();
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (from MAC) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "from MAC", "wpan_network [from MAC exit execs]")


			/** state (from MAC) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "from MAC", "idle", "tr_15", "wpan_network [from MAC -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"wpan_network")
		}
	}




void
_op_wpan_network_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_wpan_network_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_wpan_network_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (pr_state_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_wpan_network_svar function. */
#undef self_id
#undef parent_id
#undef device_mode
#undef device_name
#undef my_address
#undef enable_log
#undef intrpt_type
#undef intrpt_strm
#undef intrpt_code
#undef max_router
#undef max_children
#undef max_depth
#undef my_parent_address
#undef device_depth
#undef ete_delay_be_stathandle
#undef ete_delay_rt_stathandle

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_wpan_network_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_wpan_network_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (wpan_network)",
		sizeof (wpan_network_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_wpan_network_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	wpan_network_state * ptr;
	FIN_MT (_op_wpan_network_alloc (obtype))

	ptr = (wpan_network_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "wpan_network [init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_wpan_network_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	wpan_network_state		*prs_ptr;

	FIN_MT (_op_wpan_network_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (wpan_network_state *)gen_ptr;

	if (strcmp ("self_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->self_id);
		FOUT
		}
	if (strcmp ("parent_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->parent_id);
		FOUT
		}
	if (strcmp ("device_mode" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->device_mode);
		FOUT
		}
	if (strcmp ("device_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (prs_ptr->device_name);
		FOUT
		}
	if (strcmp ("my_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_address);
		FOUT
		}
	if (strcmp ("enable_log" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->enable_log);
		FOUT
		}
	if (strcmp ("intrpt_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_type);
		FOUT
		}
	if (strcmp ("intrpt_strm" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_strm);
		FOUT
		}
	if (strcmp ("intrpt_code" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_code);
		FOUT
		}
	if (strcmp ("max_router" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_router);
		FOUT
		}
	if (strcmp ("max_children" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_children);
		FOUT
		}
	if (strcmp ("max_depth" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_depth);
		FOUT
		}
	if (strcmp ("my_parent_address" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_parent_address);
		FOUT
		}
	if (strcmp ("device_depth" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->device_depth);
		FOUT
		}
	if (strcmp ("ete_delay_be_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ete_delay_be_stathandle);
		FOUT
		}
	if (strcmp ("ete_delay_rt_stathandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ete_delay_rt_stathandle);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

